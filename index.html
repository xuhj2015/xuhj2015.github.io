<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":20},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="循序渐进">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="循序渐进">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="xuhj">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>循序渐进</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?c67d6bf4daca1c3be5f919ad1f2ce211";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">循序渐进</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-navigation">

    <a href="/navigation/" rel="section"><i class="fa fa-archive fa-fw"></i>目录</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/10/%E6%8A%80%E6%9C%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="xuhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="循序渐进">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/10/%E6%8A%80%E6%9C%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">Redis简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-10 00:00:00 / 修改时间：15:25:02" itemprop="dateCreated datePublished" datetime="2021-11-10T00:00:00+08:00">2021-11-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">计算机技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。<br>string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。</p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>可以用于存储、读取、修改用户属性。<br>每个 hash 可以存储 2的32次方-1 个键值对（40多亿）。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>增删快，提供了操作某一段元素的API。<br>可以用于1、最新消息排行等功能(比如朋友圈的时间线)，2、消息队列。<br>列表最多可存储 2的32次方-1 个元素（40多亿）。</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。<br>为集合提供了求交集、并集、差集等操作。<br>可以用于1、共同好友，2、利用唯一性，统计访问网站的所有独立ip，3、好友推荐时，根据tag求交集，大于某个阈值就可以推荐。<br>集合中最大的成员数为 2的32次方-1。</p>
<h2 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h2><p>将Set中的元素增加一个权重参数score，元素按score有序排列。<br>数据插入集合时，已经进行天然排序。<br>可以用于1、排行榜，2、带权重的消息队列。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/09/%E6%8A%80%E6%9C%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="xuhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="循序渐进">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/09/%E6%8A%80%E6%9C%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/" class="post-title-link" itemprop="url">Redis持久化策略</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-09 00:00:00 / 修改时间：16:37:24" itemprop="dateCreated datePublished" datetime="2021-11-09T00:00:00+08:00">2021-11-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">计算机技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Redis提供两种方式进行持久化，RDB(redis database)和AOF(append only file)。</p>
<h1 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h1><p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p>
<p>Redis会将数据集的快照dump到dump.rdb文件中。此外，也可以通过配置文件来修改Redis服务器dump快照的频率，在配置文件中可以看到下面的配置信息：<br>save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照。<br>save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照。<br>save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照。</p>
<h1 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h1><p>AOF是类似于log的机制，每次写操作都会将记录写到硬盘上，当系统崩溃时，可以通过AOF来恢复数据。每个带有写操作的命令被Redis服务器端收到运行时，该命令都会被记录到AOF文件上。由于只是一个append到文件操作，所以写到硬盘上的操作往往非常快。</p>
<p>AOF在Redis的配置文件中存在三种同步方式，它们分别是：<br>appendfsync always     #每次有数据修改发生时都会写入AOF文件。<br>appendfsync everysec   #每秒钟同步一次，该策略为AOF的缺省策略。<br>appendfsync no         #从不同步。高效但是数据不会被持久化。</p>
<p>由于AOF对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果本次操作只是写入了一半数据就出现了系统崩溃问题，那么在Redis下一次启动之前，可以通过redis-check-aof工具来解决数据一致性的问题。</p>
<p>AOF实际上包含了AOF和rewrite。当AOF文件随着写命令的运行膨胀时，当文件大小触碰到临界时，rewrite会被运行。rewrite会像replication一样，fork出一个子进程，创建一个临时文件，遍历数据库，将每个key、value对输出到临时文件。输出格式就是Redis的命令，但是为了减小文件大小，会将多个key、value对集合起来用一条命令表达。在rewrite期间的写操作会保存在内存的rewrite buffer中，rewrite成功后这些操作也会复制到临时文件中，在最后临时文件会代替AOF文件。</p>
<p>rewrite操作除了有AOF触发之外，还可以通过bgrewriteaof命令调用。</p>
<p>auto_aofrewrite_perc: aof文件的大小超过基准百分之多少后触发bgrewriteaof。默认这个值设置为100，意味着当前aof是基准大小的两倍的时候触发bgrewriteaof。把它设置为0可以禁用自动触发的功能。<br>auto_aofrewrite_min_size: 当前aof文件大于多少字节后才触发。避免在aof较小的时候无谓行为。默认大小为64mb。</p>
<p>手动触发的bgrewriteaof的时候如果同时存在bgsave在备份，会推迟这次操做的事件，设置server.aofrewrite_scheduled=1，待到bgsave结束后的下一次serverCron里才会触发。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/09/%E6%8A%80%E6%9C%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="xuhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="循序渐进">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/09/%E6%8A%80%E6%9C%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/" class="post-title-link" itemprop="url">ZooKeeper持久化策略</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-09 00:00:00" itemprop="dateCreated datePublished" datetime="2021-11-09T00:00:00+08:00">2021-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-10 14:13:18" itemprop="dateModified" datetime="2021-11-10T14:13:18+08:00">2021-11-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">计算机技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="内存数据"><a href="#内存数据" class="headerlink" title="内存数据"></a>内存数据</h1><p>ZooKeeper的数据模型是树结构，在内存数据库中，存储了整棵树的内容，包括所有的节点路径、节点数据、ACL信息，ZooKeeper会定时将这个数据存储到磁盘上。</p>
<p>DataTree是内存数据存储的核心，是一个树结构，代表了内存中一份完整的数据。DataTree不包含任何与网络、客户端连接及请求处理相关的业务逻辑，是一个独立的组件。</p>
<p>DataNode是数据存储的最小单元，其内部除了保存了节点的数据内容、ACL列表、节点状态之外，还记录了父节点的引用和子节点列表两个属性，其也提供了对子节点列表进行操作的接口。</p>
<p>ZKDatabase是ZooKeeper的内存数据库，管理ZooKeeper的所有会话、DataTree存储和事务日志。ZKDatabase会定时向磁盘dump快照数据，同时在ZooKeeper启动时，会通过磁盘的事务日志和快照文件恢复成一个完整的内存数据库。</p>
<p>ZooKeeper为了防止系统宕机或重启导致的数据丢失，会对数据进行定时持久化。有两种持久化方式：</p>
<h1 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h1><p>实时将每次事务操作记录到日志文件，比如创建、删除节点、更新节点数据等，这样就可以通过执行这些日志文件来恢复数据。</p>
<p>当ZooKeeper服务器启动完成需要进行第一次事务日志的写入，或是上一次事务日志写满时，都会处于与事务日志文件断开的状态，即ZooKeeper服务器没有和任意一个日志文件相关联。因此在进行事务日志写入前，ZooKeeper首先会判断FileTxnLog组件是否已经关联上一个可写的事务日志文件。若没有，则会使用该事务操作关联的ZXID作为后缀创建一个事务日志文件，同时构建事务日志的文件头信息，并立即写入这个事务日志文件中去，同时将该文件的文件流放入streamToFlush集合，该集合用来记录当前需要强制进行数据落盘的文件流。</p>
<p>ZooKeeper会采用磁盘空间预分配策略。当检测到当前事务日志文件剩余空间不足4096字节时，就会开始进行文件空间扩容，即在现有文件大小上，将文件增加65536KB(64MB)，然后使用”0”填充被扩容的文件空间。</p>
<p>ZooKeeper对事务头和事务体的序列化，其中事务体又可分为会话创建事务、节点创建事务、节点删除事务、节点数据更新事务等。为保证日志文件的完整性和数据的准确性，ZooKeeper在将事务日志写入文件前，会计算生成Checksum。将序列化后的事务头、事务体和Checksum写入文件流中，然后将缓存数据强制刷入磁盘。</p>
<p>在ZooKeeper运行过程中，可能出现非Leader记录的事务ID比Leader上大，这是非法运行状态。此时，需要保证所有机器必须与该Leader的数据保持同步，即Leader会发送TRUNC命令给该机器，要求进行日志截断，Learner收到该命令后，就会删除所有包含或大于该事务ID的事务日志文件。</p>
<h1 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h1><p>为了加快ZooKeeper恢复的速度，ZooKeeper还提供了对树结构DataTree和session信息进行数据快照持久化的操作。</p>
<p>在ZooKeeper客户端请求ZooKeeper服务中，ZooKeeper的服务端首先是判断这个请求是否是事务请求，如果是事务请求，那么ZooKeeper服务端首先将这个请求记录在增量事务日志中，保证了其持久化，然后再进行更新内存数据DataTree；在这个过程中，它也会去判断是否生成snapshot快照文件，如果要生成snapshot，那么就创建一个新的线程去干snapshot的事情。</p>
<p>使用snapCount参数来配置每次数据快照之间的事务操作次数，即ZooKeeper会在snapCount次事务日志记录后进行一个数据快照。和事务日志文件一样,快照文件的命名也是有含义的,命名为snapShot.{zxid},后缀是该快照文件生成时已执行的最新的事务的zxid,即[1,zxid]的所有事务已应用到DataTree。</p>
<p>每进行一次事务日志记录之后,ZooKeeper都会检测当前是否需要进行数据快照。理论上进行snapCount次事务操作后就会开始数据快照，但是考虑到数据快照对于ZooKeeper所在机器的整体性能的影响，需要尽量避免ZooKeeper集群中的所有机器在同一时刻进行数据快照。因此ZooKeeper在具体的实现中，并不是严格地按照这个策略执行的，而是采取“过半随机”策略，snapCount/2 ~ snapCount次事务日志记录后进行一次数据快照。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/25/%E6%8A%80%E6%9C%AF/web/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AE%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="xuhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="循序渐进">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/25/%E6%8A%80%E6%9C%AF/web/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AE%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">浏览器访问页面的过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-25 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-25T00:00:00+08:00">2021-10-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-10 11:03:04" itemprop="dateModified" datetime="2021-11-10T11:03:04+08:00">2021-11-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">计算机技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>用户打开浏览器输入目标地址，访问一个Web页面的过程如下：<br>(1)浏览器首先会查询本机的系统，获取主机名对应的IP地址； <br>(2)若本机查询不到相应的IP地址，则会发起DNS请求，获取主机名对应的IP地址；<br>(3)使用查询到的IP地址向目标服务器发起TCP连接；<br>(4)浏览器发送HTTP请求，HTTP请求由三部分组成，分别是:请求行、消息报头、请求正文；<br>(5)服务器从请求信息中获得客户机想要访问的主机名、Web应用、Web资源；<br>(6)服务器用读取到的Web资源数据，创建并回送一个HTTP响应；<br>(7)客户机浏览器解析回送的资源，并显示结果。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/25/%E6%8A%80%E6%9C%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="xuhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="循序渐进">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/25/%E6%8A%80%E6%9C%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/" class="post-title-link" itemprop="url">Redis删除策略</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-25 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-25T00:00:00+08:00">2021-10-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-09 16:05:48" itemprop="dateModified" datetime="2021-11-09T16:05:48+08:00">2021-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">计算机技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1、定期删除"><a href="#1、定期删除" class="headerlink" title="1、定期删除"></a>1、定期删除</h1><p>redis会将每个设置了过期时间的key放入到一个独立的字典中，以后会定期遍历这个字典来删除到期的key。</p>
<p>redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如redis存了几十万个key，每隔100ms就遍历所有的设置过期时间的key的话，就会给CPU带来很大的负载。</p>
<h1 id="2、惰性删除"><a href="#2、惰性删除" class="headerlink" title="2、惰性删除"></a>2、惰性删除</h1><p>所谓惰性策略就是在客户端访问这个key的时候，redis对key的过期时间进行检查，如果过期了就立即删除，不会给你返回任何东西。</p>
<p>定期删除可能会导致很多过期key到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个key，才会被redis给删除掉。这就是所谓的惰性删除，即当你主动去查过期的key时，如果发现key过期了，就立即进行删除，不返回任何东西。</p>
<h1 id="3、内存淘汰机制"><a href="#3、内存淘汰机制" class="headerlink" title="3、内存淘汰机制"></a>3、内存淘汰机制</h1><p>由于redis定期删除是随机抽取检查，不可能扫描清除掉所有过期的key并删除，然后一些key由于未被请求，惰性删除也未触发。这样redis的内存占用会越来越高。此时就需要内存淘汰机制。</p>
<p>内存淘汰机制主要有如下一些策略：</p>
<p>1、volatile-lru：从设置过期时间的数据集中挑选出最近最少使用的数据淘汰。没有设置过期时间的key不会被淘汰，这样就可以在增加内存空间的同时保证需要持久化的数据不会丢失。</p>
<p>2、volatile-ttl：除了淘汰机制采用LRU，策略基本上与volatile-lru相似，从设置过期时间的数据集中挑选将要过期的数据淘汰，ttl值越大越优先被淘汰。</p>
<p>3、volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。当内存达到限制无法写入非过期时间的数据集时，可以通过该淘汰策略在主键空间中随机移除某个key。</p>
<p>4、allkeys-lru：从数据集中挑选最近最少使用的数据淘汰，该策略要淘汰的key面向的是全体key集合，而非过期的key集合。</p>
<p>5、allkeys-random：从数据集中选择任意数据淘汰。</p>
<p>6、no-enviction：禁止驱逐数据，也就是当内存不足以容纳新入数据时，新写入操作就会报错，请求可以继续进行，线上任务也不能持续进行，采用no-enviction策略可以保证数据不被丢失，这也是系统默认的一种淘汰策略。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/22/%E8%BD%AF%E8%80%83/16%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1(%E4%B9%9D)%E5%AE%89%E5%85%A8%E6%80%A7%E8%A7%84%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="xuhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="循序渐进">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/22/%E8%BD%AF%E8%80%83/16%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1(%E4%B9%9D)%E5%AE%89%E5%85%A8%E6%80%A7%E8%A7%84%E7%AB%A0/" class="post-title-link" itemprop="url">安全性和保密性设计（九）安全性规章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-22 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-22T00:00:00+08:00">2021-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-09 10:07:43" itemprop="dateModified" datetime="2021-11-09T10:07:43+08:00">2021-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BD%AF%E8%80%83-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/" itemprop="url" rel="index"><span itemprop="name">软考-系统架构设计师</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、安全管理制度"><a href="#一、安全管理制度" class="headerlink" title="一、安全管理制度"></a>一、安全管理制度</h1><p>信息系统安全，不仅要从技术角度采取若干措施，还要从组织管理的角度出发，制定明确的安全管理的规章制度，以确保安全技术实施的有效性。只有依靠安全管理规章的有力支持和保障，信息安全的技术解决方案才能够切实地取得预期的效果。</p>
<p>事实上，管理的缺失是信息安全失败的非常重要的原因。有统计表明，危害信息系统安全的因素中，70%以上来自组织内部。系统管理员随意性的配置或者软件升级不及时造成的安全漏洞，使用脆弱的用户口令，随意下载使用来自网络的软件，在防火墙内部架设拨号服务器却没有对账号认证等严格限制，用户安全意识不强，将自己的账号随意转借他人或与别人共享等，这些管理上的问题无论多么高超的安全技术都不能解决，都会使信息系统处于危险之中。如果没有健全的安全性规章或者安全性规章不能贯彻落实，即便设计和实现了再好的安全设备和系统，信息系统安全也不过是空谈而已。</p>
<p>所以建立定期的安全检测、口令管理、人员管理、策略管理、备份管理、日志管理等系列安全性规章并认真贯彻执行对于维护信息系统的安全来说是非常必要的。</p>
<p>为了更好地落实安全性规章，首先需要根据实际情况，建立和健全信息系统安全委员会、安全小组、安全员。安全组织成员应当由主管领导、安全保卫、信息中心、人事、审计等部门的工作人员组成，必要时可聘请相关部门的专家组成。如果有必要，安全组织也可成立专门的独立机构。设立信息安全部门和安全人员，不但可以有效地制定并贯彻落实安全性规章制度，还可以提高对安全事件的反应能力和响应速度。</p>
<p>有了信息安全部门和人员，还要制定安全管理制度。只有建立健全的安全管理制度，并在信息系统的运行过程中始终坚持贯彻执行，才能从根本上为信息系统的正常运行，以及信息系统安全技术的执行提供良好的、坚固的基础。安全管理制度应该包括下面一些主要方面的内容：</p>
<p>（1）机房安全管理制度。<br>（2）系统运行管理制度，包括系统启动、关闭、系统状态监控、系统维护等。<br>（3）人员管理制度，包括管理人员、设计人员、操作人员、人事变更等。<br>（4）软件管理制度。<br>（5）数据管理制度。<br>（6）密码口令管理制度。<br>（7）病毒防治管理制度。<br>（8）用户登记和信息管理制度。<br>（9）工作记录制度。<br>（10）数据备份制度<br>（11）审计制度。<br>（12）安全培训制度等。</p>
<p> 此外，有了制度而不认真执行等于没有制度，所以，只有在系统的运行过程中，管理人员、操作人员、用户之间的相互配合与相互协作，共同遵守既定的安全性规章，才能保证信息系统的安全措施是有用的、有效的。</p>
<p>总之，信息安全所涉及的方面很多，只有在各个方面都进行全面管理，才能在此基础上与所用的安全技术和设备一起，有效保证信息系统安全。</p>
<h1 id="二、计算机犯罪与相关法规"><a href="#二、计算机犯罪与相关法规" class="headerlink" title="二、计算机犯罪与相关法规"></a>二、计算机犯罪与相关法规</h1><p>1.计算机犯罪</p>
<p>所谓计算机犯罪是指针对和利用计算机系统，通过非法操作或者以其他手段，对计算机系统的完整性或正常运行造成危害的行为</p>
<p>计算机犯罪的犯罪对象是计算机系统或其中的数据，包括计算机设备、系统程序、文本资料、运算数据、图形表格等。所谓非法操作，是指一切没有按照操作规程或是超越授权范围而对计算机系统进行的操作。非法操作是对计算机系统造成损害的直接原因。</p>
<p>计算机犯罪是随着计算机技术的发展而出现和发展的，在不同的历史时期，具有不同的特点。大体上，计算机犯罪可以划分成两个阶段。</p>
<p>第一个阶段是计算机单机时代，即早期的电脑犯罪阶段，时间大致从 20 世纪 50 年代至 80 年代。这个时期的主要形式是计算机诈骗，针对计算机内部信息的窃取和破坏。</p>
<p>第二个阶段是计算机网络时代，时间大致从 20 世纪 80 年代到现在。在这个时期，由于计算机网络的迅速发展及其应用范围越来越广泛，而且计算机软件日益复杂化、普及化，计算机犯罪呈现出一些新的特点：</p>
<p>(1) 呈现国际化趋势。互联网的发展是跨越国界的，随之而来的就是计算机犯罪由区域性犯罪向跨地区、跨国界的国际性犯罪发展</p>
<p>(2) 从犯罪所针对的对象看，向全社会各单位和个人蔓延。计算机犯罪由早期的主要攻击金融系统、政府机关向攻击其他所有行业、所有部门的信息系统蔓延；由攻击单位、团体的信息系统向攻击个人信息系统蔓延。这两种趋势的出现都是因为计算机已经从早期的特殊部门向全社会众多机关团体以及个人普及。</p>
<p>(3) 从组织形式上看，由个人犯罪向群体犯罪、组织犯罪发展；由单一目的犯罪向综合性犯罪发展。</p>
<p>(4) 从犯罪主体看，所涉及人员范围越来越广泛，并呈现低龄化趋势。从年龄结构来看，低龄化、普遍化是主要特点。从犯罪人员素质层次看，已经从早期的高学历、高技能型向普通人群发展。这些也都是因为计算机技术的普及，使得越来越多的人能够方便地学习到更多的计算机技术，通过长时间的学习和实践，青少年、低学历人员也能够逐渐掌握这些技术，成为计算机和网络犯罪的主体。</p>
<p>(5) 从危害程度看，后果越来越严重。由于知识经济的发展，各企事业单位的日常业务越来越依赖于信息系统，大量政治、军事、经济等方面的重要文件和数据，以及大量的社会财富集中于信息系统中，例如网络银行、股票等往往就表现为计算机系统中账户上的数据。旦犯罪分子侵入这样的信息系统，必将对国家安全、经济发展、社会进步产生巨大的影响，甚至造成不可挽回的损失。</p>
<p>(6) 通过网络窃取机密信息将成为间谍活动的主要形式之一。随着越来越多的企事业单位和个人连接互联网，其中的很多机密信息和数据都面临着网络窃密行为的威胁。对于没有采取严格安全措施的系统，通过网络窃取其机密信息相对于其他方式更加隐蔽、快捷。例如，通过后门程序盗窃用户的账号和密码，通过系统漏洞取得系统特权，非法窃取商业机密等。</p>
<p>这些计算机犯罪行为显然具有很大的危害，它们影响社会的稳定，危及国家安全，扰乱经济秩序，影响社会治安，妨害青少年的健康成长，阻碍高科技产业的健康发展。因此，对于各种形式的计算机犯罪必须运用法律手段进行打击和惩处。加大对网络犯罪的打击力度，是保证我国社会稳定、经济持续发展的一项重要任务。</p>
<p>2.我国的相关法律、法规</p>
<p>计算机犯罪，已经成为刑事犯罪的一种新形式。我国《刑法》已经增加了计算机犯罪的相关内容，并将计算机犯罪分为 5 种类型。一类是直接以计算机信息系统为犯罪对象的犯罪，另一类是以计算机为犯罪工具实施其他犯罪。具体的，《刑法》关于计算机犯罪的规定有</p>
<p>第二百八十五条（非法侵入计算机信息系统罪）违反国家规定，侵入国家事务、国防建设、尖端科学技术领域的计算机信息系统的，处三年以下有期徒刑或者拘役。</p>
<p>第二百八十六条（破坏计算机信息系统罪）违反国家规定，对计算机信息系统功能进行删除、修改、增加、干扰，造成计算机信息系统不能正常运行，后果严重的，处 5 年以下有期徒刑或者拘役；后果特别严重的，处 5 年以上有期徒刑。违反国家规定，对计算机信息系统中存储、处理或者传输的数据和应用程序进行删除、修改、增加的操作，后果严重的，依照前款的规定处罚。故意制作、传播计算机病毒等破坏性程序，影响计算机系统正常运行，后果严重的，依照第一款的规定处罚。</p>
<p>第二百八十七条（利用计算机实施的各类犯罪）利用计算机实施金融诈骗、盗窃、贪污挪用公款、窃取国家秘密或者其他犯罪的，依照本法有关规定定罪处罚。</p>
<p>这些规定对于我国大规模地推广应用各种信息系统，对于保护信息系统的生产者和使用者的合法权益，对于信息系统的安全运作都具有极为重要的作用。</p>
<p>除了《刑法》之外，我国在信息系统安全方面，自 1994 年以来，国务院及其有关部委相继修改和出台了若干相关法规和管理规定，其中对于我国境内发生的各种计算机犯罪及其处罚都有明文规定。因此，为了做好信息系统安全，有必要详细了解这些法律、法规，包括《中华人民共和国法》、《中华人民共和国刑法》、《中华人民共和国国家安全法》、《中华人民共和国保守国家秘密法》、《中华人民共和国计算机信息系统安全保护条例》、《中华人民共和国计算机信息网络国际联网管理暂行规定》、《中华人民共和国治安管理处罚条例》《中华人民共和国计算机信息网络国际联网管理暂行规定实施办法》、《中华人民共和国专利法》、《中华人民共和国反不正当竞争法》、《中华人民共和国商标法》《中华人民共和国海关法》《中华人民共和国标准化法》《关于对《中华人民共和国计算机信息系统安全保护条例》中涉及的“有害数据”问题的批复》、《科学技术保密规定》、《计算机信息系统安全专用产品检测和销售许可证管理办法》《公安部关于对与国际联网的计算机信息系统进行备案工作的通知》、《计算机信息网络国际联网安全保护管理办法》、《电子出版物管理规定》、《中国互联网络域名注册暂行管理办法》、《从事放开经营电信业务审批管理暂行办法》、《计算机信息网络国际联网出入口信道管理办法》、《中国公用计算机互联网国际联网管理办法》、《中国公众多媒体通信管理办法》、《计算机软件保护条例》、《商用密码管理条例》、《计算机信息系统国际联网保密管理规定》、《计算机病毒防治管理办法》、《信息安全等级保护管理办法》等。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/22/%E8%BD%AF%E8%80%83/16%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1(%E5%85%AB)%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="xuhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="循序渐进">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/22/%E8%BD%AF%E8%80%83/16%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1(%E5%85%AB)%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">安全性和保密性设计（八）系统的安全性设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-22 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-22T00:00:00+08:00">2021-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-09 10:07:43" itemprop="dateModified" datetime="2021-11-09T10:07:43+08:00">2021-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BD%AF%E8%80%83-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/" itemprop="url" rel="index"><span itemprop="name">软考-系统架构设计师</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、物理安全问题与设计"><a href="#一、物理安全问题与设计" class="headerlink" title="一、物理安全问题与设计"></a>一、物理安全问题与设计</h1><p>物理安全包括物理设备本身是否安全可靠，还包括设备的位置与环境的安全、限制物理访问、地域因素等几个方面。</p>
<p>信息系统的所有重要的物理设备、设施都应该放在专门的区域，并尽可能集中，同时严</p>
<p>格限制外来人员来访，尽可能地减少未经授权的访问。</p>
<p>物理安全还要求在设计中注意物理设备的冗余备份，例如，核心设备或部件都应该是热备份系统，具有实时或准实时切换的能力。</p>
<p>物理安全还要求严格限制对网络信息点、线缆等网络基础设施及其所在地进行物理访问，要想访问必须经过专门的授权。</p>
<p>物理安全还包括环境方面的因素，在设计之初就要对信息系统中的温度、湿度、灰尘、振动、雷电、电力等方面的参数有明确的要求，要对自然灾害（地震、台风、闪电等）有充分的考虑，还要对电磁泄漏等方面的要求作明确的定义。设计系统时要对这些因素全盘考虑，并采取适当的防护措施或强化手段。例如，机房这种重要的地点，除了所在的建筑物要有防雷系统外，还可以加装一套专用的防雷系统。这样可以保证即使建筑物遭到雷击时，万一建筑物的避雷系统未能充分保护好昂贵的信息系统，那么单独为机房安装的专用避雷系统也能保障机房设备免受损失。</p>
<h1 id="二、防火墙及其在系统安全中的应用"><a href="#二、防火墙及其在系统安全中的应用" class="headerlink" title="二、防火墙及其在系统安全中的应用"></a>二、防火墙及其在系统安全中的应用</h1><p>网络安全隐患主要是由网络的开放性、无边界性、自由性造成的，所以保护网络安全可以首先考虑把被保护的网络从开放的、无边界的、自由的公共网络环境中独立出来，使之成为有管理的、可控制的、安全的内部网络。也只有做到这一点，实现信息网络的通信安全才有可能。</p>
<p>目前，最基本的网络分隔手段就是防火墙，它也是目前用来实现网络安全的一种主要措施。利用防火墙，可以用来在拒绝未经允许的网络连接、阻止敏感数据的泄漏的同时，保证合法用户的合法网络流量畅通无阻，可以实现内部可信任网络（如企业网）与外部不可信任网络（如 Internet）之间，或是内部不同子网之间的隔离与控制，保证网络系统及网络服务的可用性。</p>
<p>1.防火墙的基本原理防火墙通常使用的采用包过滤、状态检测、应用网关等几种方式控制网络连接</p>
<p>包过滤防火墙是一种简单而有效的安全控制技术，它根据在防火墙中预先定义的规则（允许或禁止与哪些源地址、目的地址、端口号有关的网络连接），对网络层和传输层的数据包进行检查，进而控制数据包的进出。包过滤的优点是对用户透明、传输性能高。但是由于只能在网络层、传输层进行控制，安全控制的方式也只限于源地址、目的地址和端口号这几种，对于应用层的信息无法感知，因而只能进行较为初步的安全控制，对于拥塞攻击、内存覆盖攻击或病毒等高层次的攻击手段，则无能为力。</p>
<p>状态检测防火墙保持了包过滤防火墙的优点，所以性能比较好，而且对应用是透明的。同时，状态检测防火墙改进了包过滤防火墙仅仅检查进出网络的数据包，不关心数据包状态的缺点，在防火墙的内部建立状态连接表，维护了连接，将进出网络的数据当成一个个的事</p>
<p>件来处理，对于每一个您已静音，请住空格键暂时开启麦克风接</p>
<p>通过，并在内存中记录下该连接的相关信息，生成状态表。对该连接的后续数据包，只要符合状态表，就可以通过。这种方式的好处在于：由于不需要对每个数据包进行规则检查，而是对一个连接的后续数据包（通常是大量的数据包）通过散列算法，直接进行状态检查，从而使得性能得到了较大提高。</p>
<p>与不关心应用层数的前两种方式不同，应用网关防火墙检査所有应用层的信息包，并将检査的内容信息放入决策过程，从而提高网络的安全性。然而，应用网关防火墙是通过打破客户机/服务器模式实现的。每个客户机/服务器通信需要两个连接：一个是从客户端到防火 墙，另一个是从防火墙到服务器。另外，每个网关需要一个不同的应用进程，或一个后台运行的服务程序，对每个新的应用必须添加针对此应用的服务程序，否则不能使用该服务。所以，应用网关防火墙使用起来比较麻烦，而且通用性比较差。</p>
<p>2.防火墙的优点在系统中使用防火墙，对于系统的安全有很多的优点：</p>
<p> (1) 可以隔离网络，限制安全问题的扩散。防火墙可以隔离不同的网络，或者用来隔离网络中的某一个网段，这样就能够有效地控制这个网段或网络中的问题在不同的网络中传播，从而限制安全问题的扩散。</p>
<p> (2) 通过防火墙可以对网络中的安全进行集中化管理，简化网络安全管理的复杂度。只要在防火墙上配置好过滤策略，就能使防火墙成为一个网络安全的检査站，所有进出网络的信息都需要通过防火墙，把非法访问拒于门外。从而实现安全的集中统一的管理，并且能够简化安全管理的复杂度。</p>
<p> (3) 能够有效地记录 Internet 上的活动。因为所有进出内部网络的信息都必须通过防火墙，所以防火墙能够收集内部网络和外部网络之间或者不同网段之间所发生的事件，为管理员的进一步分析与安全管理提供依据。</p>
<p>3.正确使用防火墙虽然防火墙的技术日渐成熟起来，成为维护网络安全的一个重要的手段。但是，它也不能完全解决网络上的安全问题。在实际使用过程中还有一些安全性是防火墙不能实现的，在实际工作中，一般应注意如下几点：</p>
<p>(1) 防火墙虽然能对来自外部网络的非法连接作很严格的限制，但是对来自本地网络内部的攻击却无从防范。事实上，大多数攻击不是来自外部，而是来自内部。因此，即使使用了防火墙，对本地网络内部的主机、应用系统、数据库等也要采取其他有效的措施，才能真正做到安全。</p>
<p> (2) 即使对于来自外部的攻击，目前的任何防火墙也不能做到完全阻挡所有的非法入侵。随着各种新技术的陆续涌现，非法分子对系统的深入研究与剖析，各种新的应用需求不断被开发，防火墙本身也会受到越来越多的威胁。对这些新的动态、趋势要密切关注，不断地升级防火墙、修正完善防火墙的配置，才能使防火墙本身更加坚固，进而长久地发挥安全保护作用。</p>
<p> (3) 防火墙不能防范病毒，无法抵御基于数据的攻击。尽管防火墙的过滤技术在不断完善，可是由于病毒的类型太多，隐藏方式也非常复杂，而且它们很多都是隐藏在数据文件中，因此要防火墙对所有的包含病毒的文件作出限制是不太现实的，而应当在系统中单独安装专门的病毒网关或者在主机上安装相应的防病毒软件、反间谍软件等工具软件，才能较好地防范此类安全隐患</p>
<p> (4) 防火墙不能防范全部的威胁，而只能防备已知的威胁。所以在使用过程中，应当经常根据需要配合使用入侵检测系统。</p>
<p> (5) 防火墙不能防范不通过它的链接。防火墙可以有效地过滤经过它的信息传输，但不能防范不通过它的信息传输，例如，如果允许拨号访问防火墙后面的内部系统，则防火墙没有任何办法对它进行控制</p>
<h1 id="三、入侵检测系统"><a href="#三、入侵检测系统" class="headerlink" title="三、入侵检测系统"></a>三、入侵检测系统</h1><p>传统上，一般采用防火墙作为系统安全的边界防线。但是，随着攻击者的知识日趋丰富，攻击工具与手法的日趋复杂多样，单纯的防火墙已经无法满足对安全高度敏感的部门的需要，网络的防卫必须采用一种纵深的、多样的手段。</p>
<p>与此同时，当今的网络环境也变得越来越复杂，各式各样的复杂的设备，需要不断升级、补漏，系统管理员的工作不断加重，不经意的疏忽便有可能造成安全的重大隐患。所以，信息系统中存在着不少可以被攻击者所利用的安全弱点、漏洞及不安全的配置，主要表现在操作系统、网络服务、TCP/IP协议、应用程序(如数据库、浏览器等)、网络设备等几个方面。 正是这些弱点、漏洞和不安全设置给攻击者以可乘之机。</p>
<p>另外，由于大部分网络缺少预警防护机制，即使攻击者已经侵入到内部网络，侵入到关键的主机，并从事非法的操作，系统管理员也很难察觉到。这样，攻击者就有足够的时间来做他们想做的任何事情。</p>
<p>要防止和避免遭受攻击和入侵，不仅要找出网络中存在的安全弱点、漏洞和不安全的配置，然后采取相应措施解决这些弱点、漏洞，对不安全的配置进行修正，最大限度地避免遭受攻击和入侵；还要对网络活动进行实时监测，一旦监测到攻击行为或违规操作，能够及时作出反应，包括记录日志、报警甚至阻断非法连接。</p>
<p>在这种环境下，入侵检测（Intrusion Detection）技术受到人们愈来愈多的关注，而且已经开始在各种不同的环境中发挥其关键作用。入侵检测系统可以在系统中发生一些不正常的操作时发出警报，防患于未然。设置硬件防火墙，可以提高网络的通过能力并阻挡一般性的攻击行为；而采用入侵检测系统，则可以对越过防火墙的攻击行为及来自网络内部的违规操作进行监测和响应。</p>
<p>入侵检测技术，通过对计算机网络或计算机系统中的若干关键点收集信息并对其进行分析，从中发现网络或系统中是否有违反安全策略的行为和被攻击的迹象。与其他安全产品不同的是，入侵检测系统需要更多的智能，它要根据智能库对收集到的数据进行分析，并采取相应措施。</p>
<p>作为对防火墙极其有益的补充，入侵检测系统（IDS）能够帮助人们快速发现系统攻击的发生，扩展了系统管理员的安全管理能力（包括安全审计、监视、进攻识别和响应等），提高了信息系统的安全性。入侵检测系统被认为是防火墙之后的第二道安全闻门，它能在不影响网络性能的情况下对网络进行监听，从而提供对内部攻击、外部攻击和误操作的实时保护</p>
<p>入侵检测系统作为一种积极主动的安全防护工具，能够在计算机网络和系统受到危害之前进行报警、拦截和响应。其主要功能包括：通过检测和记录系统中的安全违规行为，惩罚信息系统攻击，防止入侵事件的发生；检测其他安全措施未能阻止的攻击或安全违规行为检测黑客在攻击前的探测行为，预先给管理员发出警报；报告信息系统中存在的安全威胁；提供有关攻击的信息，帮助管理员诊断系统中存在的安全弱点，利于其进行修补。</p>
<p>在大型、复杂的计算机系统中布置入侵检测系统，可以明显提高信息系统安全管理的质量。</p>
<p>1.入侵检测技术入侵检测系统的处理过程分为数据采集阶段、数据处理及过滤阶段入侵分析及检测阶段、报告及响应阶段 4 个阶段。数据采集阶段主要收集目标系统中引擎</p>
<p>提供的通信数据包和系统使用等情况。数据处理及过滤阶段是把采集到的数据转换为可以识别是否发生入侵的数据的阶段。分析及检测阶段通过分析上一阶段提供的数据来判断是否发生入侵。这一阶段是整个入侵检测系统的核心阶段。报告及响应阶段针对上一个阶段中得出的判断作出响应。如果被判断为发生入侵，系统将对其采取相应的响应措施，或者通知管理人员发生入侵，以便于采取措施。</p>
<p>在入侵检测系统的工作过程中，对信息系统中的各种事件进行分析，从中检测出违反安全策略的行为是入侵检测系统的核心功能。检测技术分为两类：一种是基于标识（Signature- based）的入侵检测，另一种是基于异常情况（anomaly- based）的入侵检测。</p>
<p>在入侵检测系统的工作过程中，对信息系统中的各种事件进行分析，从中检测出违反安全策略的行为是入侵检测系统的核心功能。检测技术分为两类：一种是基于标识（signature- based）的入侵检测，另一种是基于异常情况（anomaly- based）的入侵检测。</p>
<p>基于标识的检测技术，先定义出违背安全策略的事件的特征，如网络数据包的某些头信息等。然后对收集到的数据进行分析，通过判别这类特征是否在所收集到的数据中出现来判断是否受到入侵。此方法非常类似杀毒软件的特征码检测，比较简单有效。</p>
<p>而基于异常的检测技术则先定义一组系统“正常”情况的数值，如 CPU 利用率、网络流量规律、文件校验和等（这类数据可以人为定义，也可以通过观察系统，并用统计的办法得出），然后将系统运行时的数值与所定义的“正常”情况比较，得出是否有被攻击的迹象。这种检测方式的核心在于如何定义所谓的“正常”情况。</p>
<p>两种检测技术的方法、所得出的结论有时会有非常大的差异。基于标识的检测技术的核心是维护一个知识库。对于已知的攻击，它可以详细、准确地报告出攻击类型，但是对未知攻击却效果有限，而且知识库必须不断更新。基于异常的检测技术则无法准确判别出攻击的手法，但它可以判别更广泛，甚至未发觉的攻击。如果条件允许，两者结合的检测会达到更好的效果。</p>
<p>2.入侵检测系统的种类和选用一般来说，入侵检测系统可分为主机型和网络型。主机型入侵检测系统往往以系统日志、应用程序日志等作为数据源，当然也可以通过其他手段（如监控系统调用）从所在的主机收集信息进行分析。主机型入侵检测系统保护的般是其所在的主机系统。主机型入侵检测系统需要为不同平台开发不同的程序，而且会增加系统负荷，还要在每一台主机安装，比较麻烦，但是可以充分利用操作系统本身提供的功能，并结合异常分析，更准确地报告攻击行为。</p>
<p>网络型入侵检测系统则以网络上的数据包作为数据源，通过在一台主机或网络设备上监听本网段内的所有数据包来进行分析判断。一般网络型入侵检测系统担负着保护整个网段的任务。这种系统应用十分简便：一个网段上只需安装一个或几个这样的系统，便可以监测整个网段的情况，但是它不跨越多个物理网段，对于复杂结构的网络（如交换环境）监测效果有一定影响。</p>
<p>主机型入侵检测系统和网络型入侵检测系统各有利弊，应用中可以根据实际需要从中选择。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/22/%E8%BD%AF%E8%80%83/17%E3%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="xuhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="循序渐进">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/22/%E8%BD%AF%E8%80%83/17%E3%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">系统的可靠性分析与设计（一）可靠性概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-22 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-22T00:00:00+08:00">2021-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-09 10:07:43" itemprop="dateModified" datetime="2021-11-09T10:07:43+08:00">2021-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BD%AF%E8%80%83-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/" itemprop="url" rel="index"><span itemprop="name">软考-系统架构设计师</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>系统的可靠性分析与设计是系统架构设计师在系统分析与设计阶段、系统集成阶段应该重点考虑的问题。内容主要为可靠性设计、系统的故障模型、系统的可靠性模型、组合模型可靠性计算、马尔柯夫模型可靠性计算，以及硬件冗余、信息校验码等方面；另外也涉及系统可靠性分析与计算、系统可靠性评估和系统配置方法等概念与理论的实际工程运用等内容。</p>
<h1 id="一、可靠性概述"><a href="#一、可靠性概述" class="headerlink" title="一、可靠性概述"></a>一、可靠性概述</h1><p>与可靠性相关的概念主要有：可靠度、可用度、可维度、平均无故障时间、平均故障修复时间及平均故障间隔时间等</p>
<p>(1) 可靠度。系统的可靠度 R（t）是指在 t=0 时系统正常的条件下，系统在时间区间[0, t]内能正常运行的概率。</p>
<p>(2) 可用度。系统的可用度 A（t）是指系统在时刻 t 可运行的概率。</p>
<p>(3) 可维度。系统的可维度 M(t）是指系统失效后，在时间间隔内被修复的概率。</p>
<p>(4) 平均无故障时间。可靠度为 R(t）的系统平均无故障时间（Mean Time To Failure, MTTF）定义为从 t=0 时到故障发生时系统的持续运行时间的期望值。</p>
<p>(5) 平均故障修复时间。可用度为 A(t）的系统平均故障修复时间（Mean Time To Repair, MTR）可以用类似于求 MTTF 的方法求得。</p>
<p>(6) 平均故障间隔时间。平均故障间隔时间（Mean Time Between Failure, MTBF）常常与 MTF 发生混淆。因为两次故障（失败）之间必然有修复行为，因此，MTBF 中应包含 MTR。对于可靠度服从指数分布的系统，从任一时刻 t0 到达故障的期望时间都是相等的。</p>
<h1 id="二、系统故障模型"><a href="#二、系统故障模型" class="headerlink" title="二、系统故障模型"></a>二、系统故障模型</h1><h2 id="1-故障的来源以及表现"><a href="#1-故障的来源以及表现" class="headerlink" title="1 故障的来源以及表现"></a>1 故障的来源以及表现</h2><p>下面先介绍几个概念。</p>
<p>(1) 失效：硬件的物理改变。</p>
<p>(2) 故障：由于部件的失效、环境的物理干扰、操作错误或不正确的设计引起的硬件或软件中的错误状态。</p>
<p>(3) 错误（差错）：故障在程序或数据结构中的具体位置。错误与故障位置之间可能出现一定距离。故障或错误有如下几种表现形式。</p>
<p>永久性：描述连续稳定的失效、故障或错误。在硬件中，永久性失效反映了不可恢复的物理改变。</p>
<p>间歇性：描述那些由于不稳定的硬件或变化着的硬件或软件状态所引起的、仅仅是偶然出现的故障或错误。</p>
<p>瞬时性：描述那些由于暂时的环境条件而引起的故障或错误。</p>
<p>个故障可能由物理失效、不适当的系统设计、环境影响或系统的操作员所引起。永久性失效会导致永久性故障。间歇性故障可能由不稳定、临界稳定或不正确的设计所引起。环境条件会造成瞬时性故障。所有这些故障都可能引起错误。不正确的设计和操作员失误会直接引起错误。由硬件的物理条件，不正确的硬件或软件设计，或不稳定但重复出现的环境条件所引起的故障可能是可检测的，并且可以通过替换或重新设计来修复；然而，由于暂时的环境条件所引起的故障是不能修复的，因为其硬件本身实际上并没有损坏。瞬时和间歇故障已经成为系统中的一个主要错误源。</p>
<h2 id="2-几种常用的故障模型"><a href="#2-几种常用的故障模型" class="headerlink" title="2 几种常用的故障模型"></a>2 几种常用的故障模型</h2><p>故障的表现形式千差万别，可以利用故障模型对千差万别的故障表现进行抽象。故障模型可以在系统的各个级别上建立。一般说来，故障模型建立的级别越低，进行故障处理的代价也越低，但故障模型覆盖的故障也越少。如果在某一级别的故障模型不能包含故障的某些表现，则可以用更高一级别的模型来概括。下面介绍几种常用的故障模型。</p>
<p>1.逻辑级的故障模型</p>
<p>固定型故障指电路中元器件的输入或输出等线的逻辑固定为 0 或固定为 1, 如某线接地、电源短路或元件失效等都可能造成固定型故障。短路故障是指一个元件的输出线的逻辑值恒等于输入线的逻辑值；元件的开路故障是元件的输出线悬空，逻辑值可根据具体电路来决定。桥接故障指两条不应相连的线连接在一起而发生的故障。</p>
<p>2.数据结构级的故障</p>
<p>故障在数据结构上的表现称为差错。常见的差错如下。独立差错：一个故障的影响表现为使一个二进制位发生改变。</p>
<p>算术差错：一个故障的影响表现为使一个数据的值增加或减少 2i (=0,1,2,…）。</p>
<p>单向差错：一个故障的影响表现为使一个二进制向量中的某些位朝一个方向（0 或 1) 改变</p>
<p>3.软件故障和软件差错</p>
<p>软件故障是指软件设计过程造成的与设计说明的不一致的情况，软件故障在数据结构或程序输出中的表现称为软件差错。与硬件不同，软件不会因为环境压力而疲劳，也不会因为时间的推移而衰老。因此，软件故障只与设计有关。常见的软件差错有以下几种。</p>
<p>非法转移：程序执行了说明中不存在的转移。</p>
<p>误转移：程序执行了尽管说明中存在，但依据当前控制数据不应进行的转移。<br>死循环：程序执行时间超过了规定界限。</p>
<p>空间溢出：程序使用的空间超过了规定的界限。</p>
<p>数据执行：指令计数器指向数据单元。</p>
<p>无理数据：程序输出的数据不合理</p>
<p>4.系统级的故障模型故障在系统级上的表现为功能错误，即系统输出与系统设计说明的不一致。如果系统输出无故障保护机构，则故障在系统级上的表现就会造成系统失效。</p>
<h1 id="三、系统配置方法"><a href="#三、系统配置方法" class="headerlink" title="三、系统配置方法"></a>三、系统配置方法</h1><p>容错技术是保证系统在某些组成部分出现故障或差错时仍能正常工作的技术。通常根据不同的系统配置方法而采用相应容错技术：单机容错技术、双机热备份技术和服务器集群技术</p>
<h2 id="1-单机容错技术"><a href="#1-单机容错技术" class="headerlink" title="1 单机容错技术"></a>1 单机容错技术</h2><p>容错技术是保证系统在某些组成部分出现故障或差错时仍能正常工作的技术。系统的故障可分为两类：一类是“致命的”，不可能自行修复，例如系统的主要部件全部损坏；另类是局部的，可能被修复，例如部分元件失效、线路故障、偶然干扰引起的差错等。容错技术正是用于构造一种能够自动排除非致命性故障的系统，即容错系统。</p>
<p>在单机容错技术中，提高系统工作可靠性的方法主要有自检技术和冗余技术。容错又有多种形式，如硬件容错、软件容错、整机容错等。</p>
<p>1.自检技术</p>
<p>自检指系统在发生非致命性故障时能自动发现故障和确定故障的性质、部位，并自动采取措施更换和隔离产生故障的部件。自检需采用诊断技术，常用专门程序实现，属于程序设计的范围。容错系统的实现要求系统必须具有重复部件或备份部件，或具有不止一个完成某种功能的通道。因此自检技术常配合冗余技术使用。计算机的容错系统一般都需要应用自检技术。</p>
<p>2.冗余技术</p>
<p>冗余可分为硬件冗余（增加硬件）、软件冗余（增加程序，如同时采用不同算法或不同人编制的程序）、时间冗余（如指令重复执行、程序重复执行）、信息冗余（如增加数据位）等。冗余技术中最常用的两种方法是重复线路和备份线路。重复线路指用多个相同品种和规格的元件或构件并联起来，当作一个元件或构件使用，只要有一个不出故障，系统就能够正常工作。在并联工作时每一个构件的可靠性概率是互相独立的。备份线路与重复线路的差别是参加备份的构件并不接入系统，只有在处于工作状态的构件发生故障后才把输入和输出接到备份构件上来，同时切断故障构件的输入、输出。</p>
<p>容错技术已获得广泛应用，常用于对可靠性要求高的系统，特别是用于危及人身安全的关键部位。在这些部位大多采用双重冗余，也有采用三重、四重甚至五重冗余的。现代的大型复杂系统常常是容错能力很强的系统。容错技术在计算机中应用得最早、最广泛。</p>
<h2 id="2-双机热备份技术"><a href="#2-双机热备份技术" class="headerlink" title="2 双机热备份技术"></a>2 双机热备份技术</h2><p>双机热备份技术是一种软硬件结合的较高容错应用方案。该方案是由两台服务器系统和个外接共享磁盘阵列柜和相应的双机热备份软件组成。其中的外接共享磁盘阵列柜也可以没有，而是在各自的服务器中采取 RAID (Redundant Array of Independent Disk，独立冗余磁盘阵列）卡。</p>
<p>在这个容错方案中，操作系统和应用程序安装在两台服务器的本地系统盘上，整个网络系统的数据是通过磁盘阵列集中管理和数据备份的。数据集中管理是通过双机热备份系统，将所有站点的数据直接从中央存储设备读取和存储，并由专业人员进行管理，极大地保护了数据的安全性和保密性。用户的数据存放在外接共享磁盘阵列中，在一台服务器出现故障时，备机主动替代主机工作，保证网络服务不间断。</p>
<p>双机热备份系统采用“心跳”方法保证主系统与备用系统的联系。所谓“心跳”，指的是主、从系统之间相互按照一定的时间间隔发送通信信号，表明各自系统当前的运行状态。旦“心跳”信号表明主机系统发生故障，或者备用系统无法收到主机系统的“心跳”信号，则系统的高可用性管理软件认为主机系统发生故障，立即将系统资源转移到备用系统上，备用系统替代主机工作，以保证系统正常运行和网络服务不间断。</p>
<p>双机热备份方案中，根据两台服务器的工作方式可以有三种不同的工作模式，即：双机热备模式、双机互备模式和双机双工模式。</p>
<p>双机热备模式即目前通常所说的 active/ standby 方式，active 服务器处于工作状态；而  standby 服务器处于监控准备状态，服务器数据包括数据库数据同时往两台或多台服务器写入（通常各服务器采用 RAD 磁盘阵列卡），保证数据的即时同步。当 active 服务器出现故障时，通过软件诊测或手工方式将 standby 机器激活，保证应用在短时间内完全恢复正常使用。典型应用有证券资金服务器或行情服务器。这是目前用较多的一种模式，但由于另外一台服务器长期处于后备的状态，所以浪费了一部分计算资源。</p>
<p>用户可以根据系统的重要性及终端用户对服务中断的容忍程度决定是否使用双机热备份。例如，网络中的用户最多能容忍多长时间恢复服务，如果服务不能很快恢复会造成什么样的后果作为是否采用双机热备份的根据。对于承担企业关键业务应用的服务器需要极高的稳定性和可用性，并需要提供每周 7（天）×24（小时）不间断服务的应用，推荐使用双机热备份。</p>
<p>双机互备模式，是两个相对独立的应用在两台机器同时运行，但彼此均设为备机，当某台服务器出现故障时，另一台服务器可以在短时间内将故障服务器的应用接管过来，从而保证了应用的持续性，但对服务器的性能要求比较高。</p>
<p>双机双工模式是集群的一种形式，两台服务器均处于活动状态，同时运行相同的应用，以保证整体系统的性能，也实现了负载均衡和互为备份，通常使用磁盘柜存储技术。Web 服务器或 FTP 服务器等用此种方式比较多。</p>
<h2 id="3-服务器集群技术"><a href="#3-服务器集群技术" class="headerlink" title="3 服务器集群技术"></a>3 服务器集群技术</h2><p>集群技术指一组相互独立的服务器在网络中组合成为单一的系统工作，并以单一系统的模式加以管理。此单一系统为客户工作站提供高可靠性的服务。大多数情況下，集群中所有的计算机拥有一个共同的名称，集群内任一系统上运行的服务可被所有的网络客户使用</p>
<p>集群必须可以协调管理各分离的构件出现的错误和故障，并可透明地向集群中加入构件。一个集群包含多台（至少二台）共享数据存储空间的服务器。其中任何一台服务器运行应用时，应用数据被存储在共享的数据空间内。每台服务器的操作系统和应用程序文件存储在其各自的本地储存空间上。</p>
<p>集群内各节点服务器通过一个内部局域网相互通信，当一台节点服务器发生故障时，这台服务器上所运行的应用程序将在另一节点服务器上被自动接管。当一个应用服务发生故障时，应用服务将被重新启动或被另一台服务器接管。当以上的任一故障发生时，客户都将能很快连接到其他应用服务器上。</p>
<h1 id="四、系统可靠性模型"><a href="#四、系统可靠性模型" class="headerlink" title="四、系统可靠性模型"></a>四、系统可靠性模型</h1><h2 id="1-时间模型"><a href="#1-时间模型" class="headerlink" title="1 时间模型"></a>1 时间模型</h2><p>最著名的时间模型是由 Shooman 提出的可靠性增长模型，这个模型基于这样一个假设：个软件中的故障数目在 t=0 时是常数，随着故障被纠正，故障数目逐渐减少。</p>
<h2 id="2-故障植入模型"><a href="#2-故障植入模型" class="headerlink" title="2 故障植入模型"></a>2 故障植入模型</h2><p>故障植入模型是一个面向错误数的数学模型，其目的是以程序的错误数作为衡量可靠性的标准，模型的原型是 1972 年由 Mills 提出的。</p>
<p>Mills 提出的故障植入模型的基本假设如下</p>
<p>(1) 程序中的固有错误数是一个未知的常数。</p>
<p>(2) 程序中的人为错误数按均匀分布随机植入。</p>
<p>(3) 程序中的固有错误数和人为错误被检测到的概率相同。</p>
<p>(4) 检测到的错误立即改正</p>
<h2 id="3-数据模型"><a href="#3-数据模型" class="headerlink" title="3 数据模型"></a>3 数据模型</h2><p>在数据模型下，对于一个预先确定的输入环境，软件的可靠度定义为在 n 次连续运行中软件完成指定任务的概率</p>
<h1 id="五、系统可靠性分析和可靠度计算"><a href="#五、系统可靠性分析和可靠度计算" class="headerlink" title="五、系统可靠性分析和可靠度计算"></a>五、系统可靠性分析和可靠度计算</h1><h2 id="1-组合模型"><a href="#1-组合模型" class="headerlink" title="1 组合模型"></a>1 组合模型</h2><p>组合模型是计算机容错系统可靠性最常用的方法。一个系统只要满足以下条件，就可以用组合模型来计算其可靠性。作如下假设。</p>
<p>(1) 系统只有两种状态：运行状态和失效状态。</p>
<p>(2) 系统可以划分成若干个不重叠的部件，每个部件也只有两种状态：运行状态和失效状态。</p>
<p>(3) 部件的失效是独立的。</p>
<p>(4) 系统失效当且仅当系统中的剩余资源不满足系统运行的最低资源要求（系统的状态只依赖于部件的状态）时。</p>
<p>(5) 已知每个部件的可靠性，可靠性指可用度或可靠度等概率参数。组合模型的目标就是根据各部件的可靠性 Ri (t）来计算系统的可靠度 Rsys (t），组合模型的基本思想如下。<br>1．枚举所有系统状态<br>2．计算每个系统状态的概率系统状态的概率是指系统处于该状态的概率。<br>3.计算直接计算一个复杂系统的可靠性是很困难的，通常的方法是把整个系统分解为简单的子系统，通过子系统的组合来计算整个系统的可靠性。</p>
<p>系统分为 串联系统、并联系统、串并联系统。</p>
<h2 id="2-马尔柯夫模型"><a href="#2-马尔柯夫模型" class="headerlink" title="2 马尔柯夫模型"></a>2 马尔柯夫模型</h2><p>马尔柯夫模型的两个核心概念是状态和状态转移。系统的状态表示了在任何瞬间用以描述该系统所必须知道的一切。对于可靠性分析，马尔柯夫模型的每个状态表示了有效和失效模块的不同组合。如果每个模块都是处于有效和失效两种情况之一，则一个 n 模块系统的完整模型有 2n 个状态。</p>
<p>状态转移是指随着时间的流逝，因模块的失效和修复，系统发生的状态变化。</p>
<p>作为马尔柯夫模型基础的基本假设是：给定状态的转移概率仅取决于当前的状态。系统从一个状态转移到另一个状态的转移率定义为单位时间内从状态ⅰ转移到状态 j 的概率。对于一个模块来说，从运行状态到失效状态的转移率就是模块的失效率，从失效状态到运行状态的转移率就是模块的修复率。</p>
<p>对于由 n 个模块构成的系统，共有 2n 个状态。从理论上说，任意两个状态之间都存在转移的可能性。但因失效是独立的，在很短的时间内发生多个失效的可能性远小于发生个失效的可能性。因此，只考虑任一时刻只有一个模块失效的转移；同样，也只考虑任意时刻只有一个模块修复的转移。系统的状态图也可以表示为层次图。第一层只有一个状态，对应于所有模块都运行的情况；第二层有 n 个状态，对应于一个模块失效的各种情况第+1 层有 Gi 个状态，对应于 n 个模块中有个失效的各种情况：第 n+1 层也只有一个状态，对应于全部模块都失效的情况。</p>
<h1 id="六、提高系统可靠性的措施"><a href="#六、提高系统可靠性的措施" class="headerlink" title="六、提高系统可靠性的措施"></a>六、提高系统可靠性的措施</h1><p>防止故障造成系统失效的两种技术是故障掩蔽技术和系统重组技术，故障掩蔽技术是指防止故障造成差错的各种技术，系统重组技术是防止差错导致系统失效的各种技术。故障掩蔽技术和系统重组技术是达到容错的两种基本途径。而它们又是建立在资源冗余的基础上的。资源冗余有硬件冗余、信息冗余、时间冗余和软件冗余 4 种形式。</p>
<h2 id="1-硬件冗余"><a href="#1-硬件冗余" class="headerlink" title="1 硬件冗余"></a>1 硬件冗余</h2><p>硬件冗余最常用的是三模冗余（Triple Modular Redundancy, TMR），三个相同的模块接收三个相同的输入，产生的三个结果送至多数表决器。表决器的输出取决于三个输入的多数，若有一个故障模块，则另两个正常模块的输出可将故障模块的输出掩蔽，从而不在表决器输出产生差错。</p>
<h2 id="2-信息冗余"><a href="#2-信息冗余" class="headerlink" title="2 信息冗余"></a>2 信息冗余</h2><p>信息冗余是指通过在数据中附加冗余的信息以达到故障检测、故障掩蔽或容错的目的。应用最广泛的是海明校验码、奇偶校验码。</p>
<p>1.海明校验码</p>
<p>海明校验码是由 Richard Hamming 于 1950 年提出，目前仍然被广泛采用的一种很有效的校验方法，是只要增加少数几个校验位，就能检测出二位同时出错，亦能检测出一位出错并能自动恢复该出错位的正确值的有效手段，后者称为自动纠错。它的实现原理，是在 k 个数据位之外加上 r 个校验位，从而形成一个 k+r 位的新的码字，使新的码字的码距比较均匀地拉大。把数据的每一个二进制位分配在几个不同的偶校验位的组合中，当某一位出错后，就会引起相关的几个校验位的值发生变化，不但可以发现出错，还能指出是哪一位出错，为进一步自动纠错提供了依据。</p>
<p>基本的海明纠错码能纠正一位错。它的原理是基于重叠奇偶校验的概念：将原始数据位分成若干个重叠的组，每组设一位奇偶校验位。由于组间有重叠，因此每位原始数据从属于多于一个组。而且每位原始数据的从属关系是不一样的，纠错时，根据哪些组的奇偶校验位出错，就可以唯一地确定是哪一位数据出错。将该位取反就完成了纠错。</p>
<p>2.循环冗余校验码</p>
<p>循环冗余校验码（Cyclic Redundancy Chec, CRC）也广泛应用于移动通信和磁盘数据存储中。CRC 也是给信息码加上几位校验码，以增加整个编码系统的码距和错纠错能力。</p>
<h1 id="七、备份与恢复"><a href="#七、备份与恢复" class="headerlink" title="七、备份与恢复"></a>七、备份与恢复</h1><p>在计算机系统中，硬件故障、系统软件和应用软件的故障、操作员的失误，甚至病毒、人为破坏总是不可避免的，为了保证故障发生后，系统能尽快从错误状态恢复到某种逻辑一致的状态，系统就必须有备份与恢复的机制。</p>
<p>系统的数据备份就是在系统其他地方创建数据与程序的电子复制，为重建系统中被破坏的或不正确的数据提供条件，备份最常用的技术是数据转储和建立日志文件。可以结合这两种技术为系统提供比较好的备份手段</p>
<p>数据转储可分为静态转储和动态转储。静态转储是指在系统中无事务时进行的转储操作，动态转储是指转储操作与用户事务并发进行，而且转储工作不会影响事务的运行，但它不能保证副本中的数据正确有效。</p>
<p>建立日志文件是指把所有事务对系统的修改活动都登记下来。若发生了故障，对于静态转储，可以在重装后备副本之后，利用日志文件进行恢复，避免重新运行事务；对于动态转储，可以把转储得到的副本和转储期间的日志文件结合起来进行故障恢复，使系统恢复正常工作状态。</p>
<p>备份通常分为联机备份和脱机备份两种方式</p>
<p>脱机备份也叫冷备份，是一种静态转储技术，备份系统所有的物理文件（控制文件、数据文件、重做日志和归档日志）和初始化文件。这种方式的优点是在恢复过程中步骤最少，它比热备份快并且出错机会少，定期的脱机备份加上一组好的重做日志可以把系统的数据恢复到任何一个时间点上。</p>
<p>联机备份也叫热备份，是一种动态转储技术，由于只备份所需的文件，因而被看作是部分备份。它在系统运行时执行。这种方式的优点是可以实现完全的时间点恢复，同时由于数据库一直处于打开状态，减少了系统对物理资源的要求，改善了数据的执行；但联机备份比较复杂，需要对系统的核心有比较深刻的认识，对备份策略进行反复的测试，才能最终确定它的正确性和可用性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/21/%E8%BD%AF%E8%80%83/16%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1(%E4%B8%83)%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BD%93%E7%B3%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="xuhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="循序渐进">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/21/%E8%BD%AF%E8%80%83/16%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1(%E4%B8%83)%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BD%93%E7%B3%BB/" class="post-title-link" itemprop="url">安全性和保密性设计（七）网络安全体系</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-21 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-21T00:00:00+08:00">2021-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-09 10:07:43" itemprop="dateModified" datetime="2021-11-09T10:07:43+08:00">2021-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BD%AF%E8%80%83-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/" itemprop="url" rel="index"><span itemprop="name">软考-系统架构设计师</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、OSI-安全架构"><a href="#一、OSI-安全架构" class="headerlink" title="一、OSI 安全架构"></a>一、OSI 安全架构</h1><p>SO的OS/RM是著名的网络架构模型,但是,OS/RM并没有在安全性方面作专门的设计，因此该模型本身的安全性是很弱的。为了改善网络的安全状况，提高网络安全强度，又在OSI/RM的基础上提出了一套OS安全架构,用以强化网络的安全性。</p>
<p>OSI 安全架构是一个面向对象的、多层次的结构，它认为安全的网络应用是由安全的服务实现的，而安全服务又是由安全机制来实现的</p>
<p>1.OSI 安全服务</p>
<p>针对网络系统的技术和环境，OS 安全架构中对网络安全提出了 5 类安全服务，即对象认证服务、访问控制服务、数据保密性服务、数据完整性服务、禁止否认服务。</p>
<p> (1) 对象认证服务。对象认证服务又可分为对等实体认证和信源认证，用于识别对等实体或信源的身份，并对身份的真实性、有效性进行证实。其中，对等实体认证用来验证在某一通信过程中的一对关联实体中双方的声称是一致的，确认对等实体中没有假冒的身份。信源认证可以验证所接收到的信息是否确实具有它所声称的来源。</p>
<p> (2) 访问控制服务。访问控制服务防止越权使用通信网络中的资源。访问控制服务可以分为自主访问控制、强制访问控制、基于角色的访问控制。由于 DAC、MAC 固有的弱点，以及 RBAC 的突出优势，所以 RBAC 一出现就成为在设计中最受欢迎的一种访问控制方法访问控制的具体内容前面已有讲述，此处不再赘述。</p>
<p> (3) 数据保密性服务。数据保密性服务是针对信息泄漏而采取的防御措施，包括信息保密、选择段保密、业务流保密等内容。数据保密性服务是通过对网络中传输的数据进行加密来实现的</p>
<p> (4) 数据完整性服务。数据完整性服务包括防止非法篡改信息，如修改、删除、插入、复制等。</p>
<p> (5) 禁止否认服务。禁止否认服务可以防止信息的发送者在事后否认自己曾经进行过的操作，即通过证实所有发生过的操作防止抵赖。具体的可以分为防止发送抵赖、防止递交抵赖和进行公证等几个方面。</p>
<p>2.OS安全机制</p>
<p>为了实现前面所述的 OS5 种安全服务，OS 安全架构建议采用如下 8 种安全机制：加密机制、数字签名机制、访问控制机制、数据完整性机制、鉴别交换机制、流量填充机制路由验证机制、公正机制。</p>
<p>(1) 加密机制。加密机制即通过各种加密算法对网络中传输的信息进行加密，它是对信息进行保护的最常用措施。加密算法有许多种，大致分为对称密钥加密与公开密钥加密两大类，其中有些（例如，DES 等）加密算法已经可以通过硬件实现，具有很高的效率，</p>
<p>(2) 数字签名机制。数字签名机制是采用私钥进行数字签名，同时采用公开密钥加密算法对数字签名进行验证的方法。用来帮助信息的接收者确认收到的信息是否是由它所声称的发送方发出的，并且还能检验信息是否被篡改、实现禁止否认等服务。</p>
<p>(3) 访问控制机制。访问控制机制可根据系统中事先设计好的一系列访问规则判断主体对客体的访问是否合法，如果合法则继续进行访问操作，否则拒绝访问。访问控制机制是安全保护的最基本方法，是网络安全的前沿屏障</p>
<p>(4) 数据完整性机制。数据完整性机制包括数据单元的完整性和数据单元序列的完整性两个方面。它保证数据在传输、使用过程中始终是完整、正确的。数据完整性机制与数据加密机制密切相关</p>
<p>(5) 鉴别交换机制。鉴别交换机制以交换信息的方式来确认实体的身份，一般用于同级别的通信实体之间的认证。要实现鉴别交换常常用到如下技术。</p>
<p>①口令：由发送方提交，由接收方检测。</p>
<p>②加密：将交换的信息加密，使得只有合法用户才可以解读。</p>
<p>③实体的特征或所有权：例如，指纹识别、身份卡识别等</p>
<p>(6) 业务流填充机制。业务流填充机制是设法使加密装置在没有有效数据传输时，还按照一定的方式连续地向通信线路上发送伪随机序列，并且这里发出的伪随机序列也是经过加密处理的。这样，非法监听者就无法区分所监听到的信息中哪些是有效的，哪些是无效的从而可以防止非法攻击者监听数据，分析流量、流向等，达到保护通信安全的目的。</p>
<p>(7) 路由控制机制。在一个大型的网络里，从源节点到目的节点之间往往有多种路由其中有一些是安全的，而另一些可能是不安全的。在这种源节点到目的节点之间传送敏感数据时，就需要选择特定的安全的路由，使之只在安全的路径中传送，从而保证数据通信的安</p>
<p>(8) 公证机制。在一个复杂的信息系统中，一定有许多用户、资源等实体。由于各种原因，很难保证每个用户都是诚实的，每个资源都是可靠的，同时，也可能由于系统故障等原因造成信息延、丢失等。这些很可能会引起责任纠纷或争议。而公证机构是系统中通信的各方都信任的权威机构，通信的各方之间进行通信前，都与这个机构交换信息，从而借助于这个可以信赖的第三方保证通信是可信的，即使出现争议，也能通过公证机构进行仲裁。</p>
<p>3.OSI 安全服务与安全机制之间的关系</p>
<p>OSI 安全服务与安全机制之间不是一一对应的关系。有的服务需要借助多种机制来实线同时，有些机制可以提供多种服务。<br><img src="/images/ruankao/10-1.png"></p>
<h1 id="二、VPN-在网络安全中的应用"><a href="#二、VPN-在网络安全中的应用" class="headerlink" title="二、VPN 在网络安全中的应用"></a>二、VPN 在网络安全中的应用</h1><p>虚拟专用网络（Virtual Private Network, VPN）是指利用不安全的公共网络如 Internet 等作为传输媒介，通过一系列的安全技术处理，实现类似专用网络的安全性能，保证重要信息的安全传输的一种网络技术。</p>
<p>1.VPN 技术的优点</p>
<p>VPN 技术具有非常突出的优点，主要包括</p>
<p> (1) 网络通信安全。VPN 采用安全隧道等技术提供安全的端到端的连接服务，位于 VPN 两端的用户在 Internet 上通信时，其所传输的信息都是经过 RSA 不对称加密算法加密处理的，它的密钥则是通过 Diffie- Hellman 算法计算得出的，可以充分地保证数据通信的安全。</p>
<p> (2) 方便的扩充性。利用 VPN 技术实现企业内部专用网络，以及异地业务人员的远程接入等，具有方便灵活的可扩性。首先是重构非常方便，只需要调整配置等就可以重构网络；其次是扩充网络方便，只需要配置几个节点，不需要对己经建好的网络作工程上的调整。</p>
<p> (3) 方便的管理。利用 VPN 组网，可以把大量的网络管理工作放到互联网络服务提供商一端来统一实现，从而减轻了企业内部网络管理的负担。同时 VPN 也提供信息传输、路由等方面的智能特性及与其他网络设备相独立的特性，也给用户提供了网络管理的灵活的手段。</p>
<p> (4) 节约成本显著。利用已有的无处不在的 Internet 组建企业内部专用网络，可以节省大量的投资成本及后续的运营维护成本。以前，要实现两个远程网络的互联，主要是采用专线连接方式。这种方式成本太高。而 VPN 则是在 Internet 基础上建立的安全性较好的虚拟专用网，因此成本比较低，而且可以把一部分运行维护工作放到服务商端，又可以节约部分维护成本。</p>
<p>2.VPN的原理</p>
<p>实现 VPN 需要用到一系列关键的安全技术，包括：</p>
<p> (1) 安全隧道技术。即把传输的信息经过加密和协议封装处理后再嵌套装入另一种协议的数据包中送入网络中，像普通数据包一样进行传输。经过这样的处理，只有源端和目标端的用户对加密封裝的信息能进行提取和处理，而对于其他用户而言，这些信息只是无意义的垃圾。</p>
<p> (2) 用户认证技术。在连接开始之前先确认用户的身份，然后系统根据用户的身份进行相应的授权和资源访问控制。</p>
<p> (3) 访问控制技术。由 VPN 服务的提供者与最终网络信息资源的提供者共同协商确定用户对资源的访问权限，以此实现基于用户的访问控制，实现对信息资源的保护。<br><img src="/images/ruankao/10-2.png"></p>
<p>安全隧道代理和管理中心组成安全传输平面（Secure Transmission Plane, STP），实现在 Internet 上安全传输和相应的系统管理功能。用户认证管理中心和密钥分配中心组成公共功能平面（Common Function Plane, CFP），它是安全传输平面的辅助平面，主要向用户代理提供相对独立的用户身份认证与管理、密钥的分配与管理功能。</p>
<p>建立 VPN 通信时，VPN 用户代理向安全隧道代理请求建立安全隧道，安全隧道代理接受后，在管理中心的控制和管理下在 Internet 上建立安全隧道，然后向用户提供透明的网络传输。VPN 用户代理包括安全隧道终端功能、用户认证功能和访问控制功能三个部分，它们共同向上层应用提供完整的 VPN 服务。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/21/%E8%BD%AF%E8%80%83/16%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1(%E4%BA%94)%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92%E4%B8%8E%E9%98%B2%E6%B2%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="xuhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="循序渐进">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/21/%E8%BD%AF%E8%80%83/16%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1(%E4%BA%94)%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92%E4%B8%8E%E9%98%B2%E6%B2%BB/" class="post-title-link" itemprop="url">安全性和保密性设计（五）计算机病毒与防治</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-21 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-21T00:00:00+08:00">2021-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-09 10:07:43" itemprop="dateModified" datetime="2021-11-09T10:07:43+08:00">2021-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BD%AF%E8%80%83-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/" itemprop="url" rel="index"><span itemprop="name">软考-系统架构设计师</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、计算机病毒概述"><a href="#一、计算机病毒概述" class="headerlink" title="一、计算机病毒概述"></a>一、计算机病毒概述</h1><p>计算机病毒（Computer Virus）的概念最早是由美国计算机病毒究专家 F. Cohen 博士提出的。对于计算机病毒的定义，不同的国家、不同的专家从不同的角度给出的定义也不尽相同。根据《中华人民共和国计算机信息系统安全保护条例》第 28 条规定：“计算机病毒，是指编制或者在计算机程序中插入的破坏计算机功能或者毁坏数据，影响计算机使用，并能自我复制的一组计算机指令或者程序代码。”此定义在我国具有法律效力和权威性。</p>
<p>和生物病毒一样，计算机病毒的复制能力使得计算机病毒可以很快地蔓延，又常常难以根除。它们能把自身附在宿主系统或文件中，当系统被运行或文件从一个用户传送到另一个用户时，它们就随同系统运行或文件传输一起蔓延开来。</p>
<p>在病毒的生命周期中，病毒一般会经历潜伏阶段、传染阶段、触发阶段和发作阶段 4 个阶段。多数病毒是基于某种特定的方式进行工作的，因此也依赖于某个特定的操作系统或某个特定的硬件平台。因此，攻击者经常利用某个特定系统的细节和弱点来设计病毒程序。</p>
<p>1.计算机病毒的特征</p>
<p>计算机病毒多种多样，但是它们都具有共同的特征，即传染性、非授权性、潜伏性和破坏性。</p>
<p>计算机病毒的传染性是指病毒具有把自身复制到其他系统或文件等宿主中去的能力，这是病毒的基本特征。非授权性是指病毒程序的执行不需要得到用户的同意，对用户来说是未知的。潜伏性是病毒生存的必要条件，即病毒潜伏在系统中而不被人们所发觉。破坏性是指病毒在一定条件下可以自动触发，并对计算机实施破坏，是病毒的表现特征。病毒的非授权性、潜伏性使得病毒的行为是不可预见的，也增加了病毒检测的困难。病毒破坏性的触发条件越多，则传染性越强，但同时其潜伏性降低。一个病毒必须具备传染性，但不一定需要拥有其他属性。</p>
<p>2.计算机病毒的分类</p>
<p>计算机病毒按不同的分类标准，有许多不同分类：</p>
<p>按照操作系统分，可分为攻击 DOS 系统的病毒、攻击 Windows 系统的病毒、攻击 Unix/ Linux系统的病毒、攻击OS/2系统的病毒、攻击 Macintosh 系统的病毒、攻击手机的病毒、其他操作系统上的病毒。</p>
<p>按照链接方式分，计算机病毒可分为源码型病毒、嵌入型病毒、She 病毒、宏病毒、脚本型病毒、操作系统型病毒</p>
<p>按照破坏情况分，计算机病毒可分为良性病毒和恶性病毒。</p>
<p>按传播媒介来分，计算机病毒可分为单机病毒和网络病毒。</p>
<p>3.计算机病毒的组成</p>
<p>病毒程序一般由传染模块、触发模块、破坏模块和主控模块组成，相应地完成病毒的传染、触发和破坏等任务。也有少数病毒不具备所有的模块</p>
<p> (1) 传染模块。传染模块是病毒进行扩散传播的部分，负责把计算机病毒从一个系统或文件传播到更多的系统或文件中去。每个病毒都有一个自我识别的标记，叫作传染标记或病毒签名。病毒程序传染系统或文件时，要把传染标记写入系统或文件中某个特定区域，例如，宿主程序、注册表、物理磁道等，作为该系统或文件已被传染的标记，以防止重复传染，增强病毒的潜伏效果。传染模块的主要功能有：寻找一个可传染的系统或文件；检査该系统或文件中是否有传染标记，判断该系统或文件是否已经被传染；如果没有传染标记，则进行传染操作，将病毒代码植入宿主系统或文件中，完成一次传染。</p>
<p> (2) 触发模块。病毒触发模块主要检査预定触发条件是否满足，如果满足，则调用相应传染或破坏模块，进行传染和破坏动作。病毒的触发条件有多种形式，如日期、时间、键盘、发现特定程序、发现网络连接、发现系统漏洞、传染的次数、特定中断调用的次数等。依据触发条件的情况，可以控制病毒传染和破坏动作的频率，使病毒在隐蔽的状态下，进行传染和破坏动作。</p>
<p> (3) 破坏模块。破坏模块负责实施病毒的破坏动作。这些破坏动作可能是破坏程序及数据、降低系统的性能、干扰系统的运行，还有些病毒甚至可以破坏计算机硬件。也有少数病毒的破坏模块并没有明显的恶意破坏行为，仅在被传染的系统设备上表现出特定的现象，该模块有时又称为表现模块。</p>
<p> (4) 主控模块。主控模块在总体上控制病毒程序的运行。染毒程序运行时，首先运行的是病毒的主控模块。</p>
<h1 id="二、网络环境下的病毒发展新趋势"><a href="#二、网络环境下的病毒发展新趋势" class="headerlink" title="二、网络环境下的病毒发展新趋势"></a>二、网络环境下的病毒发展新趋势</h1><h1 id="三、计算机病毒的检测与清除"><a href="#三、计算机病毒的检测与清除" class="headerlink" title="三、计算机病毒的检测与清除"></a>三、计算机病毒的检测与清除</h1><p>1.特征码检测</p>
<p>所谓特征码査毒法，就是在获取病毒样本后，提取出其特征码，（例如，杨基病毒的特征码是 16 进制的“F47A200”，快乐时光病毒中的“Fun Time”字符串等），然后通过该特征码对目标文件或内存等进行扫描。如果发现这种特征码，就说明感染了这种病毒，然后针对性地清除病毒。</p>
<p>特征码技术是最早被采用，而且被许多反病毒软件一直沿用至今的病毒检测方法。特征码检测方法检测病毒，方法简单、准确、快速，可识别病毒的名称，误报警率低。</p>
<p>但是，特征码技术只能诊断已知的计算机病毒，其响应速度永远滞后于病毒，而且不能检査未知病毒和变形病毒，不能对付隐蔽性病毒。</p>
<p>随着计算机病毒的发展，不断出现的新的病毒，甚至有些病毒具有自动变形功能，例如，“卡死脖”病毒，采用传统病毒特征码搜索技术的杀毒软件常常难以应付这些变形病毒。为此，人们提出了广谱特征码过滤技术，该技术在一定程度上可以弥补以上缺陷。</p>
<p>2.校验和检测</p>
<p>先计算正常文件的内容和正常的系统扇区数据的校验和，将该校验和写入数据库中保存。检测时，检査文件现在内容的校验和与原来保存的校验和是否一致，从而可以发现文件或扇区是否被感染，这种方法称校验和检测。</p>
<p>校验和检测技术的优点是：方法简单、能发现未知病毒、被査文件的细微变化也能发现。但是，它不能识别病毒种类。而且，由于病毒感染并非是文件内容改变的唯一原因，文件内容的改变有可能是正常程序引起的，所以校验和检测技术受到种种限制，同时这种方法也会影响文件的运行速度。另外，校验和不能检测新的文件，如从网络传输来的文件、磁盘和光盘拷入的文件、备份文件和压缩文档中的文件等。</p>
<p>3.行为监测</p>
<p>随着近年来病毒与反病毒斗争的不断升级、新病毒产生的速度不断加快，传统反病毒技术滞后于病毒的特点越来越不能适应防病毒的需要，更需要采用通用反病毒技术来保护计算机的安全。现阶段中被广泛研究和采用的通用病毒检测技术有病毒行为监测技术、启发式扫描技术和虚拟机技术。</p>
<p>通过研究发现，病毒不论伪装得如何巧妙，它们总是存在着一些和正常程序不同的行为，而这些行为在正常应用程序中却十分罕见，这就是病毒的行为特性。</p>
<p>常见的病毒行为特性有：对可执行文件进行写操作、写磁盘引导区、病毒程序与宿主程序的切换、程序自己重定位、通过搜索函数索引表来获取 A 函数地址等。</p>
<p>利用这些特征，就可以对病毒实施监视，在病毒程序体进行活动时发出报警。采用这种行为特性检测方法不仅可以检测出已知病毒，而且可以检测出新出现的未知病毒，无论该病毒是什么种类，或是否变形。但是，行为监测技术也可能误报警，而且不能识别病毒名称。</p>
<p>4.启发式扫描</p>
<p>在特征码扫描技术的基础上，利用对病毒代码的分析，获得一些统计的、静态的启发性知识，可以用于静态的启发性扫描技术（Heuristic Scanning)</p>
<p>启发式扫描主要分析文件中的指令序列，根据统计知识，判断该文件可能被感染或者没有被感染，从而有可能找到未知的病毒。因此，启发式扫描技术是一种概率方法，遵循概率理论的规律。早期的启发式扫描软件采用代码反编译技术作为它的实现基础。这类病毒检测软件在内部保存数万种病毒行为代码的跳转表，每个表项对应一类病毒行为的必用代码序列，如病毒格式化磁盘必须用到的代码等。启发式病毒扫描软件利用代码反编译技术，反编译出被检测文件的代码，然后在这些表格的支持下，使用“静态代码分析法”和“代码相似比较法”等有效手段，就能有效地査出已知病毒的变种，以及判定文件是否含有未知病毒。</p>
<p>由于病毒代码千变万化，具体实现启发式病毒扫描技术是相当复杂的。通常这类病毒检测软件要能够识别并探测许多可疑的程序代码指令序列，如格式化磁盘类操作、搜索和定位各种可执行程序的操作、实现驻留内存的操作、子程序调用中只执行入栈操作、远距离（如超过文件长度的三分之二）跳往文件头的指令等。一般来说，仅仅一项可疑的功能操作不足以触发病毒报警。但如果同时具有多项可疑操作，目标程序就很可能是病毒程序</p>
<p>5.虚拟机</p>
<p>自动变形病毒，也称为多态性病毒或多型（形）性病毒。自动变形病毒每次感染宿主时都自动改变自身的程序代码和特征码，这类病毒的代表有“幽灵”病毒等</p>
<p>般而言，自动变形病毒采用以下几种操作来不断变换自己：采用等价代码对原有代码进行替换；改变与执行次序无关的指令的次序；增加许多垃圾指令；对原有病毒代码进行压缩或加密等。因为自动变形病毒对其代码不断进行变换，而且每次传染使用不同的密钥。将染毒文件的病毒代码相互比较，也难以找出相同的可作为病毒特征的稳定特征码，因此用传统检测方法根本无法检测出这类病毒。但是，自动变形病毒也有一个共同的规律：即无论病毒如何变化，每一个自动变形病毒在其自身执行时都要对自身进行还原。</p>
<p>为了检测自动变形病毒，出现了一种新的病毒检测方法虚拟机技术”。该技术用软件方法让病毒在一个虚拟的环境中，仿真一部分系统指令和功能调用，对病毒代码作解释执行，而且仿真运行不对系统产生实际的影响，即可获得程序运行的后果，并在此基础上对程序运行分析，进而判断是否存在病毒。不管病毒使用什么样的加密、隐形等伪装手段，只要在虚拟机所营造的虚拟环境下，病毒都会随着运行过程自动褪去伪装（实际上是被虚拟机动态还原）。正是基于上述设计原理，虚拟机在处理加密、变换、变形病毒方面具有很强的优越性。</p>
<p>虚拟机检测方法，实际上是用软件实现了模拟人工反编译、智能动态跟踪、分析代码运行的过程，其效率更高，也更准确。使得反病毒从单纯的静态分析进入了动态和静态分析相结合的新时期，极大地提高了对已知病毒和未知病毒的检测水平。在今后相当长的一段时间内，虚拟机技术还会有很大的发展</p>
<p>6.病毒的清除</p>
<p>将病毒代码从宿主中去除，使之恢复为可正常运行的系统或程序，称为病毒清除。大多数情况下，采用反病毒软件或采用手工处理方式可以恢复受感染的文件或系统。</p>
<p>不是所有染毒文件都可以消毒，也不是所有染毒的宿主都能够被有效恢复。依据病毒的种类及其破坏行为的不同，感染病毒后，如果宿主数据没有被删除，常常可以恢复；如果宿主数据被病毒删除或覆盖、或者宿主数据的逻辑关系被病毒破坏，常常不能恢复。</p>
<h1 id="四、计算机病毒的预防"><a href="#四、计算机病毒的预防" class="headerlink" title="四、计算机病毒的预防"></a>四、计算机病毒的预防</h1><p>“防重于治”，对于计算机病毒也是如此。在日常使用计算机的过程中，同时做好预防工作，可以很大程度上避免被病毒感染，减少不必要的物力、数据损失</p>
<p>要预防计算机病毒，最好的方法就是不与外界交换文件，但这是不可能的。人们在工作中，要经常与外界进行各种数据交换。而大量与外界交换信息，就给病毒的感染与传播创造了条件。</p>
<p>为了保护计算机不受病毒破坏，至少必须做到： (1) 一定要在计算机中安装反病毒软件。</p>
<p> (2) 不要轻易使用来历不明的或者没有经过确认的软件；对从网络上下载的程序和文档应十分小心，在执行文件或打开文档之前，要检査是否有病毒；从外部取得的介质及其中的文件，应检査病毒后再使用；压缩后的文件应解压缩后检査病毒。</p>
<p> (3) 电子邮件的附件应该先检病毒后再开启，并在发送邮件之前检査病毒；不要运行来历不明的 E-mail 附件，尤其是在邮件正文中以诱惑性的文字建议执行的附件程序。</p>
<p> (4) 定期使用反病毒软件扫描系统。</p>
<p> (5) 确保所使用的反病毒软件的扫描引和病毒代码库为最新的，因为旧的扫描引擎和病毒代码库不会检查到新出现的病毒</p>
<p> (6) 为防止引导型病毒对系统的破坏，应该在系统安装完成后立即制作系统应急启动盘，以便万一硬盘分区表遭到破坏时，能从应急盘启动，并用备份的引导区、分区表等直接进行恢复。</p>
<p> (7) 对于一些重要的文件，要定期进行备份，以便万一系统遭受病毒破坏时能够从备份恢复。</p>
<p> (8) 利用安全扫描工具定时扫描系统和主机。若发现漏洞，及时寻找解决方案，从而减少被病毒和蠕虫感染的机会。</p>
<p> (9) 使用反病毒软件时，最好先毒，找到了带毒文件后，再确定是否进行杀毒操作。因为査毒不是危险操作，它可能产生误报，但绝不会对系统造成任何损坏；而杀毒是危险操作，有的操作可能把文件破坏。</p>
<p> (10) 建立本单位的计算机病毒防治管理制度；并对计算机用户进行反病毒培训。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="xuhj"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">xuhj</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">91</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xuhj</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  

</body>
</html>
