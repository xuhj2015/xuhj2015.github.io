---
title: 软件架构设计（四）层次系统架构风格
date: 2021-09-26
categories: [软考-系统架构设计师]
tags: [软考-软件架构设计]
---


# 一、二层及三层 C/S 架构风格

## 二层架构
C/S 架构是基于资源不对等，且为实现共享而提出来的，是 20 世纪 90 年代成熟起来 的技术，C/S 结构将应用一分为二，服务器(后台)负责数据管理，客户机(前台)完成与 用户的交互任务。

### 二层架构优点
具有强大的数据操作和事务处理能力，模型思想简单，易于人们理解和接受

### 二层架构缺点
单一服务器且以局域网为中心
软、硬件的组合及集成能力有限;
服务器的负荷太重，难以管理大量的客户机，系统的性能容易变坏;
数据安全性不好。

## 三层架构
三层 C/S 结构是 将应用功能分成表示层、功能层和数据层三个部分。

![](/images/ruankao/6-40.png)

# 二、B/S架构风格

浏览器/服务器(Browser/Server，简称 B/S)风格就是上述三层应用结构的一种实现方 式，其具体结构为:浏览器/Web 服务器/数据库服务器。

在 B/S 结构中，除了数据库服务器外，应用程序以网页形式存放于 Web 服务器上，用户运行某个应用程序时只需在客户端上的浏览器中键入相应的网址，调用 Web 服务器上 的应用程序并对数据库进行操作完成相应的数据处理工作，最后将结果通过浏览器显示给用 户。可以说，在 B/S 模式的计算机应用系统中，应用(程序)在一定程度上具有集中特征。

## B/S架构优点
B/S 架构主要是利用不断成熟的 WWW 浏览器技术，结合浏览器的多种脚本语言，用 通用浏览器就实现了原来需要复杂的专用软件才能实现的强大功能，并节约了开发成本。

## B/S架构缺点
与 C/S 架构相比，B/S 架构也有许多不足之处，例如:
(1)B/S 架构缺乏对动态页面的支持能力，没有集成有效的数据库处理功能。
(2)采用 B/S 架构的应用系统，在数据查询等响应速度上，要远远地低于 C/S 架构。
(3)B/S 架构的数据提交一般以页面为单位，数据的动态交互性不强，不利于在线事 务处理(OnLine Transaction Processing，简称 OLTP)应用。

# 三、MVC 架构风格
MVC 全名是 Model ViewController，是模型(model)-视图(view)-控制器(controller)的 缩写，它是分层架构风格的一种。

MVC 提出的基本思想是进行关注点分 离。一个典型的人机交互应用具有三个主要的关注点:数据在可视化界面上的呈现、UI 处 理逻辑和业务逻辑。

传统的自治视图模式(即将与 UI 相关的逻辑都定义在针对视图 的相关元素的事件上)，将三者混合在一起会带来一下问题：

(1)业务逻辑是与 UI 无关的，应该最大限度地被重用。由于业务逻辑定义在自治视 图中，相当于完全与视图本身绑定在一定，如果我们能够将 UI 的行为抽象出来，基于抽象 化 UI 的处理逻辑也是可以被共享的。但是定义在自治视频中的 UI 处理逻辑完全丧失了重 用的可能。
(2)业务逻辑具有最强的稳定性，UI 处理逻辑次之，而可视化界面上的呈现最差(比如我们经常会为了更好地呈现效果来调整 HTML)。如果将具有不同稳定性的元素融为一体，那么具有最差稳定性的元素决定了整体的稳定性。
(3)任何涉及 UI 的组件都不易测试。UI 是呈现给人看的，并且用于人机交互，用机 器来模拟活生生的人来对组件实施自动化测试不是一件容易的事，自治视图严重损害了组件 的可测试性。

![](/images/ruankao/6-41.png)

# 四、MVP 架构风格

MVP 是从经典的模式 MVC 演变而来。

MVC 模式中元素之间“混乱”的交互主要体现在允许 View 和 Model 直接进行“交流”，这在 MVP 模式中是不允许的。

MVP 不仅仅避免了 View 和 Model 之间的耦合，还进一步降低了 Presenter 对 View 的依赖。

![](/images/ruankao/6-42.png)

## MVP 的优点
(1)模型与视图完全分离，我们可以修改视图而不影响模型。 (2)可以更高效地使用模型，因为所有的交互都发生在一个地方—Presenter 内部。
(3)我们可以将一个 Presenter 用于多个视图，而不需要改变 Presenter 的逻辑。这个特性非常的有用，因为视图的变化总是比模型的变化频繁。
(4)如果我们把逻辑放在 Presenter 中，那么我们就可以脱离用户接口来测试这些逻辑(单元测试)。

## MVP 的缺点
（1）由于对视图的渲染放在了 Presenter 中，所以视图和 Presenter 的交互会过于频繁。
（2）如果 Presenter 过多地渲染了视图，往往会使得它与特定的视图的联系过 于紧密。一旦视图需要变更，那么 Presenter 也需要变更了。