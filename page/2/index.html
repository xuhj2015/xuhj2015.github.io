<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":20},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="循序渐进">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="循序渐进">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="xuhj">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>循序渐进</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?c67d6bf4daca1c3be5f919ad1f2ce211";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">循序渐进</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-navigation">

    <a href="/navigation/" rel="section"><i class="fa fa-archive fa-fw"></i>目录</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/21/%E8%BD%AF%E8%80%83/16%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1(%E5%9B%9B)%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="xuhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="循序渐进">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/21/%E8%BD%AF%E8%80%83/16%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1(%E5%9B%9B)%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">安全性和保密性设计（四）安全协议</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-21 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-21T00:00:00+08:00">2021-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-09 10:07:43" itemprop="dateModified" datetime="2021-11-09T10:07:43+08:00">2021-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BD%AF%E8%80%83-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/" itemprop="url" rel="index"><span itemprop="name">软考-系统架构设计师</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、IPSec-协议简述"><a href="#一、IPSec-协议简述" class="headerlink" title="一、IPSec 协议简述"></a>一、IPSec 协议简述</h1><p>在TCP/P协议中,对IP数据包没有提供任何安全保护,攻击者可以通过网络嗅探、IP 欺骗、连接截获等方法来攻击正常的TCP/IP通信。因此,通信过程中会存在以下危险:数据并非来自合法的发送者、数据在传输过程中被非法篡改、信息内容已被人窃取等。</p>
<p>为了确保在 P 网络上进行安全保密的通信，IETF 制定了一套开放标准的网络安全协议  Ipsec (IP Security）。该协议把密码技术应用在网络层，以向信息的发送方和接收方提供源地址验证、数据传输的完整性、存取控制、保密性等安全服务，保护通信免遭窃听、抵御网络攻击，而且更高层的应用层协议也可以直接或间接地使用这些安全服务，为其上层协议如 TCP、UDP 等提供透明的安全保护服务，在 Internet 这样不安全的网络中为通信提供安全保证。</p>
<p>在 IPv6 中，Ipsec 协议是一个必备的组成部分，被强制实施；在 IPv4 中，它是一个可选的扩展协议。</p>
<p>由于 Internet 等网络具有公共特性，因此在通信过程中难以确认传输媒介是安全的，所以要进行安全的通信，则通信数据必须经过加密。Ipsec 协议对数据的加密以数据包而不是整个数据流为单位，这不仅非常灵活，也有助于进一步提高 P 数据包的安全性。</p>
<p>Ipsec 协议的基本工作原理是：发送方在发送数据前对数据实施加密，然后把密文数据发送到网络中去，开始传输。在整个传输过程中，数据都是以密文方式传输的，直到数据到达目的节点，才由接收方对密文进行解密，提取明文信息。</p>
<p>PSec 协议对网络层的通信使用了加密技术，它不是加密数据包的头部和尾部信息（如源地址、目的地址、端口号、CRC 校验值等），而是对数据包中的数据进行加密。由于加密过程发生在 IP 层，因此可在不改变 HTP 等上层应用协议的情况下进行网络协议的安全加密，为通信提供透明的安全传输服务。</p>
<p> Ipsec 协议中使用端到端的工作模式，掌握加密、解密方法的只有数据的发送方和接收方，两者各自负责相应的数据加密、解密处理，而网络中其他节点只负责转发数据，无须支持 Ipsec，从而可以实现加密通信与传输媒介无关，保证机密数据在公共网络环境下的适应性和安全性。因此，Ipsec 可以应用到非常广泛的环境中，能为局域网、拨号用户、远程站点、Internet 之上的通信提供强有力的保护，而且还能用来筛选特定数据流，还可以用于不同局域网之间通过互联网的安全互联</p>
<p> Ipsec 协议不是一个单独的协议，它包括应用于 P 层上网络数据安全的一整套协议，主要包括 AH (Authentication Header, IP 认证头部协议）、ESP (Encapsulating Security Payload，封装安全负载协议）、IKE (Internet Key Exchange, Internet 密钥交换协议）和用于网络认证及加密的一些算法等。</p>
<p>AH 提供数据的完整性和认证，但不包括保密性；而 ESP 原则上只提供保密性，但也可在 ESP Header 中选择适当的算法及模式来实现数据的完整性和认证。AH 和 ESP 可分开使用也可一起使用。IKE 则提供加密算法、密钥等的协商。</p>
<h1 id="二、SSL-协议"><a href="#二、SSL-协议" class="headerlink" title="二、SSL 协议"></a>二、SSL 协议</h1><p>SSL 是用于安全传输数据的一种通信协议。它米用公钥加密技术、对称密钥加密技术等保护两个应用之间的信息传输的机密性和完整性。但是，SSL 也有一个不足，就是它本身不能保证传输信息的不可否认性。</p>
<p>SL 协议包括服务器认证、客户认证、SSL 链路上的数据完整性、SSL 链路上的数据保密性等几个方面，通过在浏览器和 Web 服务器之间建立一条安全的通道来保证 Internet 数据传递的安全性。目前，利用公钥加密的 SL 技术，已经成为 Internet 上进行保密通信的工业标准。SSL 协议常常用于增强 Web 服务的安全性。</p>
<p>在 TCP/IP协议中,SSL协议建立在传输层即TCP之上、应用层之下。SSL 协议有一个突出的优点，就是它与应用层协议相独立，高层的应用层协议如 HTTP 等可以透明地建立在 SSL 协议之上进行工作。</p>
<p>通过 SSL 协议建立的传输通道具有如下的基本安全性</p>
<p> (1) 通道是保密的，经过握手确定密钥之后，所有的消息被加密。SSL 协议在应用层协议工作之前就已经完成了加密算法、密钥的协商、服务器认证等工作，而此后的所有应用层所传送的数据都是经过加密的，因此 SSL 协议具有很好的保密性。</p>
<p> (2) 通道是被认证的，通信中的服务器端总是被认证，客户端可选认证。在基于 SSL 协议的通信过程中，服务器端认证是必须进行的，所以，即使在一次会话过程中不进行客户端认证，该会话的确认性也能够有很好的保证。</p>
<p> (3) 通道是可靠的，用 MAC 对传送的消息进行完整性检查，保证通道上数据的完整性。基于 SSL 协议的通信过程，因为传递的消息中包括消息完整性检査数据（即 MAC 数据），因此，可以保证该通信是可靠的。</p>
<p>SSL 协议由 SL 记录协议、SSL 握手协议、SSL 密码变更说明协议、SSL 警告协议等组成。</p>
<h1 id="三、PGP-协议"><a href="#三、PGP-协议" class="headerlink" title="三、PGP 协议"></a>三、PGP 协议</h1><p>PGP (Pretty Good Privacy）是美国人 Philzimmermann 于 1995 年提出的一套电子邮件加密方案。它可以用来对邮件加密以防止非授权者阅读，还能对邮件加上数字签名而使收信人可以确认邮件确实是由发送方发出的</p>
<p>PGP 并不是新的加密算法或协议，它综合采用了多种加密算法，例如，对邮件内容加密采用 IDEA 算法、对于加密信息采用 RSA 公钥加密算法，还采用了用于数字签名的消息摘要算法，加密前进行压缩处理等技术手段进行邮件加密的一套软件。通过组合使用这些加密方法，把 RSA 公钥加密体系的良好加密效果和对称密钥加密体系的高速度结合起来，并且通过在数字签名和密钥认证管理机制中的巧妙设计，使得 PGP 成为一个优秀的强有力的数据加密程序。</p>
<p>由于 PGP 功能强大、处理迅速、使用简便，而且它的源代码是免费的，因此，PGP 在 T 等多个行业得到了广泛的应用，迅速普及。如今，PGP 除了用于通常的电子邮件加密，还可以用来加密重要文件，用 PGP 代替 Uuencode 生成 RADIX64 格式（就是 MIME 的 BASE64 格式）的编码文件，以保证它们在网络上的安全传输，或为文件做数字签名，以防止篡改和伪造。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/21/%E8%BD%AF%E8%80%83/16%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1(%E5%85%AD)%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E4%B8%8E%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="xuhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="循序渐进">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/21/%E8%BD%AF%E8%80%83/16%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1(%E5%85%AD)%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E4%B8%8E%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/" class="post-title-link" itemprop="url">安全性和保密性设计（六）身份认证与访问控制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-21 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-21T00:00:00+08:00">2021-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-09 10:07:43" itemprop="dateModified" datetime="2021-11-09T10:07:43+08:00">2021-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BD%AF%E8%80%83-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/" itemprop="url" rel="index"><span itemprop="name">软考-系统架构设计师</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>访问控制是通过某种途径限制和允许对资源的访问能力及范围的一种方法。它是针对越权使用系统资源的保护措施，通过限制对文件等资源的访问，防止非法用户的侵入或者合法用户的不当操作造成的破坏，从而保证信息系统资源的合法使用</p>
<p>访问控制技术可以通过对计算机系统的控制，自动、有效地防止对系统资源进行非法访问或者不当地使用，检测出一部分安全侵害，同时可以支持应用和数据的安全需求</p>
<p>访问控制技术并不能取代身份认证，它是建立在身份认证的基础之上的。</p>
<p>问控制技术包括如下几方面的内容</p>
<p> (1) 用户标识与认证。用户标识与认证是一种基于用户的访问控制技术，它是防止未经授权的用户进入系统的一种常规技术措施。用户标识用于向系统声明用户的身份。用户标识一般应当具有唯一性，其最常见的形式就是用户 ID。系统必须采用一定的策略来维护所有的用户标识。验证用户标识的有效性、真实性，通常有三种类型的认证方式：一是用户个人掌握的秘密信息，例如，口令、密钥、PIN 码等；二是用户个人所拥有的带有认证信息的特定物品，例如，磁卡、IC 卡等；三是用户个人的特定生理、生物学特征，例如，声音指纹等。在同一种系统中可以单独采用一种认证方法，也可以联合采用多种认证方法。</p>
<p> (2) 逻辑访问控制。逻辑访问控制是基于系统的访问控制技术，用来控制特定的用户对特定资源的访问。通常，把用户分成不同的组，再对组授予不同的访问权限来实现对用户的逻辑访问控制，防止用户访问他所不需要访问的资源、或者进行与工作无关的访问</p>
<p> (3) 审计与跟踪。审计与跟踪系统的一个或多个运行记录，在事件发生后对事件进行调査，分析其时间、原因、活动内容、引发的相关事件、涉及的用户等。</p>
<p> (4) 公共访问控制。如果一个应用系统是面向公众开放，允许公众进行访问时，面临的主要威胁是来自外部的匿名攻击，必须采取访问控制等措施以保护系统数据的完整性和敏感信息的保密性。</p>
<h1 id="一、身份认证技术"><a href="#一、身份认证技术" class="headerlink" title="一、身份认证技术"></a>一、身份认证技术</h1><p>身份认证是对系统的用户进行有效性、真实性验证。</p>
<p>1.口令认证方式</p>
<p>使用口令认证方式，用户必须具有一个唯一的系统标识，并且保证口令在系统的使用和存储过程中是安全的，同时口令在传输过程中不能被窃取、替换。另外特别要注意的是在认证前，用户必须确认认证者的真实身份，以防止把口令发给冒充的认证者。</p>
<p>使用口令的单向身份认证过程一般是：请求认证者和认证者之间建立安全连接、并确认认证者身份等；然后请求认证者向认证者发送认证请求，认证请求中必须包括请求认证者的 ID 和口令；认证者接受 ID 和口令，在用户数据库中找出请求认证的 ID 和口令；査找是否有此用户并比较两口令是否相同；最后向请求认证者发回认证结果。如果请求认证者的 ID 在认证者的用户数据库中，并且请求认证者发送的口令与数据库中相应的口令相同，则允许请求认证者通过认证</p>
<p>2.基于公钥签名的认证方式</p>
<p>公开密钥签名算法的身份认证方式，是通过请求认证者与认证者（对于双向身份认证而言，双方互为请求认证者和认证者）之间对于一个随机数做数字签名与验证数字签名来实现的。这种方式中认证双方的个人秘密信息不用在网络上传送，从而减少了口令等秘密信息泄漏的风险。</p>
<p>采用数字签名技术认证与口令认证方式有一个很大的不同：口令认证通常在正式数据交换开始之前进行。认证一旦通过，双方即建立安全通道进行通信，此后的通信被认为是安全的，不再进行身份认证；而数字签名认证在每一次的请求和响应中进行，即接收信息的一方先从接收到的信息中验证发送者的身份信息，验证通过后才对收到的信息进行相应处理</p>
<p>使用公钥加密算法进行身份认证要求：请求认证者必须具有私钥实现数字签名的功能；认证者必须具有使用公钥验证数字签名的功能；认证者必须具有产生随机数的功能，而且随机数的质量必须达到一定要求</p>
<p>使用公钥加密算法进行身份认证的方式，对用于数字签名的私钥由参与通信的认证者自己保密，而用于验证数字签名的公钥则需要采用可靠的方式进行安全分发。一般可以采用公钥数据库方式或者使用认证机构签发数字证书的方式（认证机构与数字证书的内容参见前文 PKI 部分）</p>
<p>如果使用公钥数据库的方式管理公钥，则请求认证者 1D 就包含在认证请求中发给认证者，认证者使用该 ID 从公钥数据库中获得请求认证者的公钥。</p>
<p>如果使用认证机构签发数字证书的方式管理公钥，则请求认证者的数字证书包含在认证请求中发给认证者，认证者验证请求认证者的数字证书后，从数字证书中获取请求认证者的公钥。</p>
<p>3.持卡认证方式</p>
<p>持卡认证方式最早采用磁卡。磁卡中最重要的部分是磁道，不仅存储数据，而且还存储用户的身份信息。目前所用的卡是 IC 卡，与磁卡相比，它除了存储容量大之外，还可一卡多用，同时具有可靠性高，寿命长，读写机构简单可靠，造价便宜，维护方便，容易推广等诸多优点。正由于上述优点，使得 IC 卡在世界各地广泛使用。IC 卡上一般分为不加密的公共区、加密的数据区等，有些还有自己的操作系统和微处理器。IC 卡已被广泛应用于身份认证领域。</p>
<p>一般 IC 卡与用户的个人 PIN 一起使用。在脱机系统中，PN 以加密的形式存在卡中识别设备读出 C 卡中的身份信息，然后将其中的 PIN 解密，与用户输入的 PIN 比较，以决定 IC 卡持有者是否合法。在联机系统中，PIN 可不存在 IC 卡上，而存在主机系统中，鉴别时，系统将用户输入的 PIN 与主机的 PIN 比较，而由此认证其身份的合法性。</p>
<p>4.基于人体生物特征的认证方式</p>
<p>这种方式是指通过计算机，利用人体固有的生理特征或行为特征进行个人身份鉴定。与传统的身份鉴别手段相比，基于生物特征的认证技术具有突出的优点：一是不会遗忘或丢失二是防伪性能好，无法伪造；三是随时随地可用。能够用来鉴别身份的生物特征一般具有广泛性（每个人都应该具有这种特性）、唯一性（每个人拥有的特征应各不相同）、稳定性（所选择的特征应该不随时间变化而发生变化）和可采集性（所选择的特征应该便于采集、测量）。前，可用于身份鉴别的生物特征主要有指纹、笔迹、脸像、红外温、视网膜、手形、掌纹等。</p>
<p>由于生物特征识别的设备比其他身份认证的设备要复杂，所以一般用在非常重要的机密场合，如军事等。生物特征识别主要采用模式识别技术。身份识别系统工作方式分为识别模式和鉴定模式，其性能指标主要有错误拒绝率和错误接受率等。在选择这种认证方式时需要对这些参数作认真的考虑。</p>
<p>5.动态口令技术（一次性口令技术）</p>
<p>般情况下，所使用的计算机口令都是静态的，也就是说在一定的时间内是相对不变的，而且可重复使用。这种口令很容易被系统中的嗅探程序所劫持，而且很容易受到基于字典的暴力攻击</p>
<p>针对这种静态口令认证方式的缺陷，人们提出了利用散列函数产生一次性口令的方法，即用户每次登录系统时使用的口令都是变化的。一次性口令是动态变化的密码，其变化来源于产生密码的运算因子。一次性口令的产生因子一般都采用双运算因子：一是用户的私钥，它代表用户身份的识别码，是固定不变的。二是变动因子，正是变动因子的不断变化，才能够产生动态的一次性口令</p>
<p>动态口令技术认证方式中要用到动态口令密码卡，这是一种便于携带的智能化硬件产品。这种密码卡内置的构件和程序能通过密码卡内的密钥加上其他因子动态地计算出新的口令</p>
<p>当密码卡持有者将这个口令输入计算机时，系统中的认证服务器会根据相同的算法和动态因子计算出对应于该密码卡的认证口令，并把这个口令与密码卡产生的口令比对，进行身份认证。</p>
<p>6.PPp中的认证协议</p>
<p>点到点协议（Point-to- Point Protocol, PPp）提供了一种在点到点链路上封装网络层协议信息的标准方法。PP 也定义了可扩展的链路控制协议。链路控制协议使用验证协议磋商机制，在链路层上传输网络层协议前验证链路的对端。</p>
<p>PPP 包含如下几个部分：在串行链路上封装数据报的方法；建立、配置和测试数据链路连接的链路控制协议（Link Control Protocol, LC）；建立和配置不同网络层协议的一组网络控制协议（Network Control Protocol, NCP）。</p>
<p>PPP 协议定义了两种验证协议：密码验证协议（Password Authentication Protocol, PAP）和挑战一握手验证协议（Challenge- Handshake Authentication Protocol, CHAP），此外还有扩展认证协议（Extensible Authentication Protocol, EAP）。</p>
<p>一个典型的 PPP 链路建立过程分为三个阶段：创建阶段、认证阶段和网络层协商阶段。（1) 创建阶段。在这个阶段，将对基本的通信方式进行选择。链路两端设备通过 LCP 向对方发送配置信息，建立链路。在链路创建阶段，只是对验证协议进行选择，具体的用户验证过程在认证阶段实现。</p>
<p> (2) 认证阶段。在这个阶段，客户端会将自己的身份发送给远端的接入服务器。该阶段使用一种安全的验证方式避免第三方窃取数据或冒充远程客户接管与客户端的连接。认证成功，则转到网络层协商阶段。如果认证失败，则链路终止。</p>
<p> (3) 网络层协商阶段。认证阶段完成之后，PPP 将调用在链路创建阶段选定的各种 NC 协商高层协议问题，例如，在该阶段 IP 控制协议可以向拨入用户分配动态地址。这样，经过三个阶段以后，一条完整的 PP 链路就建立起来了。</p>
<p>最常用的认证协议有 PAP 和 CHAP，此外还有 EAP。</p>
<p>7.RADIUS 协议</p>
<p> RADIUS (Remote Authentication Dial- in User Service)协议是由朗讯公司提出的客户/服务器方式的安全认证协议，它能在拨号网络中提供注册、验证功能，现已成为 Internet 的正式协议标准，是当前流行的 AAA (Authentication、Authorization、Accountion）协议  RADIUS 协议可以把拨号和认证这两种功能放在两个分离的服务器一一网络接入服务器（NAS）和后台认证服务器（RADIUS 服务器）上。在 RADIUS 服务器上存放有用户名和它们相应的认证信息的一个大数据库，来提供认证用户名和密码及向用户发送配置服务的详细信息等。</p>
<h1 id="二、访问控制技术"><a href="#二、访问控制技术" class="headerlink" title="二、访问控制技术"></a>二、访问控制技术</h1><p>访问控制是在身份认证的基础上，根据不同身份的用户对用户的访问请求加以限制。身份认证关心的是“你是谁，你是否拥有你所声明的身份”这个问题；而访问控制则关心“你能做什么，不能做什么”的问题。</p>
<p>在访问控制过程中，一般把发出访问、存取请求的一方，例如，用户、程序、进程等叫作主体；而把被访问的对象和资源，例如，文件、数据库、设备、内存区域等叫作客体。另外还有一套定义主体与客体之间相互关系，确定不同主体对不同客体的访问能力与权限的规则，叫作访问规则。一个完整的访问控制体系就是由上述三方面共同构成的。</p>
<p>1.访问控制策略</p>
<p>访问控制策略一般可以划分为三类：自主访问控制（Discretionary Access Control, DAC）强制访问控制（Mandarory Access Control, MAC），基于角色的访问控制（Roal Based Access  Control, RBAC）。其中 DAC、MAC 是属于传统的访问控制策略，而 RBAC 则是后来出现的种访问控制策略，被认为具有很大的优势，具有很好的发展前景。</p>
<p> (1) DAC。自主访问控制是目前计算机系统中实现最多的访问控制机制，它使主体可以自主地进行配置以决定其他的主体可以采取什么样的方式来访问其所拥有的一些资源，即个拥有一定权限范围的主体可以直接或者间接地把权限授予其他的主体</p>
<p>常见的操作系统如 Windows、UNⅨ等都是采用自主访问控制策略来实施访问控制的其常见的方式是由某个用户（一般为某个文件或资源的拥有者或超级管理员）采用某种方式指定不同类型、不同分组的其他用户对其名下的资源的访问许可和访问方式</p>
<p>自主访问控制策略中，由用户自己决定其他用户对系统中某些资源的访问权限，这样虽然方便，但是却很难保证这种类型的授权对于整个系统来说是安全的。首先，用户往往不知道或者难以确定其他的用户是否适合具有对某些资源的访问权限；其次，如果不是所有的用户都有很强的安全意识，可能随意授权，那么这对于系统安全就是一个潜在的威胁；再次，由用户自己决定访问权限的分配，不利于系统管理员实施统一的全局访问控制；另外，许多组织中往往希望对于信息系统采取的授权与控制结构能够与该组织的行政结构一致。总之自主访问控制策略容易使系统失控，容易给非法入侵者留下可乘之机。所以，自主访问控制策略的安全性不是很高。</p>
<p>随着网络规模的扩大，用户对访问控制服务的质量也提出了更高的要求，采用自主访问控制策略已经很难满足一个安全性要求比较高的系统的需要。</p>
<p> (2) MAC。强制访问控制是系统统一采用某种访问权限的授予和撤销的策略，而且强制所有主体都必须服从这种访问权限的分配。</p>
<p>MAC 一般用在安全级别层次比较多的军事、安全等特殊应用领域中。它预先为系统中接受的所有主体、客体根据可以信任的程度、所处的岗位和承担的任务、信息的敏感程度时间发展的阶段等划分成若干级别，例如，信息可以分为绝密、机密、秘密和无密级等不同的级别。然后再根据主体和客体的级别标记来决定访问模式，任何用户对任何客体的访问请求都由这种安全级别的划分及相应的权限配置来控制</p>
<p>强制访问控制由于过于强调系统的安全性能，虽然能够很好地控制系统的安全，但是它管理起来比较麻烦，工作量很大，也不够灵活。</p>
<p>(3) RBAC。DAC 和 MAC 访问控制策略都各有其特点，但是也各有它们的不足。而基于角色的访问控制则可以在克服以上两者的缺点的同时，提供一个良好的安全的系统环境，因而是面向企业的系统中一种十分有效的访问控制策略。</p>
<p>DAC 系统中，有一种常见的情况，就是在一个组织中，最终用户能够使用某些资源但是它并不是该资源的拥有者，资源的拥有者是这个组织或组织中的所有用户。这时，就应该基于用户的职务来进行访问权限的设置和分配，而不应该基于资源的拥有者来进行。</p>
<p>例如，在图书馆中，应该根据某一个用户是流通人员、文献编目人员，还是分馆的管理员等不同的角色来分配和设置权限。如果是文献编目人员，那么他对系统中流通的图书这种资源就只能有看的权限，而对未进行典藏的图书等资源就有比较高的访问权限；如果是分馆的管理员，那么他相应地就具有对该分馆的读者、文献等资源有较高的访问权限，而对其他用户则没有。也就是说，用户具有什么样的访问权限，不直接取决于用户自己，而是取决于他所属的角色，有什么样的角色就有什么样的权限。</p>
<p>角色的种类和访问权限由系统管理员来定义，每一个成员属于哪种类型的角色也由系统管理员来规定，即只有系统管理员才有权定义和分配角色，而且对于用户来说只能服从系统中的这一系列规定，而不能有自主的配置，因此这是一种非自主型访问控制策略。</p>
<p>2.访问许可的授权对访问许可的授权有三种类型</p>
<p> (1) 等级型。把对客体的存取控制权限的修改能力划分成不同的等级，拥有高级别修改能力的主体可以把这种权限分配给比其级别低的主体。依此类推，从而将访问许可的授权关系组成一个树型结构。</p>
<p>例如，超级管理员可以作为这个等级树的根，具有修改所有客体的存取控制表的能力且可以向任意一个主体分配这种修改权。系统管理员把用户根据部门划分成多个子集，并对部门领导授予相应存取控制权限的修改权和对修改权的分配权。部门领导又可以把自己所拥有的权力按照同样的方法向下授权。</p>
<p>这种方式的优点是树型结构与实际组织机构类似，并且可以由领导根据日常实际工作需要进行授权来对各级用户进行控制与管理。但这种方式也有一个缺点，就是对同一个客体来说，可能存在多个主体有能力修改其存取控制权限</p>
<p> (2) 拥有型。这种类型对每一个客体都有一个拥有者（一般情况下就是该客体的创建者），拥有者具有对所拥有的客体的全部的控制权，并且可以任意修改其拥有的客体的访问控制表，并可对其他主体授予或销对其客体的任何一种访问权限。但是拥有者无权将其对客体的访问控制权的分配权予其他主体</p>
<p>在 UNX 系统中就是用这种方式来进行授权控制的</p>
<p> (3) 自由型。自由型的特点是一个客体的拥有者可以对任何主体授予对他所拥有的客体的访问权限，同时还可以把这种分配权授予其他主体而不受任何限制。这样，获得了这种授权的主体就可以把这种分配权授予更多的主体而不受该客体拥有者的限制。这样，一旦访问控制的分配权被授予出去，就很难控制对客体的访问了。显然，这样做安全性比较差，般的系统中很少采用这种方式</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/20/%E8%BD%AF%E8%80%83/16%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1(%E4%B8%80)%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="xuhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="循序渐进">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/20/%E8%BD%AF%E8%80%83/16%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1(%E4%B8%80)%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86/" class="post-title-link" itemprop="url">安全性和保密性设计（一）加密和解密</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-20 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-20T00:00:00+08:00">2021-10-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-09 10:07:43" itemprop="dateModified" datetime="2021-11-09T10:07:43+08:00">2021-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BD%AF%E8%80%83-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/" itemprop="url" rel="index"><span itemprop="name">软考-系统架构设计师</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>信息安全，具体地说就是保证信息的保密性、完整性、真实性、占有性。</p>
<p>保密性是指系统中的信息必须按照该信息拥有者的要求保证一定的秘密性，不会被未经许可的第三方非法获取。系统必须阻止一切对秘密信息的非授权访问或泄露。</p>
<p>完整性是指系统中的信息应当安全、准确、有效，要求数据不能被非法改动或删除。完整性是信息安全的最基本要求。为了实现完整性，可以借助本章讲述的数字签名、加密等措施，从而有力地保护数据的完整。</p>
<p>真实性是指对信息的发送者身份的确认或系统中有关主体的身份确认，这样可以保证信息的可信度。信息的真实性可以通过数字签名、公钥加密等方式来实现。</p>
<p>占有性是指要保护信息赖以存储的节点、介质、载体等不被盗用或窃取。保护信息占有性的方法有使用版权、专利、商业秘密性，提供物理的或逻辑的存取限制方法，维护和检有关窃取文件的记录等。</p>
<h1 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h1><p>密码学是研究加密方法、秘密通信的原理，以及解密方法、破译密码的方法的一门科学。</p>
<p>加密和解密的过程大致如下：首先，信息的发送方准备好要发送信息的原始形式，叫作明文。然后对明文经过一系列变换后形成信息的另一种不能直接体现明文含义的形式，叫作密文。由明文转换为密文的过程叫作加密。在加密时所采用的一组规则或方法称为加密算法接收者在收到密文后，再把密文还原成明文，以获得信息的具体内容，这个过程叫作解密。解密时也要运用一系列与加密算法相对应的方法或规则，这种方法或规则叫作解密算法。在加密、解密过程中，由通信双方掌握的参数信息控制具体的加密和解密过程，这个参数叫作密钥。密钥分为加密密钥和解密密钥，分别用于加密过程和解密过程。</p>
<p>在加密和解密的过程中，如果采用的加密密钥与解密密钥相同，或者从一个很容易计算出另一个，则这种方法叫作对称密钥密码体制，也叫作单钥密码体制。反之，如果加密和解密的密钥并不相同，或者从一个很难计算出另外一个，就叫作不对称密钥密码系统或者公开密钥密码体制，也叫作双钥密码体制。</p>
<h2 id="一、对称秘钥加密算法"><a href="#一、对称秘钥加密算法" class="headerlink" title="一、对称秘钥加密算法"></a>一、对称秘钥加密算法</h2><p>对称密钥密码体制中，加密和解密过程中所使用的是同一个密钥，或者即使加密密钥和解密密钥不同，但是很容易地由一个计算出另外一个。显然，在这种密码体制中，密钥成为整个秘密通信的核心，整个加密系统的安全性完全以密钥的保密为基础。如果密钥暴露，则整个密码体制就完全失去了保密的效果。所以说，密钥的保密是对称密钥加密体制安全保密的关键，必须妥善保存并经由可靠的渠道传递。</p>
<p>对称密钥加密算法有多种，例如，DES (Data Encryption Standard，数据加密标准）、IDEA  (International Data Encryption Algorithm，国际数据加密算法）、Skipjack、3DES、GDES、New DES、Lucifer、FEAL N、LOKI91、RC4、RC5 等。</p>
<h2 id="二、不对称秘钥加密算法"><a href="#二、不对称秘钥加密算法" class="headerlink" title="二、不对称秘钥加密算法"></a>二、不对称秘钥加密算法</h2><p>对称密钥加密方法是加密、解密使用同样的密钥，由发送者和接收者同时保存，在加密和解密时使用相同的密钥。采用这种方法的主要问题是密钥的生成、导入、存储、管理、分发等过程比较复杂，特别是随着用户的增加，密钥的需求量成倍增加。而在较大规模的信息系统中，大量密钥的分配与管理是一个难以解决的问题。</p>
<p>与对称密钥加密方法不同，不对称密钥加密技术在对信息进行加密和解密时，需要分别采用两个不同的密钥，因此也称为双钥加密方法。它在运算中，先产生一对密钥，其中之是保密密钥，由用户自己保存，不能向外界泄漏，简称私钥；另一个为公开密钥，可对外公开，甚至可在公共目录中列示，简称公钥，因此也称公开密钥加密方法。</p>
<p>只有使用私钥才能解密用公钥加密的数据，同时使用私钥加密的数据只能用公钥解密。在通信过程中，如果发送者要向接收者发送保密信息，则需要先用接收者的公开密钥对信息进行加密，然后发送给该接收者，接收方用其私钥能够顺利解密。而其他人即使收到加密的密文也无法正确解读，从而达到保密通信的目的。</p>
<p>公开密钥加密方法中，要想达到良好的加密效果，算法上必须做到：在计算上产生密钥常容易；已知公钥的情况下对明文加密在计算上很容易实现；已知私钥的情况下对密文解密在计算上很容易实现；尽管用于加密和解密的两个密钥在数学上是相关的，但是在已知公钥的情况下，要想求得私钥在计算上不可行；已知公钥和密文的情况下，要想求得明文在计算上不可行。只有做到以上几点，才能有效地防止攻击者对算法的破译。</p>
<p>不对称密钥加密算法有多种，例如，RSA、背包密码、Mceliece、Diffe Hellman、Rabin、 Ong Fiat Shamir、零知识证明的算法、椭圆曲线、Elgamal 等。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/20/%E8%BD%AF%E8%80%83/16%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1(%E4%B8%89)%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E4%B8%8E%E7%A7%98%E9%92%A5%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="xuhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="循序渐进">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/20/%E8%BD%AF%E8%80%83/16%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1(%E4%B8%89)%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E4%B8%8E%E7%A7%98%E9%92%A5%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">安全性和保密性设计（三）数字证书与秘钥管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-20 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-20T00:00:00+08:00">2021-10-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-09 10:07:43" itemprop="dateModified" datetime="2021-11-09T10:07:43+08:00">2021-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BD%AF%E8%80%83-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/" itemprop="url" rel="index"><span itemprop="name">软考-系统架构设计师</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>过去，人们总是依赖于对于加密算法和密钥的保密来增加保密的强度和效果。随着现代密码学的发展，大部分的加密算法都已经公开了。一些典型的算法（例如，DES、IDEA、RSA 等）更是成了国际标准，被广泛接纳。人们可以从多种途径来获取算法的细节，也已经有很多采用这些算法的软件、硬件设备可以利用</p>
<p>因此，在现代密码系统中，算法本身的保密已经不重要了，对于数据的保密在很大程度上，甚至完全依赖于对密钥的保密。只要密钥能够保密，即使加密算法公开，甚至加密设备丢失，也不会对加密系统的坚固性和正常使用产生多大影响。相反，如果密钥丢失，则非法用户可以窃取机密数据，而合法用户却面对密文如读天书，无法提取有效的信息。与其如此还不如不加密呢！因此，在密码系统中，如何高效地分配密钥、安全地管理密钥对于保证数据安全至关重要。</p>
<h1 id="一、秘钥分配中心（Key-Distribution-Center，密匙分配中心）"><a href="#一、秘钥分配中心（Key-Distribution-Center，密匙分配中心）" class="headerlink" title="一、秘钥分配中心（Key Distribution Center，密匙分配中心）"></a>一、秘钥分配中心（Key Distribution Center，密匙分配中心）</h1><p>在 KDC 方案中，每一个用户都只保存自己的私钥 SK 和 KDC 的公钥 PKDC，而在通信时再经由 KDC 获得其他用户的公钥 PK 或者仅仅在某一次通信中可以使用的对称密钥加密算法的临时密钥 K。</p>
<h1 id="二、数字证书和公开密钥基础设施"><a href="#二、数字证书和公开密钥基础设施" class="headerlink" title="二、数字证书和公开密钥基础设施"></a>二、数字证书和公开密钥基础设施</h1><p>公钥加密算法的密钥分配和对称密钥加密算法中密钥的分配要求有着很大的区别。在对称密钥加密体制中，要求将密钥从一方传送到另一方，并且保证只有通信的双方知道密钥，而不让其他任何一方知道密钥。</p>
<p>而在公钥加密体制中，则要求通信各方的私钥只有通信的一方知道，而其他任何一方都不能知道，同时每一方的公钥需要公开，其他任何一方都可以查看和提取。</p>
<p>在公钥加密体制中，私钥的分配相对容易，但是，公钥的发布和获取就需要采取合适的方法来进行，否则很容易留下安全漏洞种简单的发布公钥的方法是公开宣布。通信系统中的每一方都独自保管好自己的私钥，而把自己的公钥公开地公布给其他所有各方，以使其他人能够得到他的公钥，从而可以与他进行加密通信。这实现起来非常简单，似乎也没有什么问题。但是，却有一个致命的漏洞，就是任何一个非法入侵者也可以冒充是这个通信系统中的一方，向这个通信系统中公布一个冒充的公钥。此后系统中与该用户的通信实际上就是与该非法冒充者进行通信。</p>
<p>数字签名和公钥加密都是基于不对称加密技术，因此也存在这样的问题：如何保证公开密钥的持有者是真实的；大规模信息系统环境下公开密钥如何产生、分发和管理。</p>
<p>要解决上述问题，就要用到数字证书和 PK (Public Key Infrastructure，公开密钥基础设施）</p>
<p>1、数字证书</p>
<p>数字证书提供了一个在公钥和拥有相应私钥的实体之间建立关系的机制。目前最常用的数字证书格式是由国际标准 ITU-TX.509v3 版本定义的。</p>
<p>数字证书中采用公钥体制，即利用一对互相匹配的密钥进行加密、解密。每个用户自己保存私钥，用它进行解密和签名；同时设定一个公钥，并由本人公开，为一组用户所共享，用于加密和验证签名。</p>
<p>数字证书是用户在系统中作为确认身份的证据。在通信的各个环节中，参与通信的各方通过验证对方数字证书，从而确认对方身份的真实性和有效性，从而解决相互间的信任问题。</p>
<p>数字证书的内容一般包括：唯一标识证书所有者的名称、唯一标识证书签发者的名称、证书所有者的公开密钥、证书签发者的数字签名、证书的有效期及证书的序列号等。</p>
<p>2.公开密钥基础设施</p>
<p>PKI 在信息系统中的作用就相当于作为公共设施在社会生活中的作用，其目标是向广大的信息系统用户和应用程序提供公开密钥的管理服务。PKI 是指由数字证书、证书颁发机构（Certificate Authority, CA），以及对电子交易、通信等所涉及的各方的合法性进行检查和验证的其他注册机构组成的一套系统。为了使用户在不可靠的网络环境中获得真实可靠的公开密钥，PK 引入公认可信的第三方；同时 PK 中采用数字证书机制来避免在线询集中存放的公开密钥产生的性能瓶颈。可信的第三方是 PKI 的核心部件，系统中任意两个实体之间都是通过公认可信的第三方建立安全联系的。数字证书中第三方的数字签名，使用户可以离线地确认一个公开密钥的真实性。</p>
<p>除了数字证书的有效期，证书撤销列表（Certificate Revocation List, CRL）是另一种数字证书有效期控制机制。当数字证书中认可的事实发生变化时，数字证书发布者必须使用某种</p>
<p>机制来销以前发出、但现在失效的证书。证书发布者定期发布 CRL，列出所有曾发布但当前已被销的证书号，证书的使用者依据 CRL 即可验证某证书是否已被撤销。</p>
<p>(1) PKI 的结构模型。PK 中有三类实体：管理实体、端实体和证书库。管理实体是 PKI 的核心，是 PKI 服务的提供者；端实体是 PKI 的用户，是 PK 服务的使用者；证书库是一个分布式数据库，用于证书和 CRL 的存放和检索。</p>
<p>CA 和注册机构（Registeauthority, RA）是两种管理实体。CA 是 PK 框架中唯一能够发布和撤销证书的实体，维护证书的生命周期；RA 负责处理用户请求，在验证了请求的有效性后，代替用户向 CA 提交。RA 可以单独实现，也可以合并在 CA 中实现。作为管理实体，CA 和 RA 以证书方式向端实体提供公开密钥的分发服务。</p>
<p>持有者和验证者是两种端实体。持有者是证书的拥有者，是证书所声明的事实上的主体持有者向管理实体申请并获得证书，也可以在需要时请求撇销或更新证书。持有者使用证书声明自己的身份，从而获得相应的权力。验证者确认持有者所提供的证书的有效性和对方是否为该证书的真正拥有者，只有在成功鉴别之后オ可与对方进行更进一步的交互。</p>
<p>证书库可以用 Web、FTP 或目录等来实现。由于证书库中存取的对象是证书和 CRL，其完整性由数字签名保证，因此对证书库的操作可在无特殊安全保护的通道上传输。</p>
<p>不同的实体间通过 PKI 操作完成证书的请求、确认、发布、撇销、更新和获取等过程。PK 操作分成存取操作和管理操作两类。其中，存取操作包括管理实体或端实体，把证书和 CRL 存放到证书库、从证书库中读取证书和 CRL；管理操作则是管理实体与端实体之间或管理实体与管理实体之间的交互，是为了完成证书的各项管理任务和建立证书链。</p>
<p>(2) PKI 层次模型。PKI 框架可以分为三个层次。最低层是传输层，向上提供 PKI 报文的可靠传输，它可以是传输层协议或应用层协议。中间层是密码学服务层，向上提供加密、解密、数字签名、消息摘要等基本密码学服务，可由 RSA、MD5 等方法实现。最高层是证书服务层，使用前面两层提供的加密和传输服务，向用户提供证书的请求、签发、发布、撤销和更新等服务。</p>
<p>PKI 的三类实体对这三层服务的使用各不相同。证书库不需要特殊的安全交互措施，所以仅使用传输层服务来分发证书和 CRL；管理实体和端实体使用证书服务层构造 PK 证书，使用密码学服务层来鉴别和保护交互信息，使用传输层服务传送信息。</p>
<p>(3)X.509数字证书。ISO/TU、ANSl、IETF等组织制定的X.509 标准，对数字证书的格式进行了专门定义，该标准是为了保证使用数字证书的系统间的互操作性而制定的。理论上为一种应用创建的 X.509 证书可以用于其他任何符合 X.509 标准的应用。但实际上，不同的公司对 X.509 证书进行了不同的扩展，并不是所有的证书都彼此兼容。</p>
<p>X.509 证书具有如下一些突出的特点：</p>
<p>①支持多种算法。X.509 证书独立于算法，CA 可以根据需要选择证书的签名和摘要算法，以及端实体所拥有密钥对的类型。摘要算法有 MD2、MD5 和 SHA-1, 证书签名算法有 RSA 和 DSA，密钥对类型有 RSA 密钥、DSA 签名密钥、D-H 密钥交换密钥、KEA 密钥和  ECDSA 密钥。</p>
<p>支持多种命名机制。X.509 证书除了使用 X.500 名字机制标识持证者和验证者，还支持 E-mail 地址、IP 地址、DNS 名和 UR。</p>
<p>③可以限制证书（公开密钥）的用途。CA 能够规定证书的使用范围，如签名、不可否认、密钥加密、数据加密、密钥协商、证书签发和 CRL 签发等。</p>
<p>④定义证书遵循的策略。每个 CA 都定义了一定的安全策略，规范证书的操作过程。这些策略包括：CA 的命名空间、身份验证、撇销机制、法律责任和收费等。</p>
<p>⑤控制信任关系的传递。建立 CA 体系，跨域认证，使得每个 CA 除负责本域的证书管理任务外，还要维护与其他 CA 间的信任关系。X.509 证书定义若干字段用于控制信任关系的传递，CA 能够将自己管理域的安全策略体现在信任关系中</p>
<p>可见，X.509 证书适用于大规模信息系统环境，它的灵活性和扩展性能够满足各种应用系统不同类型的安全要求。</p>
<p>X.509 有不同的版本，例如，X.509v3 是比较新的版本，它是在原有版本 X.509 的基础上进行功能的扩充。每一版本都包含下列数据项：</p>
<p>①版本号。用来区分 X.509 的不同版本号。</p>
<p>序列号。由 CA 给每一个证书分配唯一的数字型编号，由同一 CA 发放的每个证书的序列号是唯一的。</p>
<p>3③签名算法识别符。用来指定 CA 签发证书时所使用的公开密钥算法和 HASH 算法，须向国际标准组织注册。</p>
<p>④发行者名称。建立和签署证书的 CA 名称。</p>
<p>⑤有效期。证书有效的时间包括两个日期：证书开始生效的日期、证书失效的日期和时间。在所指定的这两个时间之间有效。</p>
<p>⑥主体名称。证书持有人的姓名、服务处所等信息。</p>
<p>⑦主体的公开密钥信息。包括主体的公开密钥、使用这一公开密钥的算法的标识符及相应的参数。</p>
<p>⑧ 发行者唯一识别符。这一数据项是可选的，当 CA 名称重新用于其他实体时，则用这一识别符来唯一标识发行者。</p>
<p>⑨主体唯一标识符。这一数据项也是可选的，当主体的名称重新用于其他实体时，则用这一识别符来唯一识别主体。</p>
<p>⑩扩充域。其中包括一个或多个扩充的数据项。</p>
<p>⑪签名。CA 用自己的私钥对上述各数据项的散列值进行数字签名的结果。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/20/%E8%BD%AF%E8%80%83/16%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1(%E4%BA%8C)%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E4%B8%8E%E6%95%B0%E5%AD%97%E6%B0%B4%E5%8D%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="xuhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="循序渐进">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/20/%E8%BD%AF%E8%80%83/16%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1(%E4%BA%8C)%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E4%B8%8E%E6%95%B0%E5%AD%97%E6%B0%B4%E5%8D%B0/" class="post-title-link" itemprop="url">安全性和保密性设计（二）数字签名与数字水印</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-20 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-20T00:00:00+08:00">2021-10-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-09 10:07:43" itemprop="dateModified" datetime="2021-11-09T10:07:43+08:00">2021-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BD%AF%E8%80%83-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/" itemprop="url" rel="index"><span itemprop="name">软考-系统架构设计师</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>散列函数是一种公开的数学函数。散列函数运算的输入信息也可叫作报文。散列函数运算后所得到的结果叫作散列码或者叫作消息摘要。散列函数具有如下一些特点：</p>
<p> (1) 不同内容的报文具有不同的散列码，而一旦原始报文有任何改变，哪怕改变一位信息，则通过散列函数计算后得到的散列码也将完全不同。这样，这个散列码就好比是这个报文所特有的“指纹”。</p>
<p> (2) 散列函数是单向的，即求解某一个报文的散列码非常容易，但是根据散列码来倒推原始报文是非常困难的</p>
<p> (3) 对于任何一个报文，无法预知它的散列码。</p>
<p> (4) 散列码具有固定的长度，不管原始报文的长度如何，通过散列函数运算后的散列码都具有一样的长度。例如，MD5 (Message Digest Algorithm5, 消息摘要算法第 5 个版本）散列算法的散列码长度为 128 位，并且不管是对一部百科全书，还是对某个人的工资进行 MD5 散列运算，得到的散列码长度都是 128 位。</p>
<p>由于散列函数具有这些特征，因此散列函数可以用来检测报文的可靠性。接收者对收到的报文用与发送者相同的散列函数进行运算，如果得到与发送者相同的散列码，则可以认为报文没有被篡改，否则，报文就是不可信的。</p>
<p>常见的散列函数有 MD5、SHA、HMAC 等。MD5 是一种非常著名的散列算法，已经成为国际标准，具有很好的安全性能。MD5 算法在对输入的报文进行计算时，是以 512 位为单位进行处理的，结果生成一个 128 位长的消息摘要；SHA、HMAC 等算法都是对任意长度的报文以 512 位为单位进行处理，最后得出一个 160 位的消息摘要。</p>
<h1 id="一、数字签名"><a href="#一、数字签名" class="headerlink" title="一、数字签名"></a>一、数字签名</h1><p>对于计算机系统中传送、存储的重要文件、数据、信息等，一般需要有某种方式来确认其真实性，即接收者能够确认自己得到的信息确实是由该信息所声称的发送者发出的，而不是由非法入侵者伪造、冒充发出的，并且还要能够保证信息在传送、存储中没有被恶意改，这样这份信息才能真实地反映发送方的意图。另外，对于发送方来说，如果发出一份信息还必须有一定的措施阻止其否认自己发出信息的行为，即不可否认性。</p>
<p>只有做到以上几点，一个信息传送、存储系统才能够安全、可靠，其上所传送、存储的信息才是真实的、值得相信的。</p>
<p>数字签名主要由两个算法组成：签名算法和验证算法。通过使用签名算法签名一个消息，所得到的签名能够通过一个验证算法来验证签名的真实性和有效性。</p>
<p>所以数字签名技术的大致过程就是：信息的发送方对信息利用自己的私钥进行签名，接着发送方把这个签名和信息一起发送给接收方。接收方收到信息后利用发送方的公钥来对其中的数字签名进行验证，确认其合法性。</p>
<p>目前已经有大量的数字签名算法，例如，RSA 数字签名算法、El Gamal、Fiat-shamir、 Guillon- Oucsquerrter、DS (Digital Signature Standard，数字签名标准）、DSA (Digital Signature Algorithm，数字签名算法）、椭圆曲线等。</p>
<p>1．RSA 结合 MD5 数字签名<br>RSA 结合 MD5 数字签名的主要过程是：信息的发送方通过对信息进行散列运算生成个消息摘要，接着发送方用自己的私钥对这个消息摘要进行加密，就形成发送方的数字签名。然后，把这个数字签名作为信息的附件和信息一起发送给信息的接收方。接收方收到信息后首先对收到的信息进行与发送者相同的散列运算得到一个消息摘要，接着再用发送方的公钥来对信息中附加的数字签名进行解密得到发送方计算出的散列码。如果两个散列码相同，那么接收方就能确认该信息和数字签名是由发送方发出的。通过数字签名能够实现对原始信息完整性的鉴别和发送方发送信息的不可抵赖性。</p>
<p>RSA 用于数字签名的一个重要的特点是能够证实信息发送方的身份及电子文件的可靠性和完整性，它对于发送方和被发送的信息都是独一无二的，具有可验证性和不可否认的权威性特点；另一个重要的特点是它通过在计算机之间交换数字证书就可以确定当事者就是他们所宣称的人。</p>
<p>2．数字签名标准</p>
<p>DSs 是美国国家标准与技术学会的数字签名标准，自 1991 年提出以来又经过广泛的修改。DSS 为计算和验证数字签名指定了一个数字签名算法-DSA。DSA 是 E Gamal 数字签名算法的一个改进版本，它通过选择较小规格的参数减少数字签名的数据量，从而减少了存储空间和传输带宽。</p>
<p>DSs 中指定 SHA 作为其散列算法，它对原始信息进行运算后产生 160 位的消息摘要，然后 DS 把这一消息摘要与一个用作这个特殊签名的随机数作为输入送到数字签名算法中，经过运算生成数字签名</p>
<p>该数字签名函数还依赖于发送方的私钥 SK 和一个对许多通信方都公开的由重要的公钥集合组成的全局公钥。</p>
<p>接收方在收到消息摘要和签名后将其作为验证函数的输入。验证函数还依赖于全局公钥和与发送方的私钥相匹配的公钥 PK，这样只有发送方用其自己的私钥才能产生有效的签名</p>
<p>数字签名作为一项重要的鉴别技术，近年来越来越受到人们的重视，在政府、军事、金融、安全等领域得到广泛的运用。通过数字签名可以有效地保证数据的完整性，防止第三方伪造或发送方的抵赖。</p>
<p>2004 年 8 月 28 日，十届全国人大常委会第十一次会议表决通过了电子签名法。这部法律规定，可靠的电子签名与手写签名或者盖章具有同等的法律效力，并于 2005 年 4 月 1 日起施行。这部法律将对我国电子商务、电子政务等计算机信息系统的发展起到极其重要的促进作用。</p>
<h1 id="二、数字信封"><a href="#二、数字信封" class="headerlink" title="二、数字信封"></a>二、数字信封</h1><p>数字信封是公钥密码体制在实际中的一个应用，是用加密技术来保证只有规定的特定收信人才能阅读通信的内容。</p>
<p>在数字信封中，信息发送方采用对称密钥来加密信息内容，然后将此对称密钥用接收方的公开密钥来加密（这部分称数字信封），之后，将它和加密后的信息一起发送给接收方，接收方先用相应的私有密钥打开数字信封，得到对称密钥，然后使用对称密钥解开加密信息。这种技术的安全性相当高。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%80%83%E8%AF%95/%E4%B9%9D%E3%80%81%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6(%E4%B8%80)%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1%E4%B8%8E%E7%BB%9F%E8%AE%A1%E6%8E%A8%E6%96%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="xuhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="循序渐进">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%80%83%E8%AF%95/%E4%B9%9D%E3%80%81%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6(%E4%B8%80)%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1%E4%B8%8E%E7%BB%9F%E8%AE%A1%E6%8E%A8%E6%96%AD/" class="post-title-link" itemprop="url">数据科学（一）概率统计与统计推断</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-18 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-18T00:00:00+08:00">2021-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-09 10:07:43" itemprop="dateModified" datetime="2021-11-09T10:07:43+08:00">2021-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%BA%94%E7%94%A8-%E4%B8%AD%E7%BA%A7/" itemprop="url" rel="index"><span itemprop="name">大数据分析应用-中级</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1、掌握概率、条件概率的概念，并会计算简单的概率、条件概率。"><a href="#1、掌握概率、条件概率的概念，并会计算简单的概率、条件概率。" class="headerlink" title="1、掌握概率、条件概率的概念，并会计算简单的概率、条件概率。"></a>1、掌握概率、条件概率的概念，并会计算简单的概率、条件概率。</h1><p>概率，亦称“或然率”，它是反映随机事件出现的可能性大小。随机事件是指在相同条件下，可能出现也可能不出现的事件。例如，从一批有正品和次品的商品中，随意抽取一件，“抽得的是正品”就是一个随机事件。设对某一随机现象进行了n次试验与观察，其中A事件出现了m次，即其出现的频率为m/n。经过大量反复试验，常有m/n越来越接近于某个确定的常数（此论断证明详见伯努利大数定律）。该常数即为事件A出现的概率，常用P (A) 表示。</p>
<p>条件概率是指事件A在事件B发生的条件下发生的概率。条件概率表示为：P（A|B），读作“A在B发生的条件下发生的概率”。若只有两个事件A，B，那么，P(A|B)=P(AB)/P(B)。</p>
<p>P(B|A)=P(A|B)P(B)/P(A)</p>
<h2 id="统计独立性"><a href="#统计独立性" class="headerlink" title="统计独立性"></a>统计独立性</h2><p>当且仅当两个随机事件A与B满足P(A∩B)=P(A)P(B)的时候，它们才是统计独立的，这样联合概率可以表示为各自概率的简单乘积。<br>同样，对于两个独立事件A与B有P(A|B)=P(A)以及P(B|A)=P(B)，换句话说，如果A与B是相互独立的，那么A在B这个前提下的条件概率就是A自身的概率；同样，B在A的前提下的条件概率就是B自身的概率。</p>
<h2 id="互斥性"><a href="#互斥性" class="headerlink" title="互斥性"></a>互斥性</h2><p>当且仅当A与B满足P(A∩B)=0且P(A)≠0，P(B)≠0的时候，A与B是互斥的。<br>因此，P(A|B)=0，P(B|A)=0。换句话说，如果B已经发生，由于A不能和B在同一场合下发生，那么A发生的概率为零；同样，如果A已经发生，那么B发生的概率为零。</p>
<h1 id="2、理解随机事件的独立性和随机变量的独立性。"><a href="#2、理解随机事件的独立性和随机变量的独立性。" class="headerlink" title="2、理解随机事件的独立性和随机变量的独立性。"></a>2、理解随机事件的独立性和随机变量的独立性。</h1><p>事件的相互独立可定义试验的相互独立，试验的相互独立可推出一些事件的相互独立。试验的独立性和随机变量的独立性都是在事件独立性的基础上来定义的。随机变量取某个值或取某个连续区间时，就是表示某事件。</p>
<h1 id="3、掌握乘法公式、全概率公式、贝叶斯公式，并会简单应用。"><a href="#3、掌握乘法公式、全概率公式、贝叶斯公式，并会简单应用。" class="headerlink" title="3、掌握乘法公式、全概率公式、贝叶斯公式，并会简单应用。"></a>3、掌握乘法公式、全概率公式、贝叶斯公式，并会简单应用。</h1><p><img src="/images/bigdata/4-1.png"><br><img src="/images/bigdata/4-2.png"><br><img src="/images/bigdata/4-3.png"><br><img src="/images/bigdata/4-4.png"><br><img src="/images/bigdata/4-5.png"><br><img src="/images/bigdata/4-6.png"></p>
<h1 id="4、掌握随机变量分布函数的概念，掌握连续型随机变量的密度函数和离散型随机变量的分布列。"><a href="#4、掌握随机变量分布函数的概念，掌握连续型随机变量的密度函数和离散型随机变量的分布列。" class="headerlink" title="4、掌握随机变量分布函数的概念，掌握连续型随机变量的密度函数和离散型随机变量的分布列。"></a>4、掌握随机变量分布函数的概念，掌握连续型随机变量的密度函数和离散型随机变量的分布列。</h1><p>概率分布用以表达随机变量取值的概率规律，根据随机变量所属类型的不同，概率分布取不同的表现形式<br>离散型分布：二项分布、多项分布、伯努利分布（两点分布）、泊松分布<br>连续型分布：均匀分布、正态分布、指数分布、伽玛分布、偏态分布、贝塔分布</p>
<h1 id="5、掌握常见分布（两点分布、二项分布、泊松分布、均匀分布、正态分布、指数分布）及其简单性质。"><a href="#5、掌握常见分布（两点分布、二项分布、泊松分布、均匀分布、正态分布、指数分布）及其简单性质。" class="headerlink" title="5、掌握常见分布（两点分布、二项分布、泊松分布、均匀分布、正态分布、指数分布）及其简单性质。"></a>5、掌握常见分布（两点分布、二项分布、泊松分布、均匀分布、正态分布、指数分布）及其简单性质。</h1><p>二项分布的每一次尝试都是独立的，前一次投掷的结果不能决定或影响当前投掷的结果，只有两个可能结果并且重复n次的实验叫做二项式。</p>
<p>多项分布是二项分布的推广扩展，在n次独立实验中每次只输出k种结果中的一个，且每种结果都有一个确定概率，多项分布给出在多种输出状态的情况下，关于成功次数的各种组合的概率。</p>
<p>伯努利分布（两点分布）只有两种可能的结果，1-成功和0-失败，具有伯努利分布特征的随机变量X可以取值为1的概率为p，取值为0的概率1-p，其中成功和失败的概率不一定相等。</p>
<p>当二项分布的n很大而p很小时，泊松分布可作为二项分布的近似，其中λ为np。通常当n≧20,p≦0.05时，就可以用泊松公式近似得计算。</p>
<p>均匀分布也叫矩形分布，它是对称概率分布，在相同长度间隔的分布概率是等可能的。 均匀分布由两个参数a和b定义，它们是数轴上的最小值和最大值，通常缩写为U（a，b）。</p>
<p>正态分布（Normal distribution），也称“常态分布”，又名高斯分布（Gaussian distribution）。正态曲线呈钟型，两头低，中间高，左右对称因其曲线呈钟形，因此人们又经常称之为钟形曲线。</p>
<p>指数分布（也称为负指数分布）是描述泊松过程中的事件之间的时间的概率分布，即事件以恒定平均速率连续且独立地发生的过程。 这是伽马分布的一个特殊情况。 它是几何分布的连续模拟，它具有无记忆的关键性质。 除了用于分析泊松过程外，还可以在其他各种环境中找到。</p>
<h1 id="6、理解数学期望、方差（标准差）、相关系数的概念，并会简单计算。"><a href="#6、理解数学期望、方差（标准差）、相关系数的概念，并会简单计算。" class="headerlink" title="6、理解数学期望、方差（标准差）、相关系数的概念，并会简单计算。"></a>6、理解数学期望、方差（标准差）、相关系数的概念，并会简单计算。</h1><h2 id="数学期望"><a href="#数学期望" class="headerlink" title="数学期望"></a>数学期望</h2><p>在概率论和统计学中，数学期望(mean)（或均值，亦简称期望）是试验中每次可能结果的概率乘以其结果的总和，是最基本的数学特征之一。它反映随机变量平均取值的大小。<br><img src="/images/bigdata/4-7.png"></p>
<h2 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h2><p>概率论中方差用来度量随机变量和其数学期望（即均值）之间的偏离程度。统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方值的平均数。在许多实际问题中，研究方差即偏离程度有着重要意义。方差是衡量源数据和期望值相差的度量值。<br><img src="/images/bigdata/4-8.png"></p>
<h2 id="标准差"><a href="#标准差" class="headerlink" title="标准差"></a>标准差</h2><p>标准差是方差算术平方根。</p>
<h1 id="7、了解多元随机变量的概念，掌握多元正态分布。"><a href="#7、了解多元随机变量的概念，掌握多元正态分布。" class="headerlink" title="7、了解多元随机变量的概念，掌握多元正态分布。"></a>7、了解多元随机变量的概念，掌握多元正态分布。</h1><p>多元随即变量也是变量，这个变量有两个未知的数组成<br>比如说，向直角坐标平面内投掷小球，小球的落点是一个随机变量，这个随机变量是用坐标表示（x，y），则就是二元随机变量<br>又如某一天的天气情况，由阴晴和风的情况组成，是一个随机变量，用（晴，三级）表示某天的天气晴，三级风，这也是一个二元随机变量，如果再加上温度的话，就是三元随机变量了。</p>
<p>多变量正态分布亦称为多变量高斯分布。它是单维正态分布向多维的推广。它同矩阵正态分布有紧密的联系。</p>
<h1 id="8、理解统计量的概念，理解样本均值、样本方差（标准差）的概念，并会简单计算。"><a href="#8、理解统计量的概念，理解样本均值、样本方差（标准差）的概念，并会简单计算。" class="headerlink" title="8、理解统计量的概念，理解样本均值、样本方差（标准差）的概念，并会简单计算。"></a>8、理解统计量的概念，理解样本均值、样本方差（标准差）的概念，并会简单计算。</h1><p>统计量是统计理论中用来对数据进行分析、检验的变量。宏观量是大量微观量的统计平均值，具有统计平均的意义，对于单个微观粒子，宏观量是没有意义的．相对于微观量的统计平均性质的宏观量也叫统计量。需要指出的是，描写宏观世界的物理量例如速度、动能等实际上也可以说是宏观量，但宏观量并不都具有统计平均的性质，因而宏观量并不都是统计量。</p>
<h1 id="9、了解点估计的概念，了解点估计的无偏性、相合性。"><a href="#9、了解点估计的概念，了解点估计的无偏性、相合性。" class="headerlink" title="9、了解点估计的概念，了解点估计的无偏性、相合性。"></a>9、了解点估计的概念，了解点估计的无偏性、相合性。</h1><h1 id="10、了解参数的矩估计、最大似然估计。"><a href="#10、了解参数的矩估计、最大似然估计。" class="headerlink" title="10、了解参数的矩估计、最大似然估计。"></a>10、了解参数的矩估计、最大似然估计。</h1><h1 id="11、了解线性回归的基本概念。"><a href="#11、了解线性回归的基本概念。" class="headerlink" title="11、了解线性回归的基本概念。"></a>11、了解线性回归的基本概念。</h1><p>线性回归是利用数理统计中回归分析，来确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法，运用十分广泛。其表达形式为y = w’x+e，e为误差服从均值为0的正态分布。</p>
<p>回归分析中，只包括一个自变量和一个因变量，且二者的关系可用一条直线近似表示，这种回归分析称为一元线性回归分析。如果回归分析中包括两个或两个以上的自变量，且因变量和自变量之间是线性关系，则称为多元线性回归分析。</p>
<h1 id="12、了解方差分析（ANOVA）的基本概念。"><a href="#12、了解方差分析（ANOVA）的基本概念。" class="headerlink" title="12、了解方差分析（ANOVA）的基本概念。"></a>12、了解方差分析（ANOVA）的基本概念。</h1><p>方差分析(Analysis of Variance，简称ANOVA)，又称“变异数分析”，是R.A.Fisher发明的，用于两个及两个以上样本均数差别的显著性检验。 由于各种因素的影响，研究所得的数据呈现波动状。造成波动的原因可分成两类，一是不可控的随机因素，另一是研究中施加的对结果形成影响的可控因素。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%80%83%E8%AF%95/%E4%B9%9D%E3%80%81%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6(%E4%B8%89)%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="xuhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="循序渐进">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%80%83%E8%AF%95/%E4%B9%9D%E3%80%81%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6(%E4%B8%89)%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">数据科学（三）深度学习与强化学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-18 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-18T00:00:00+08:00">2021-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-09 10:07:43" itemprop="dateModified" datetime="2021-11-09T10:07:43+08:00">2021-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%BA%94%E7%94%A8-%E4%B8%AD%E7%BA%A7/" itemprop="url" rel="index"><span itemprop="name">大数据分析应用-中级</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1、掌握全连接网络（MLP）的定义与算法原理、并能够应用。"><a href="#1、掌握全连接网络（MLP）的定义与算法原理、并能够应用。" class="headerlink" title="1、掌握全连接网络（MLP）的定义与算法原理、并能够应用。"></a>1、掌握全连接网络（MLP）的定义与算法原理、并能够应用。</h1><p>全连接网络，是指前一层的每个神经元会都与下一层的全部神经元连接。</p>
<h1 id="2、掌握卷积神经网络（CNN）基本概念，了解几种经典的卷积神经网络，-如-AlexNet、VGG、GoogLeNet、ResNet。"><a href="#2、掌握卷积神经网络（CNN）基本概念，了解几种经典的卷积神经网络，-如-AlexNet、VGG、GoogLeNet、ResNet。" class="headerlink" title="2、掌握卷积神经网络（CNN）基本概念，了解几种经典的卷积神经网络， 如 AlexNet、VGG、GoogLeNet、ResNet。"></a>2、掌握卷积神经网络（CNN）基本概念，了解几种经典的卷积神经网络， 如 AlexNet、VGG、GoogLeNet、ResNet。</h1><p>卷积神经网络（Convolutional Neural Networks, CNN）是一类包含卷积计算且具有深度结构的前馈神经网络（Feedforward Neural Networks），是深度学习（deep learning）的代表算法之一。卷积神经网络具有表征学习（representation learning）能力，能够按其阶层结构对输入信息进行平移不变分类（shift-invariant classification），因此也被称为“平移不变人工神经网络（Shift-Invariant Artificial Neural Networks, SIANN）”。</p>
<p>AlexNet是2012年ILSVRC图像分类和物体识别算法的优胜者，也是LetNet-5之后受到人工智能领域关注的现代卷积神经网络算法。AlexNet的隐含层由5个卷积层、3个池化层和3个全连接层组成。</p>
<p>VGGNet是牛津大学视觉几何团队（Visual Geometry Group, VGG）开发的一组卷积神经网络算法，包括VGG-11、VGG-11-LRN、VGG-13、VGG-16和VGG-19。其中VGG-16是2014年ILSVRC物体识别算法的优胜者，其规模是AlexNet的2倍以上并拥有规律的结构，这里以VGG-16为例介绍其构筑。VGG-16的隐含层由13个卷积层、3个全连接层和5个池化层组成。</p>
<p>GoogLeNet是2014年ILSVRC图像分类算法的优胜者，是首个以Inception模块进行堆叠形成的大规模卷积神经网络。GoogLeNet共有四个版本：Inception v1、Inception v2、Inception v3、Inception v4。</p>
<p>ResNet来自微软的人工智能团队Microsoft Research，是2015年ILSVRC图像分类和物体识别算法的优胜者，其表现超过了GoogLeNet的第三代版本Inception v3。ResNet是使用残差块建立的大规模卷积神经网络，其规模是AlexNet的20倍、VGG-16的8倍，在ResNet的原始版本中，其残差块由2个卷积层、1个跳跃连接、BN和激励函数组成，ResNet的隐含层共包含16个残差块。</p>
<h1 id="3、掌握循环神经网络（RNN）原理与基本概念，了解几种常见的模型，如-长短期记忆网络-LSTM、GRU。"><a href="#3、掌握循环神经网络（RNN）原理与基本概念，了解几种常见的模型，如-长短期记忆网络-LSTM、GRU。" class="headerlink" title="3、掌握循环神经网络（RNN）原理与基本概念，了解几种常见的模型，如 长短期记忆网络 LSTM、GRU。"></a>3、掌握循环神经网络（RNN）原理与基本概念，了解几种常见的模型，如 长短期记忆网络 LSTM、GRU。</h1><p>循环神经网络（Recurrent Neural Network, RNN）是一类以序列（sequence）数据为输入，在序列的演进方向进行递归（recursion）且所有节点（循环单元）按链式连接的递归神经网络（recursive neural network）。</p>
<p>对循环神经网络的研究始于二十世纪80-90年代，并在二十一世纪初发展为深度学习（deep learning）算法之一，其中双向循环神经网络（Bidirectional RNN, Bi-RNN）和长短期记忆网络（Long Short-Term Memory networks，LSTM）是常见的循环神经网络。</p>
<p>循环神经网络具有记忆性、参数共享并且图灵完备（Turing completeness），因此在对序列的非线性特征进行学习时具有一定优势。循环神经网络在自然语言处理（Natural Language Processing, NLP），例如语音识别、语言建模、机器翻译等领域有应用，也被用于各类时间序列预报。引入了卷积神经网络（Convolutional Neural Network,CNN）构筑的循环神经网络可以处理包含序列输入的计算机视觉问题。</p>
<p>LSTM是最早被提出的RNN门控算法，其对应的循环单元，LSTM单元包含3个门控：输入门、遗忘门和输出门。相对于RNN对系统状态建立的递归计算，3个门控对LSTM单元的内部状态建立了自循环（self-loop）。具体地，输入门决定当前时间步的输入和前一个时间步的系统状态对内部状态的更新；遗忘门决定前一个时间步内部状态对当前时间步内部状态的更新；输出门决定内部状态对系统状态的更新。</p>
<p>由于LSTM中3个门控对提升其学习能力的贡献不同，因此略去贡献小的门控和其对应的权重，可以简化神经网络结构并提升其学习效率。GRU即是根据以上观念提出的算法，其对应的循环单元仅包含2个门控：更新门和复位门，其中复位门的功能与LSTM单元的输入门相近，更新门则同时实现了遗忘门和输出门的功能。</p>
<h1 id="4、掌握生成对抗网络（GAN、WGAN）的基本定义与原理，能够完成基本-应用"><a href="#4、掌握生成对抗网络（GAN、WGAN）的基本定义与原理，能够完成基本-应用" class="headerlink" title="4、掌握生成对抗网络（GAN、WGAN）的基本定义与原理，能够完成基本 应用"></a>4、掌握生成对抗网络（GAN、WGAN）的基本定义与原理，能够完成基本 应用</h1><p>生成式对抗网络（GAN, Generative Adversarial Networks ）是一种深度学习模型，是近年来复杂分布上无监督学习最具前景的方法之一。模型通过框架中（至少）两个模块：生成模型（Generative Model）和判别模型（Discriminative Model）的互相博弈学习产生相当好的输出。原始 GAN 理论中，并不要求 G 和 D 都是神经网络，只需要是能拟合相应生成和判别的函数即可。但实用中一般均使用深度神经网络作为 G 和 D 。一个优秀的GAN应用需要有良好的训练方法，否则可能由于神经网络模型的自由性而导致输出不理想。</p>
<p>WGAN：<br>1、彻底解决GAN训练不稳定的问题，不再需要小心平衡生成器和判别器的训练程度<br>2、基本解决了collapse mode的问题，确保了生成样本的多样性<br>3、训练过程中终于有一个像交叉熵、准确率这样的数值来指示训练的进程，这个数值越小代表GAN训练得越好，代表生成器产生的图像质量越高<br>4、以上一切好处不需要精心设计的网络架构，最简单的多层全连接网络就可以做到</p>
<h1 id="5、掌握马尔可夫决策过程的定义，了解其算法应用范围，并能够实际应用"><a href="#5、掌握马尔可夫决策过程的定义，了解其算法应用范围，并能够实际应用" class="headerlink" title="5、掌握马尔可夫决策过程的定义，了解其算法应用范围，并能够实际应用"></a>5、掌握马尔可夫决策过程的定义，了解其算法应用范围，并能够实际应用</h1><p>马尔可夫决策过程（Markov Decision Process, MDP）是序贯决策（sequential decision）的数学模型，用于在系统状态具有马尔可夫性质的环境中模拟智能体可实现的随机性策略与回报。MDP的得名来自于俄国数学家安德雷·马尔可夫（Андрей Андреевич Марков），以纪念其为马尔可夫链所做的研究。</p>
<p>MDP基于一组交互对象，即智能体和环境进行构建，所具有的要素包括状态、动作、策略和奖励。在MDP的模拟中，智能体会感知当前的系统状态，按策略对环境实施动作，从而改变环境的状态并得到奖励，奖励随时间的积累被称为回报。</p>
<p>MDP的理论基础是马尔可夫链，因此也被视为考虑了动作的马尔可夫模型。在离散时间上建立的MDP被称为“离散时间马尔可夫决策过程（descrete-time MDP）”，反之则被称为“连续时间马尔可夫决策过程（continuous-time MDP）”。此外MDP存在一些变体，包括部分可观察马尔可夫决策过程、约束马尔可夫决策过程和模糊马尔可夫决策过程。</p>
<p>在应用方面，MDP被用于机器学习中强化学习（reinforcement learning）问题的建模。通过使用动态规划、随机采样等方法，MDP可以求解使回报最大化的智能体策略，并在自动控制、推荐系统等主题中得到应用。</p>
<h1 id="6、掌握经典强化学习算法（Q-learning、SARMA）的定义与原理。"><a href="#6、掌握经典强化学习算法（Q-learning、SARMA）的定义与原理。" class="headerlink" title="6、掌握经典强化学习算法（Q-learning、SARMA）的定义与原理。"></a>6、掌握经典强化学习算法（Q-learning、SARMA）的定义与原理。</h1><p>强化学习的概念，通俗的讲，强化学习就是通过agent，也就是动作的发起者，对环境造成一个影响，环境接受该动作后状态发生变化，同时产生一个强化信号(奖或惩)反馈给Agent，Agent根据强化信号和环境当前状态再选择下一个动作，选择的原则是使受到正强化(奖)的概率增大。选择的动作不仅影响立即强化值，而且影响环境下一时刻的状态及最终的强化值。在强化学习中，包含两种基本的元素：状态与动作，在某个状态下执行某种动作，这便是一种策略，学习器要做的就是通过不断地探索学习，从而获得一个好的策略。</p>
<p>Q-Learning属于强化学习的经典算法，用于解决马尔可夫决策问题。为无监督学习。</p>
<h1 id="7、掌握经典深度强化学习算法（DQN、DDPG、A3C、TRPO、PPO）的定义-与原理，了解其算法特性。"><a href="#7、掌握经典深度强化学习算法（DQN、DDPG、A3C、TRPO、PPO）的定义-与原理，了解其算法特性。" class="headerlink" title="7、掌握经典深度强化学习算法（DQN、DDPG、A3C、TRPO、PPO）的定义 与原理，了解其算法特性。"></a>7、掌握经典深度强化学习算法（DQN、DDPG、A3C、TRPO、PPO）的定义 与原理，了解其算法特性。</h1><p>DeepMind在2013年提出的DQN算法（2015年提出了DQN的改进版本）可以说是深度学习和强化学习的第一次成功结合。要想将深度学习融合进强化学习，是有一些很关键的问题需要解决的，其中的两个问题如下：<br>1、深度学习需要大量有标签的数据样本；而强化学习是智能体主动获取样本，样本量稀疏且有延迟。<br>2、深度学习要求每个样本相互之间是独立同分布的；而强化学习获取的相邻样本相互关联，并不是相互独立的。</p>
<p>DQN是一种基于值函数的方法，基于值函数的方法难以应对的是大的动作空间，特别是连续动作情况。因为网络难以有这么多输出，且难以在这么多输出之中搜索最大的Q值。而DDPG是基于上面所讲到的Actor-Critic方法，在动作输出方面采用一个网络来拟合策略函数，直接输出动作，可以应对连续动作的输出及大的动作空间。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%80%83%E8%AF%95/%E4%B9%9D%E3%80%81%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6(%E4%BA%8C)%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="xuhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="循序渐进">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%80%83%E8%AF%95/%E4%B9%9D%E3%80%81%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6(%E4%BA%8C)%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/" class="post-title-link" itemprop="url">数据科学（二）统计学习与数据挖掘</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-18 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-18T00:00:00+08:00">2021-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-09 10:07:43" itemprop="dateModified" datetime="2021-11-09T10:07:43+08:00">2021-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%BA%94%E7%94%A8-%E4%B8%AD%E7%BA%A7/" itemprop="url" rel="index"><span itemprop="name">大数据分析应用-中级</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1、掌握感知机的定义和基本原理。"><a href="#1、掌握感知机的定义和基本原理。" class="headerlink" title="1、掌握感知机的定义和基本原理。"></a>1、掌握感知机的定义和基本原理。</h1><p>感知机是二分类的线性模型，其输入是实例的特征向量，输出的是事例的类别，分别是+1和-1，属于判别模型。</p>
<p>假设训练数据集是线性可分的，感知机学习的目标是求得一个能够将训练数据集正实例点和负实例点完全正确分开的分离超平面。如果是非线性可分的数据，则最后无法获得超平面。感知机由Rosenblatt于1957年提出的，是神经网络和支持向量机的基础。</p>
<p><img src="/images/bigdata/4-9.png"></p>
<h1 id="2、掌握-Logistic-回归算法原理与特点，能够使用-Logistic-回归进行数据的分类建模与参数解释。"><a href="#2、掌握-Logistic-回归算法原理与特点，能够使用-Logistic-回归进行数据的分类建模与参数解释。" class="headerlink" title="2、掌握 Logistic 回归算法原理与特点，能够使用 Logistic 回归进行数据的分类建模与参数解释。"></a>2、掌握 Logistic 回归算法原理与特点，能够使用 Logistic 回归进行数据的分类建模与参数解释。</h1><p>Logistic回归虽然说是回归，但确是为了解决分类问题，是二分类任务的首选方法，简单来说，输出结果不是0就是1。</p>
<p>逻辑回归（Logistic Regression）与线性回归（Linear Regression）都是一种广义线性模型（generalized linear model）。</p>
<p>逻辑回归假设因变量 y 服从二项分布，而线性回归假设因变量 y 服从高斯分布。</p>
<p>因此与线性回归有很多相同之处，去除Sigmoid映射函数的话，逻辑回归算法就是一个线性回归。</p>
<p>可以说，逻辑回归是以线性回归为理论支持的，但是逻辑回归通过Sigmoid函数引入了非线性因素，因此可以轻松处理0/1分类问题。</p>
<h1 id="3、掌握朴素贝叶斯算法的定义与基本原理。"><a href="#3、掌握朴素贝叶斯算法的定义与基本原理。" class="headerlink" title="3、掌握朴素贝叶斯算法的定义与基本原理。"></a>3、掌握朴素贝叶斯算法的定义与基本原理。</h1><p>贝叶斯方法是以贝叶斯原理为基础，使用概率统计的知识对样本数据集进行分类。由于其有着坚实的数学基础，贝叶斯分类算法的误判率是很低的。贝叶斯方法的特点是结合先验概率和后验概率，即避免了只使用先验概率的主观偏见，也避免了单独使用样本信息的过拟合现象。贝叶斯分类算法在数据集较大的情况下表现出较高的准确率，同时算法本身也比较简单。</p>
<p>朴素贝叶斯分类（NBC）是以贝叶斯定理为基础并且假设特征条件之间相互独立的方法，先通过已给定的训练集，以特征词之间独立作为前提假设，学习从输入到输出的联合概率分布，再基于学习到的模型，输入 求出使得后验概率最大的输出 。</p>
<p><img src="/images/bigdata/4-10.png"></p>
<h1 id="4、掌握-k-近邻算法算法定义与原理。"><a href="#4、掌握-k-近邻算法算法定义与原理。" class="headerlink" title="4、掌握 k 近邻算法算法定义与原理。"></a>4、掌握 k 近邻算法算法定义与原理。</h1><p>给定测试样本，基于某种距离度量找出训练集中与其最靠近的k个训练样本，然后基于这k个”邻居”的信息来进行预测。<br>通俗点说：就是计算一个点与样本空间所有点之间的距离，取出与该点最近的k个点，然后统计这k个点里面所属分类比例最大的（“回归”里面使用平均法），则点A属于该分类。</p>
<p>1、算距离： 给定测试对象，计算它与训练集中的每个对象的距离；<br>2、找邻居：圈定距离最近的k个训练对象，作为测试对象的近邻；<br>3、做分类：根据这k个近邻归属的主要类别，来对测试对象分类；</p>
<p>欧氏距离、曼哈顿距离</p>
<h1 id="5、掌握支持向量机（SVM）算法的思想与原理。"><a href="#5、掌握支持向量机（SVM）算法的思想与原理。" class="headerlink" title="5、掌握支持向量机（SVM）算法的思想与原理。"></a>5、掌握支持向量机（SVM）算法的思想与原理。</h1><p>支持向量机（Support Vector Machine, SVM）是一类按监督学习（supervised learning）方式对数据进行二元分类的广义线性分类器（generalized linear classifier），其决策边界是对学习样本求解的最大边距超平面（maximum-margin hyperplane）。</p>
<p>SVM使用铰链损失函数（hinge loss）计算经验风险（empirical risk）并在求解系统中加入了正则化项以优化结构风险（structural risk），是一个具有稀疏性和稳健性的分类器。SVM可以通过核方法（kernel method）进行非线性分类，是常见的核学习（kernel learning）方法之一。</p>
<p>SVM被提出于1964年，在二十世纪90年代后得到快速发展并衍生出一系列改进和扩展算法，在人像识别、文本分类等模式识别（pattern recognition）问题中有得到应用。</p>
<h1 id="6、掌握决策树的算法的定义与原理，了解决策树的剪枝理论。"><a href="#6、掌握决策树的算法的定义与原理，了解决策树的剪枝理论。" class="headerlink" title="6、掌握决策树的算法的定义与原理，了解决策树的剪枝理论。"></a>6、掌握决策树的算法的定义与原理，了解决策树的剪枝理论。</h1><p>决策树(Decision Tree）是在已知各种情况发生概率的基础上，通过构成决策树来求取净现值的期望值大于等于零的概率，评价项目风险，判断其可行性的决策分析方法，是直观运用概率分析的一种图解法。由于这种决策分支画成图形很像一棵树的枝干，故称决策树。在机器学习中，决策树是一个预测模型，他代表的是对象属性与对象值之间的一种映射关系。</p>
<p>决策树是一种树形结构，其中每个内部节点表示一个属性上的测试，每个分支代表一个测试输出，每个叶节点代表一种类别。</p>
<p>分类树（决策树）是一种十分常用的分类方法。它是一种监督学习，所谓监督学习就是给定一堆样本，每个样本都有一组属性和一个类别，这些类别是事先确定的，那么通过学习得到一个分类器，这个分类器能够对新出现的对象给出正确的分类。这样的机器学习就被称之为监督学习。</p>
<p>剪枝是决策树停止分支的方法之一，剪枝有分预先剪枝和后剪枝两种。预先剪枝是在树的生长过程中设定一个指标，当达到该指标时就停止生长，这样做容易产生“视界局限”，就是一旦停止分支，使得节点N成为叶节点，就断绝了其后继节点进行“好”的分支操作的任何可能性。不严格的说这些已停止的分支会误导学习算法，导致产生的树不纯度降差最大的地方过分靠近根节点。后剪枝中树首先要充分生长，直到叶节点都有最小的不纯度值为止，因而可以克服“视界局限”。然后对所有相邻的成对叶节点考虑是否消去它们，如果消去能引起令人满意的不纯度增长，那么执行消去，并令它们的公共父节点成为新的叶节点。这种“合并”叶节点的做法和节点分支的过程恰好相反，经过剪枝后叶节点常常会分布在很宽的层次上，树也变得非平衡。后剪枝技术的优点是克服了“视界局限”效应，而且无需保留部分样本用于交叉验证，所以可以充分利用全部训练集的信息。但后剪枝的计算量代价比预剪枝方法大得多，特别是在大样本集中，不过对于小样本的情况，后剪枝方法还是优于预剪枝方法的。</p>
<h1 id="7、了解常见集成方法如-boosting、bagging-等。"><a href="#7、了解常见集成方法如-boosting、bagging-等。" class="headerlink" title="7、了解常见集成方法如 boosting、bagging 等。"></a>7、了解常见集成方法如 boosting、bagging 等。</h1><h2 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging:"></a>Bagging:</h2><p>Bagging即套袋法，其算法过程如下：<br>1、从原始样本集中抽取训练集。每轮从原始样本集中使用Bootstraping的方法抽取n个训练样本（在训练集中，有些样本可能被多次抽取到，而有些样本可能一次都没有被抽中）。共进行k轮抽取，得到k个训练集。（k个训练集之间是相互独立的）<br>2、每次使用一个训练集得到一个模型，k个训练集共得到k个模型。（注：这里并没有具体的分类算法或回归方法，我们可以根据具体问题采用不同的分类或回归方法，如决策树、感知器等）<br>3、对分类问题：将上步得到的k个模型采用投票的方式得到分类结果；对回归问题，计算上述模型的均值作为最后的结果。（所有模型的重要性相同）</p>
<p>Boosting：<br>Boosting方式每次使用的是全部的样本，每轮训练改变样本的权重。下一轮训练的目标是找到一个函数f 来拟合上一轮的残差。当残差足够小或者达到设置的最大迭代次数则停止。Boosting会减小在上一轮训练正确的样本的权重，增大错误样本的权重。（对的残差小，错的残差大）<br>梯度提升的Boosting方式是使用代价函数对上一轮训练出的模型函数f的偏导来拟合残差。</p>
<h1 id="8、掌握聚类分析的相关概念。"><a href="#8、掌握聚类分析的相关概念。" class="headerlink" title="8、掌握聚类分析的相关概念。"></a>8、掌握聚类分析的相关概念。</h1><p>聚类分析指将物理或抽象对象的集合分组为由类似的对象组成的多个类的分析过程。它是一种重要的人类行为。</p>
<p>聚类分析的目标就是在相似的基础上收集数据来分类。聚类源于很多领域，包括数学，计算机科学，统计学，生物学和经济学。在不同的应用领域，很多聚类技术都得到了发展，这些技术方法被用作描述数据，衡量不同数据源间的相似性，以及把数据源分类到不同的簇中。</p>
<h1 id="9、掌握主成分分析的原理。"><a href="#9、掌握主成分分析的原理。" class="headerlink" title="9、掌握主成分分析的原理。"></a>9、掌握主成分分析的原理。</h1><p>主成分分析（Principal Component Analysis，PCA）， 是一种统计方法。通过正交变换将一组可能存在相关性的变量转换为一组线性不相关的变量，转换后的这组变量叫主成分。</p>
<p>在实际课题中，为了全面分析问题，往往提出很多与此有关的变量（或因素），因为每个变量都在不同程度上反映这个课题的某些信息。</p>
<p>主成分分析首先是由K.皮尔森（Karl Pearson）对非随机变量引入的，尔后H.霍特林将此方法推广到随机向量的情形。信息的大小通常用离差平方和或方差来衡量。</p>
<p>在用统计分析方法研究多变量的课题时，变量个数太多就会增加课题的复杂性。人们自然希望变量个数较少而得到的信息较多。在很多情形，变量之间是有一定的相关关系的，当两个变量之间有一定相关关系时，可以解释为这两个变量反映此课题的信息有一定的重叠。主成分分析是对于原先提出的所有变量，将重复的变量（关系紧密的变量）删去多余，建立尽可能少的新变量，使得这些新变量是两两不相关的，而且这些新变量在反映课题的信息方面尽可能保持原有的信息。</p>
<p>设法将原来变量重新组合成一组新的互相无关的几个综合变量，同时根据实际需要从中可以取出几个较少的综合变量尽可能多地反映原来变量的信息的统计方法叫做主成分分析或称主分量分析，也是数学上用来降维的一种方法。</p>
<h1 id="10、了解生成式半监督学习方法、半监督-SVM、图半监督学习方法的思想与原理。"><a href="#10、了解生成式半监督学习方法、半监督-SVM、图半监督学习方法的思想与原理。" class="headerlink" title="10、了解生成式半监督学习方法、半监督 SVM、图半监督学习方法的思想与原理。"></a>10、了解生成式半监督学习方法、半监督 SVM、图半监督学习方法的思想与原理。</h1><p>半监督学习(Semi-Supervised Learning，SSL)是模式识别和机器学习领域研究的重点问题，是监督学习与无监督学习相结合的一种学习方法。半监督学习使用大量的未标记数据，以及同时使用标记数据，来进行模式识别工作。当使用半监督学习时，将会要求尽量少的人员来从事工作，同时，又能够带来比较高的准确性，因此，半监督学习正越来越受到人们的重视。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%80%83%E8%AF%95/%E5%85%AB%E3%80%81%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="xuhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="循序渐进">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%80%83%E8%AF%95/%E5%85%AB%E3%80%81%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">大数据分析模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-18 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-18T00:00:00+08:00">2021-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-09 10:07:43" itemprop="dateModified" datetime="2021-11-09T10:07:43+08:00">2021-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%BA%94%E7%94%A8-%E4%B8%AD%E7%BA%A7/" itemprop="url" rel="index"><span itemprop="name">大数据分析应用-中级</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1、了解常用的大数据分析模型，例如行为事件分析模型、点击分析模型、用户行为路径分析模型、用户分群分析模型等，具有应用大数据技术进行大数据分析能力"><a href="#1、了解常用的大数据分析模型，例如行为事件分析模型、点击分析模型、用户行为路径分析模型、用户分群分析模型等，具有应用大数据技术进行大数据分析能力" class="headerlink" title="1、了解常用的大数据分析模型，例如行为事件分析模型、点击分析模型、用户行为路径分析模型、用户分群分析模型等，具有应用大数据技术进行大数据分析能力"></a>1、了解常用的大数据分析模型，例如行为事件分析模型、点击分析模型、用户行为路径分析模型、用户分群分析模型等，具有应用大数据技术进行大数据分析能力</h1><h2 id="行为事件分析模型"><a href="#行为事件分析模型" class="headerlink" title="行为事件分析模型"></a>行为事件分析模型</h2><p>行为事件分析法来研究某行为事件的发生对企业组织价值的影响以及影响程度。企业借此来追踪或记录的用户行为或业务过程，如用户注册、浏览产品详情页、成功投资、提现等，通过研究与事件发生关联的所有因素来挖掘用户行为事件背后的原因、交互影响等。<br>在日常工作中，运营、市场、产品、数据分析师根据实际工作情况而关注不同的事件指标。如最近三个月来自哪个渠道的用户注册量最高？变化趋势如何？各时段的人均充值金额是分别多少？上周来自北京发生过购买行为的独立用户数，按照年龄段的分布情况？每天的独立 Session 数是多少？诸如此类的指标查看的过程中，行为事件分析起到重要作用。</p>
<p>行为事件分析法具有强大的筛选、分组和聚合能力，逻辑清晰且使用简单，已被广泛应用。行为事件分析法一般经过事件定义与选择、下钻分析、解释与结论等环节。</p>
<h3 id="事件定义与选择。"><a href="#事件定义与选择。" class="headerlink" title="事件定义与选择。"></a>事件定义与选择。</h3><p>事件描述的是，一个用户在某个时间点、某个地方、以某种方式完成了某个具体的事情。Who、When、Where、What、How是定义一个事件的关键因素。其中：<br>Who 是参与事件的主体，对于未登陆用户，可以是 Cookie、设备ID 等匿名 ID ；对于登录用户，可以使用后台配置的实际用户ID；<br>When 是事件发生的实际时间，应该记录精确到毫秒的事件发生时间；<br>Where 即事件发生的地点，可以通过IP来解析用户所在省市；也可以根据 GPS 定位方式获取地理位置信息。<br>How 即用户从事这个事件的方式。用户使用的设备、浏览器、 App 版本、渠道来源等等；<br>What 描述用户所做的这个事件的所有具体内容。比如对于“购买”类型的事件，则可能需要记录的字段有：商品名称、商品类型、购买数量、购买金额、付款方式等。</p>
<h3 id="多维度下钻分析。"><a href="#多维度下钻分析。" class="headerlink" title="多维度下钻分析。"></a>多维度下钻分析。</h3><p>最为高效的行为事件分析要支持任意下钻分析和精细化条件筛选。当行为事件分析合理配置追踪事件和属性，可以激发出事件分析的强大潜能，为企业回答关于变化趋势、维度对比等等各种细分问题。同时，还可以通过添加筛选条件，可以精细化查看符合某些具体条件的事件数据。</p>
<h3 id="解释与结论。"><a href="#解释与结论。" class="headerlink" title="解释与结论。"></a>解释与结论。</h3><p>此环节要对分析结果进行合理的理论解释，判断数据分析结果是否与预期相符，如判断产品的细节优化是否提升了触发用户数。如果相悖，则应该针对不足的部分进行再分析与实证。</p>
<h2 id="用户分群分析模型"><a href="#用户分群分析模型" class="headerlink" title="用户分群分析模型"></a>用户分群分析模型</h2><p>用户分群数据分析方法是进行用户画像的关键数据分析模型，这是企业进行数据分析、精细化运营的第一步。用户分群即用户信息标签化，通过用户的历史行为路径、行为特征、偏好等属性，将具有相同属性的用户划分为一个群体，并进行后续分析。</p>
<h3 id="漏斗分析关注阶段差异，用户分群关注群体差异"><a href="#漏斗分析关注阶段差异，用户分群关注群体差异" class="headerlink" title="漏斗分析关注阶段差异，用户分群关注群体差异"></a>漏斗分析关注阶段差异，用户分群关注群体差异</h3><p>通过漏斗分析模型，运营人员可以看到，用户在不同阶段所表现出的行为是不同的，譬如新用户的关注点在哪里？已购用户什么情况下会再次付费？然而，由于群体特征不同，行为会有很大差别，因此运营人员或者产品人员希望可以根据历史数据将用户进行划分，将具有一定规律特性的用户群体进行归类，进而再次观察该群体的具体行为。这就是用户分群的原理。</p>
<h3 id="普通用户分群与预测分群"><a href="#普通用户分群与预测分群" class="headerlink" title="普通用户分群与预测分群"></a>普通用户分群与预测分群</h3><p>严格说来，用户分群分为普通分群和预测分群。普通分群是依据用户的属性特征和行为特征将用户群体进行分类；预测分群是根据用户以往的行为属性特征，运用机器学习算法来预测他们将来会发生某些事件的概率。</p>
<h2 id="点击分析模型"><a href="#点击分析模型" class="headerlink" title="点击分析模型"></a>点击分析模型</h2><p>点击分析模型在各行业内数据分析应用较为广泛，是重要的数据分析模型之一。<br>点击图是点击分析方法的效果呈现，在用户行为分析领域，点击分析被应用于显示页面或页面组（结构相同的页面，如商品详情页、官网博客等）区域中不同元素点击密度的图示。包括元素被点击的次数、占比、发生点击的用户列表、按钮的当前与历史内容等因素。</p>
<p>点击分析具有分析过程高效、灵活、易用，效果直观的特点。点击分析采用可视化的设计思想与架构，简洁直观的操作方式，直观呈现访客热衷的区域，帮助运营人员或管理者评估网页的设计的科学性。</p>
<p>在追求精细化网站运营的路上，企业对用户点击行为的可视化分析提出了更高需求，理想的点击分析方法主要分析：</p>
<h3 id="1、精准评估用户与网站交互背后的深层关系"><a href="#1、精准评估用户与网站交互背后的深层关系" class="headerlink" title="1、精准评估用户与网站交互背后的深层关系"></a>1、精准评估用户与网站交互背后的深层关系</h3><p>除了展示单个页面或页面组的点击图，前沿的点击分析应该能够支持事件（元素）属性、用户属性的任意维度筛选下钻；运营人员可以按照事件属性和用户属性进行筛选，对特定环境下特定用户群体对特定元素的点击进行精细化分析；支持查看页面元素点击背后的用户列表，满足企业网站的精细化分析需求。</p>
<h3 id="2、实现网页内跳转点击分析，抽丝剥茧般完成网页深层次的点击分析；"><a href="#2、实现网页内跳转点击分析，抽丝剥茧般完成网页深层次的点击分析；" class="headerlink" title="2、实现网页内跳转点击分析，抽丝剥茧般完成网页深层次的点击分析；"></a>2、实现网页内跳转点击分析，抽丝剥茧般完成网页深层次的点击分析；</h3><p>前沿的点击分析应支持网页内点击跳转分析——在浏览页面点击图时，使用者能够像访问者一样，点击页面元素，即可跳转至新的分析页面，且新的分析页面自动延续上一页面的筛选条件。同一筛选条件下，运营人员可抽丝剥茧般完成网页深层次的点击分析，操作流畅，分析流程简易、高效。</p>
<h3 id="3、与其他分析模型配合，以全面视角探索数据价值，能够深度感知用户体验，实现科学决策。"><a href="#3、与其他分析模型配合，以全面视角探索数据价值，能够深度感知用户体验，实现科学决策。" class="headerlink" title="3、与其他分析模型配合，以全面视角探索数据价值，能够深度感知用户体验，实现科学决策。"></a>3、与其他分析模型配合，以全面视角探索数据价值，能够深度感知用户体验，实现科学决策。</h3><p>无法精细化地深入分析，会让网页设计与优化丧失了科学性。点击图呈现用户喜爱点击的模块或聚焦的内容，是数据价值最上层表现。当“点击分析”与其他分析模块配合，交叉使用，将数据和分析结果以多种形式可视化展现，运营人员即可深度感知用户体验。例如，改版后，如何评估新版本对用户体验的影响？一处修改，是否影响其他元素的点击……等等。再如 A/B 测试，反复验证优化效果选择最优方案等。</p>
<h2 id="用户行为路径分析模型"><a href="#用户行为路径分析模型" class="headerlink" title="用户行为路径分析模型"></a>用户行为路径分析模型</h2><h3 id="什么是用户行为路径？"><a href="#什么是用户行为路径？" class="headerlink" title="什么是用户行为路径？"></a>什么是用户行为路径？</h3><p>用户路径分析，顾名思义，用户在APP或网站中的访问行为路径。为了衡量网站优化的效果或营销推广的效果，以及了解用户行为偏好，时常要对访问路径的转换数据进行分析。</p>
<p>以电商为例，买家从登录网站／APP到支付成功要经过首页浏览、搜索商品、加入购物车、提交订单、支付订单等过程。而在用户真实的选购过程是一个交缠反复的过程，例如提交订单后，用户可能会返回首页继续搜索商品，也可能去取消订单，每一个路径背后都有不同的动机。与其他分析模型配合进行深入分析后，能为找到快速用户动机，从而引领用户走向最优路径或者期望中的路径。</p>
<h3 id="用户路径分析模型的价值"><a href="#用户路径分析模型的价值" class="headerlink" title="用户路径分析模型的价值"></a>用户路径分析模型的价值</h3><p>用户路径的分析结果通常以桑基图形式展现，以目标事件为起点／终点，详细查看后续／前置路径，可以详细查看某个节点事件的流向，总的来说，科学的用户路径分析能够带来以下价值：</p>
<p>第一，可视化用户流，全面了解用户整体行为路径；</p>
<p>通过用户路径分析，可以将一个事件的上下游进行可视化展示。用户即可查看当前节点事件的相关信息，包括事件名、分组属性值、后续事件统计、流失、后续事件列表等。运营人员可通过用户整体行为路径找到不同行为间的关系，挖掘规律并找到瓶颈。</p>
<p>第二，定位影响转化的主次因素，产品设计的优化与改进有的放矢。</p>
<p>路径分析对产品设计的优化与改进有着很大的帮助，了解用户从登录到购买整体行为的主路径和次路径，根据用户路径中各个环节的转化率，发现用户的行为规律和偏好，也可以用于监测和定位用户路径走向中存在的问题，判断影响转化的主要因素和次要因素，也可以发现某些冷僻的功能点。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%80%83%E8%AF%95/%E4%B8%83%E3%80%81%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="xuhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="循序渐进">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%80%83%E8%AF%95/%E4%B8%83%E3%80%81%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">大数据技术与应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-18 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-18T00:00:00+08:00">2021-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-09 10:07:43" itemprop="dateModified" datetime="2021-11-09T10:07:43+08:00">2021-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%BA%94%E7%94%A8-%E4%B8%AD%E7%BA%A7/" itemprop="url" rel="index"><span itemprop="name">大数据分析应用-中级</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="（一）数据可视化"><a href="#（一）数据可视化" class="headerlink" title="（一）数据可视化"></a>（一）数据可视化</h1><h2 id="1、了解常见可视化图形（散点图、折线图、饼图、环图、双层环图、柱状图、堆积柱状图、分组柱状图、正负条形图、雷达图）的概念，具有初步的可视化图形展示数据的能力。"><a href="#1、了解常见可视化图形（散点图、折线图、饼图、环图、双层环图、柱状图、堆积柱状图、分组柱状图、正负条形图、雷达图）的概念，具有初步的可视化图形展示数据的能力。" class="headerlink" title="1、了解常见可视化图形（散点图、折线图、饼图、环图、双层环图、柱状图、堆积柱状图、分组柱状图、正负条形图、雷达图）的概念，具有初步的可视化图形展示数据的能力。"></a>1、了解常见可视化图形（散点图、折线图、饼图、环图、双层环图、柱状图、堆积柱状图、分组柱状图、正负条形图、雷达图）的概念，具有初步的可视化图形展示数据的能力。</h2><h2 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h2><p>散点图是指在回归分析中，数据点在直角坐标系平面上的分布图，散点图表示因变量随自变量而变化的大致趋势，据此可以选择合适的函数对数据点进行拟合。<br>用两组数据构成多个坐标点，考察坐标点的分布，判断两变量之间是否存在某种关联或总结坐标点的分布模式。散点图将序列显示为一组点。值由点在图表中的位置表示。类别由图表中的不同标记表示。散点图通常用于比较跨类别的聚合数据。</p>
<h2 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h2><p>折线图是排列在工作表的列或行中的数据可以绘制到折线图中。折线图可以显示随时间（根据常用比例设置）而变化的连续数据，因此非常适用于显示在相等时间间隔下数据的趋势。<br>在折线图中，类别数据沿水平轴均匀分布，所有值数据沿垂直轴均匀分布。</p>
<h2 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h2><p>饼图常用于统计学模块。<br>仅排列在工作表的一列或一行中的数据可以绘制到饼图中。饼图显示一个数据系列中各项的大小与各项总和的比例。饼图中的数据点显示为整个饼图的百分比。</p>
<p>数据系列：在图表中绘制的相关数据点，这些数据源自数据表的行或列。图表中的每个数据系列具有唯一的颜色或图案并且在图表的图例中表示。可以在图表中绘制一个或多个数据系列。饼图只有一个数据系列。</p>
<p>数据点：在图表中绘制的单个值，这些值由条形、柱形、折线、饼图或圆环图的扇面、圆点和其他被称为数据标记的图形表示。相同颜色的数据标记组成一个数据系列。</p>
<h2 id="环图"><a href="#环图" class="headerlink" title="环图"></a>环图</h2><h2 id="双层环图"><a href="#双层环图" class="headerlink" title="双层环图"></a>双层环图</h2><h2 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h2><p>柱形图，又称长条图、柱状统计图，亦称条图、条状图、棒形图，是一种以长方形的长度为变量的统计图表。长条图用来比较两个或以上的价值（不同时间或者不同条件），只有一个变量，通常利用于较小的数据集分析。长条图亦可横向排列，或用多维方式表达。</p>
<h2 id="堆积柱状图"><a href="#堆积柱状图" class="headerlink" title="堆积柱状图"></a>堆积柱状图</h2><h2 id="分组柱状图"><a href="#分组柱状图" class="headerlink" title="分组柱状图"></a>分组柱状图</h2><h2 id="正负条形图"><a href="#正负条形图" class="headerlink" title="正负条形图"></a>正负条形图</h2><h2 id="雷达图"><a href="#雷达图" class="headerlink" title="雷达图"></a>雷达图</h2><p>雷达图是以从同一点开始的轴上表示的三个或更多个定量变量的二维图表的形式显示多变量数据的图形方法。轴的相对位置和角度通常是无信息的。 雷达图也称为网络图，蜘蛛图，星图，蜘蛛网图，不规则多边形，极坐标图或Kiviat图。它相当于平行坐标图，轴径向排列。</p>
<h1 id="（二）大数据处理技术"><a href="#（二）大数据处理技术" class="headerlink" title="（二）大数据处理技术"></a>（二）大数据处理技术</h1><h2 id="1、掌握云计算的概念、云计算的特征、云计算的三层-SPI-模型（IaaS、PaaS、-SaaS）。"><a href="#1、掌握云计算的概念、云计算的特征、云计算的三层-SPI-模型（IaaS、PaaS、-SaaS）。" class="headerlink" title="1、掌握云计算的概念、云计算的特征、云计算的三层 SPI 模型（IaaS、PaaS、 SaaS）。"></a>1、掌握云计算的概念、云计算的特征、云计算的三层 SPI 模型（IaaS、PaaS、 SaaS）。</h2><p>参考<a href="/2021/10/14/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%80%83%E8%AF%95/%E4%B8%89%E3%80%81%E4%BF%A1%E6%81%AF%E5%8C%96%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E4%BF%A1%E6%81%AF%E5%8C%96%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E4%B8%89)%E6%96%B0%E4%B8%80%E4%BB%A3%E4%BF%A1%E6%81%AF%E6%8A%80%E6%9C%AF/">[信息化基础知识（三）新一代信息技术]</a>云计算部分。</p>
<h2 id="2、掌握虚拟化技术的概念、常用虚拟化方法，了解常用虚拟化软件。"><a href="#2、掌握虚拟化技术的概念、常用虚拟化方法，了解常用虚拟化软件。" class="headerlink" title="2、掌握虚拟化技术的概念、常用虚拟化方法，了解常用虚拟化软件。"></a>2、掌握虚拟化技术的概念、常用虚拟化方法，了解常用虚拟化软件。</h2><p>虚拟化（Virtualization）技术最早出现在 20 世纪 60 年代的 IBM 大型机系统，在 20 世纪 70 年代的 System370 系列中逐渐流行起来，这些机器通过一种叫虚拟机监控器（Virtual Machine Monitor, VMM）的程序在物理硬件之上生成许多可以运行独立操作系统软件的虚拟机（Virtual Machine）实例。随着近年多核系统、集群、网格甚至云计算的广泛部署，虚拟化技术在商业应用上的优势日益体现，不仅降低了 T 成本，而且还增强了系统安全性和可靠性，虚拟化的概念也逐渐深入到人们日常的工作与生活中。</p>
<p>虚拟化是一个广义的术语，对于不同的人来说可能意味着不同的东西，这要取决他们所处的环境。在计算机科学领域中，虚拟化代表着对计算资源的抽象，而不仅仅局限于虚拟机的概念。例如对物理内存的抽象，产生了虚拟内存技术，使得应用程序认为其自身拥有连续可用的地址空间（Address Space），而实际上，应用程序的代码和数据可能被分隔成多个碎片页或段，甚至被交换到磁盘、闪存等外部存储器上，即使物理内存不足，应用程序也能顺利执行。</p>
<h3 id="（1）全虚拟化"><a href="#（1）全虚拟化" class="headerlink" title="（1）全虚拟化"></a>（1）全虚拟化</h3><p>全虚拟化（Full Virtualization）是指虚拟机模拟了完整的底层硬件，包括处理器、物理 内存、时钟、外设等，使得为原始硬件设计的操作系统或其他系统软件完全不作任何修改就 可以在虚拟机中运行。<br>比较著名的全虚拟化 VMM 有 Microsoft Virtual PC、VMware Workstation、SUN Virtual Box、Parallels Desktop forMac 和 QEMU。</p>
<h3 id="（2）超虚拟化"><a href="#（2）超虚拟化" class="headerlink" title="（2）超虚拟化"></a>（2）超虚拟化</h3><p>超虚拟化（Paravirtualization）是一种修改 Guest OS 部分访问特权状态的代码以便直接 与 VMM 交互的技术。在超虚拟化虚拟机中，部分硬件接口以软件的形式提供给客户机操 作系统，这可以通过 Hypercall（VMM 提供给 Guest OS 的直接调用，与系统调用类似）的 方式来提供。<br>比较著名的 VMM 有 Denali、Xen。</p>
<h3 id="（3）硬件辅助虚拟化"><a href="#（3）硬件辅助虚拟化" class="headerlink" title="（3）硬件辅助虚拟化"></a>（3）硬件辅助虚拟化</h3><p>硬件辅助虚拟化（Hardware-Assisted Virtualization）是指借助硬件（主要是主机处理器） 的支持来实现高效的全虚拟化。<br>Intel-VT 和 AMD-V 是目前 x86 体系结构上可用的两种硬件辅助虚拟化技术。</p>
<h3 id="（4）部分虚拟化"><a href="#（4）部分虚拟化" class="headerlink" title="（4）部分虚拟化"></a>（4）部分虚拟化</h3><p>部分虚拟化（Partial Virtualization）中，VMM 只模拟部分底层硬件，因此客户机操作系 统不作修改是无法在虚拟机中运行的，其他程序可能也需要进行修改。</p>
<h3 id="（5）操作系统级虚拟化"><a href="#（5）操作系统级虚拟化" class="headerlink" title="（5）操作系统级虚拟化"></a>（5）操作系统级虚拟化</h3><p>在传统操作系统中，所有用户的进程本质上是在同一个操作系统的实例中运行，因此内 核或应用程序的缺陷可能影响到其他进程。 操作系统级虚拟化（ Operating System Level Virtualization）是一种在服务器操作系统中使用的轻量级的虚拟化技术，内核通过创建多个 虚拟的操作系统实例（内核和库）来隔离不同的进程，不同实例中的进程完全不了解对方的 存在。<br>比较著名的有 Solaris Container、FreeBSD Jail 和 OpenVZ 等。</p>
<h2 id="3、具有应用虚拟化技术搭建虚拟化平台的能力。"><a href="#3、具有应用虚拟化技术搭建虚拟化平台的能力。" class="headerlink" title="3、具有应用虚拟化技术搭建虚拟化平台的能力。"></a>3、具有应用虚拟化技术搭建虚拟化平台的能力。</h2><h2 id="4、了解分布式计算、高性能计算、边缘计算的概念。"><a href="#4、了解分布式计算、高性能计算、边缘计算的概念。" class="headerlink" title="4、了解分布式计算、高性能计算、边缘计算的概念。"></a>4、了解分布式计算、高性能计算、边缘计算的概念。</h2><h3 id="分布式计算"><a href="#分布式计算" class="headerlink" title="分布式计算"></a>分布式计算</h3><p>分布式计算是一种计算方法，和集中式计算是相对的。<br>随着计算技术的发展，有些应用需要非常巨大的计算能力才能完成，如果采用集中式计算，需要耗费相当长的时间来完成。<br>分布式计算将该应用分解成许多小的部分，分配给多台计算机进行处理。这样可以节约整体计算时间，大大提高计算效率。</p>
<h3 id="高性能计算"><a href="#高性能计算" class="headerlink" title="高性能计算"></a>高性能计算</h3><p>高性能计算(High performance computing， 缩写HPC) 指通常使用很多处理器（作为单个机器的一部分）或者某一集群中组织的几台计算机（作为单个计 算资源操作）的计算系统和环境。有许多类型的HPC 系统，其范围从标准计算机的大型集群，到高度专用的硬件。大多数基于集群的HPC系统使用高性能网络互连，比如那些来自 InfiniBand 或 Myrinet 的网络互连。基本的网络拓扑和组织可以使用一个简单的总线拓扑，在性能很高的环境中，网状网络系统在主机之间提供较短的潜伏期，所以可改善总体网络性能和传输速率。</p>
<h3 id="边缘计算"><a href="#边缘计算" class="headerlink" title="边缘计算"></a>边缘计算</h3><p>边缘计算，是指在靠近物或数据源头的一侧，采用网络、计算、存储、应用核心能力为一体的开放平台，就近提供最近端服务。其应用程序在边缘侧发起，产生更快的网络服务响应，满足行业在实时业务、应用智能、安全与隐私保护等方面的基本需求。边缘计算处于物理实体和工业连接之间，或处于物理实体的顶端。而云端计算，仍然可以访问边缘计算的历史数据。</p>
<h2 id="5-了解有监督学习、无监督学习、强化学习的概念和区别。"><a href="#5-了解有监督学习、无监督学习、强化学习的概念和区别。" class="headerlink" title="5.了解有监督学习、无监督学习、强化学习的概念和区别。"></a>5.了解有监督学习、无监督学习、强化学习的概念和区别。</h2><h3 id="有监督学习"><a href="#有监督学习" class="headerlink" title="有监督学习"></a>有监督学习</h3><p>训练数据由一组训练实例组成。在监督学习中，每一个例子都是一对由一个输入对象（通常是一个向量）和一个期望的输出值（也被称为监督信号）。有监督学习算法分析训练数据，并产生一个推断的功能，它可以用于映射新的例子。一个最佳的方案将允许该算法正确地在标签不可见的情况下确定类标签。<br>用已知某种或某些特性的样本作为训练集，以建立一个数学模型(如模式识别中的判别模型，人工神经网络法中的权重模型等)，再用已建立的模型来预测未知样本，此种方法称为有监督学习。是最常见的机器学习方法。</p>
<h3 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h3><p>现实生活中常常会有这样的问题：缺乏足够的先验知识，因此难以人工标注类别或进行人工类别标注的成本太高。很自然地，我们希望计算机能代我们完成这些工作，或至少提供一些帮助。根据类别未知(没有被标记)的训练样本解决模式识别中的各种问题，称之为无监督学习。</p>
<h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><p>强化学习（Reinforcement Learning, RL），又称再励学习、评价学习或增强学习，是机器学习的范式和方法论之一，用于描述和解决智能体（agent）在与环境的交互过程中通过学习策略以达成回报最大化或实现特定目标的问题。<br>强化学习的常见模型是标准的马尔可夫决策过程（Markov Decision Process, MDP）。按给定条件，强化学习可分为基于模式的强化学习（model-based RL）和无模式强化学习（model-free RL），以及主动强化学习（active RL）和被动强化学习（passive RL）。强化学习的变体包括逆向强化学习、阶层强化学习和部分可观测系统的强化学习。求解强化学习问题所使用的算法可分为策略搜索算法和值函数（value function）算法两类。深度学习模型可以在强化学习中得到使用，形成深度强化学习。</p>
<h2 id="6、了解数据集市、数据仓库、数据中台、数据平台的概念。"><a href="#6、了解数据集市、数据仓库、数据中台、数据平台的概念。" class="headerlink" title="6、了解数据集市、数据仓库、数据中台、数据平台的概念。"></a>6、了解数据集市、数据仓库、数据中台、数据平台的概念。</h2><h3 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h3><p>数据仓库：是一个集成的面向主题的数据集合，设计的目的是支持DSS（决策支持系统）的功能，在数据仓库里，每个数据单元都和特定的时间相关。数据仓库包括原子级别的数据和轻度汇总的数据。数据仓库是面向主题的、集成的、不可更新的(稳定性)、随时间不断变化（不同时间）的数据集合，用以支持经营管理中的决策制定过程。</p>
<h3 id="数据集市"><a href="#数据集市" class="headerlink" title="数据集市"></a>数据集市</h3><p>数据集市：是一个小型的部门或工作组级别的数据仓库。有两种类型的数据集市——独立型和从属型。独立型数据集市直接从操作型环境获取数据。从属型数据集市从企业级数据仓库获取数据。从长远的角度看，从属型数据集市在体系结构上比独立型数据集市更稳定。</p>
<h3 id="数据中台和数据平台"><a href="#数据中台和数据平台" class="headerlink" title="数据中台和数据平台"></a>数据中台和数据平台</h3><p>数据中台的本质就是“数据仓库+数据服务中间件”。</p>
<p>想要理解数据中台和数据平台的区别，首先应该了解中台和平台的区别。我理解的平台是企业或者研发团队为了满足用户需求而建设的基于业务的平台（也就是各种不同类型的能力组合后的产物）。而中台，一般是组合前的能力集合，处于同一中台的能力一般都是相似能力的，前台调用者只需要对中台的各种能力进行组合就可以来满足用户的需求。</p>
<p>数据中台就是对数据能力的一个建设集合，数据平台可以通过组合数据中台的能力来满足用户的需求，数据平台是直接面向客户的能力组合过后的商业产品，而数据中台是企业自身的能力集合。产品层从用户获取需求之后，制定出需要构建的数据能力平台，该能力平台就可以从企业已有的数据中台中获取不同的数据能力，通过能力的组合的方法，将中台中的小能力通过组合，拆分聚合构建起数据平台。如果数据能力中台中不包含某项能力，那么中台的建设者就应该积极去拓展这样的能力。</p>
<p>中台建设的过程中，中台抽象自平台。在平台的搭建过程中，平台来源于对中台能力的组合和聚合。单从用处来讲，中台的出现是为了减少重复劳动，基于用户需求的各种平台可以构建在企业能力中台之上，平台由各种中台能力类似于像搭积木一样构建起来。通过对不同能力的组合，聚合，构建起满足一定用户需求的大功能。中台的建设也需要从平台中借鉴经验，比如，用户需要什么样的功能，如果目前中台对这样的功能无法支持，那么我们就需要对中台能力进行扩充。数据中台就是为了避免重复创造数据能力相关的轮子而出现的数据能力集合。虽然数据平台也是能力集合，单从组成来讲，平台的能力比较基于某种功能，而中台能力集合中的某一个能力往往只基于某一个点。可以简单想象成企业内部的能力库。中台的出现就是为了减少重复轮子的构建工作。</p>
<h2 id="7、掌握数据采集与预处理过程，掌握数据采集、数据清洗、数据转换、数据脱敏的方法。"><a href="#7、掌握数据采集与预处理过程，掌握数据采集、数据清洗、数据转换、数据脱敏的方法。" class="headerlink" title="7、掌握数据采集与预处理过程，掌握数据采集、数据清洗、数据转换、数据脱敏的方法。"></a>7、掌握数据采集与预处理过程，掌握数据采集、数据清洗、数据转换、数据脱敏的方法。</h2><h3 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h3><p>数据采集根据采集数据的类型可以分为不同的方式，主要方式有：传感器采集、爬虫、录入、导入、接口等。</p>
<h3 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h3><p>1）忽略该条记录<br>若一条记录中有属性值被遗漏了，则将此条记录排除，尤其是没有类别属性值而又要进行分类数据挖掘时。当然，这种方法并不很有效，尤其是在每个属性的遗漏值的记录比例相差较大时。<br>2）手工填补遗漏值<br>一般这种方法比较耗时，而且对于存在许多遗漏情况的大规模数据集而言，显然可行性较差。<br>3）利用默认值填补遗漏值<br>对一个属性的所有遗漏的值均利用一个事先确定好的值来填补，如都用“OK”来填补。但当一个属性的遗漏值较多时，若采用这种方法，就可能误导挖掘进程。因此这种方法虽然简单，但并不推荐使用，或使用时需要仔细分析填补后的情况，以尽量避免对最终挖掘结果产生较大误差。<br>4）利用均值填补遗漏值<br>计算一个属性值的平均值，并用此值填补该属性所有遗漏的值。例如，若顾客的平均收入为 10000 元，则用此值填补“顾客收入”属性中所有被遗漏的值。<br>5）利用同类别均值填补遗漏值<br>这种方法尤其适合在进行分类挖掘时使用。例如，若要对商场顾客按信用风险进行分类挖掘时，就可以用在同一信用风险类别（如良好）下的“顾客收入”属性的平均值，来填补所有在同一信用风险类别下“顾客收入”属性的遗漏值。<br>6）利用最可能的值填补遗漏值<br>可以利用回归分析、贝叶斯计算公式或决策树推断出该条记录特定属性的最大可能的取值。例如，利用数据集中其他顾客的属性值，可以构造一个决策树来预测“顾客收入”属性的遗漏值。<br>最后一种方法是一种较常用的方法，与其他方法相比，它最大程度地利用了当前数据所包含的信息来帮助预测所遗漏的数据。</p>
<h3 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h3><p>1）平滑处理<br>帮助除去数据中的噪声，主要技术方法有 Bin 方法、聚类方法和回归方法。<br>2）合计处理<br>对数据进行总结或合计操作。例如，每天的数据经过合计操作可以获得每月或每年的总额。这一操作常用于构造数据立方或对数据进行多粒度的分析。<br>3）数据泛化处理<br>用更抽象（更高层次）的概念来取代低层次或数据层的数据对象。</p>
<p>例如，街道属性可以泛化到更高层次的概念，如城市、国家，数值型的属性，如年龄属性，可以映射到更高层次的概念，如年轻、中年和老年。<br>4）规格化处理<br>将有关属性数据按比例投射到特定的小范围之中。例如，将工资收入属性值映射到 0 到 1 范围内。<br>5）属性构造处理<br>根据已有属性集构造新的属性，以帮助数据处理过程。</p>
<h3 id="数据脱敏"><a href="#数据脱敏" class="headerlink" title="数据脱敏"></a>数据脱敏</h3><p>1.数据替换<br>要求：用设置的固定虚构值替换真值。例如将手机号码统一替换为 13800013800<br>2.无效化<br>要求：通过对数据值得截断、加密、隐藏等方式使敏感数据脱敏，使其不再具有利用价值，例如将地址以 ****** 代替真值。数据无效化与数据替换所达成的效果基本类似。<br>3.随机化<br>要求：用随机数据代替真值，保持替换值的随机性以模拟样本的真实性。例如用随机生成的姓和名代替真值。<br>【注意】这个例子中我们针对数据脱敏引入了外部字典表，实际情况中可以根据数据脱敏要求，随时引入任意外部字典表，通过数据的随机化组合，实现替换真值数据的脱敏处理。<br>4.偏移和取整<br>要求：通过随机移位改变数字数据，例如日期 2018-01-02 8:12:25 变为 2018-01-02 8:00:00，偏移取整在保持了数据的安全性的同时保证了范围的大致真实性，此项功能在大数据利用环境中具有重大价值。<br>5.掩码屏蔽<br>要求：掩码屏蔽是针对账户类数据的部分信息进行脱敏时的有力工具，比如银行卡号或是身份证号的脱敏。将身份证号的出生日期进行掩码屏蔽脱敏。使用left()函数截取身份证号的左边 6 位 + 字符串 ********+right()函数截取身份证号右边 4 位替换源身份证字符串。<br>6.灵活编码<br>要求：在需要特殊脱敏规则时，可执行灵活编码以满足各种可能的脱敏规则。比如用固定字母和固定位数的数字替代合同编号真值。将合同编号进行自定义编码脱敏。自定义编码规则：4 位固定码 + 当前年份 + 源目标字符串 4 位号码 + 9 位数值组成。</p>
<h2 id="8、了解数据存储与管理技术、大数据处理架构-Hadoop、分布式文件系统-HDFS、NoSQL-数据库、分布式数据库-HBase-的相关概念。"><a href="#8、了解数据存储与管理技术、大数据处理架构-Hadoop、分布式文件系统-HDFS、NoSQL-数据库、分布式数据库-HBase-的相关概念。" class="headerlink" title="8、了解数据存储与管理技术、大数据处理架构 Hadoop、分布式文件系统 HDFS、NoSQL 数据库、分布式数据库 HBase 的相关概念。"></a>8、了解数据存储与管理技术、大数据处理架构 Hadoop、分布式文件系统 HDFS、NoSQL 数据库、分布式数据库 HBase 的相关概念。</h2><h3 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h3><p>Hadoop 是一种分析和处理大数据的软件平台，是一个用 Java 语言实现的 Apache 的开源软件框架，在大量计算机组成的集群中实现了对海量数据的分布式计算。<br>Hadoop 采用 MapReduce 分布式计算框架，根据 GFS 原理开发了 HDFS（分布式文件系统），并根据 BigTable 原理开发了 HBase 数据存储系统。<br>Hadoop 是一个基础框架，允许用简单的编程模型在计算机集群上对大型数据集进行分布式处理。它的设计规模从单一服务器到数千台机器，每个服务器都能提供本地计算和存储功能，框架本身提供的是计算机集群高可用的服务，不依靠硬件来提供高可用性。<br>用户可以在不了解分布式底层细节的情况下，轻松地在 Hadoop 上开发和运行处理海量数据的应用程序。低成本、高可靠、高扩展、高有效、高容错等特性让 hadoop 成为最流行的大数据分析系统。<br><img src="/images/bigdata/3-7.jpg"><br>Hadoop 生态圈包括以下主要组件。<br>1）HDFS<br>一个提供高可用的获取应用数据的分布式文件系统。<br>2）MapReduce<br>一个并行处理大数据集的编程模型。<br>3）HBase<br>一个可扩展的分布式数据库，支持大表的结构化数据存储。是一个建立在 HDFS 之上的，面向列的 NoSQL 数据库，用于快速读/写大量数据。<br>4）Hive<br>一个建立在 Hadoop 上的数据仓库基础构架。它提供了一系列的工具；可以用来进行数据提取转化加载（ETL），这是一种可以存储、查询和分析存储在 Hadoop 中的大规模数据的机制。<br>Hive 定义了简单的类 SQL 查询语言，称为 HQL，它允许不熟悉 MapReduce 的开发人员也能编写数据查询语句，然后这些语句被翻译为 Hadoop 上面的 MapReduce 任务。<br>5）Mahout<br>可扩展的机器学习和数据挖掘库。它提供的 MapReduce 包含很多实现方法，包括聚类算法、回归测试、统计建模。<br>6）Pig<br>一个支持并行计算的高级的数据流语言和执行框架。它是 MapReduce 编程的复杂性的抽象。Pig 平台包括运行环境和用于分析 Hadoop 数据集的脚本语言（PigLatin）。其编译器将 PigLatin 翻译成 MapReduce 程序序列。<br>7）Zookeeper<br>—个应用于分布式应用的高性能的协调服务。它是一个为分布式应用提供一致性服务的软件，提供的功能包括配置维护、域名服务、分布式同步、组服务等。<br>8）Amban<br>一个基于 Web 的工具，用来供应、管理和监测 Hadoop 集群，包括支持 HDFS、MapReduceAHive、HCatalog、HBase、ZooKeeperAOozie、Pig 和 Sqoop 。</p>
<h3 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h3><p>HDFS 是 Hadoop 的一个分布式文件系统，是 Hadoop 应用程序使用的主要分布式存储。HDFS 被设计成适合运行在通用硬件上的分布式文件系统。<br>在 HDFS 体系结构中有两类结点：一类是 NameNode，又叫“名称结点”；另一类是 DataNode，又叫“数据结点”。这两类结点分别承担 Master 和 Worker 具体任务的执行。<br>HDFS 总的设计思想是分而治之，即将大文件和大批量文件分布式存放在大量独立的服务器上，以便采取分而治之的方式对海量数据进行运算分析。<br>HDFS 是一个主/从体系结构，从最终用户的角度来看，它就像传统的文件系统一样，可以通过目录路径对文件执行 CRUD（Create、Read、Update 和 Delete）操作。但由于分布式存储的性质，HDFS 集群拥有一个 NameNode 和一些 DataNode。NameNode 管理文件系统的元数据，DataNode 存储实际的数据。<br>客户端通过同 NameNode 和 DataNode 的交互来访问文件系统。客户端通过联系 NameNode 来获取文件的元数据，而真正的文件 I/O 操作是直接和 DataNode 交互进行的。<br>HDFS 主要针对“一次写入，多次读取”的应用场景，不适合实时交互性很强的应用场景，也不适合存储大量小文件。</p>
<h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><p>NoSQL 是一种不同于关系型数据库的数据库管理系统设计方式，是对非关系型数据库的统称。它所采用的数据模型并非关系型数据库的关系模型，而是类似键值、列族、文档等的非今系模型。它打破了长久以来关系型数据库与 ACID（原子性（Atomicity）、一致性（Consistency）隔离性（Isolation）和持久性（Durability））理论大一统的局面。<br>NoSQL 数据存储不需要固定的表结构，每一个元组可以有不一样的字段，每个元组可以根据需要增加一些自己的键值对，这样就不会局限于固定的结构，可以减少一些时间和空间的开销。</p>
<h3 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h3><p>HBase 是基于 Apache Hadoop 的面向列的 NoSQL 数据库，是 Google 的 BigTable 的开源实现。HBase 是一个针对半结构化数据的开源的、多版本的、可伸缩的、高可靠的、高性能的、分布式的和面向列的动态模式数据库。<br>HBase 和传统关系数据库不同，它采用了 BigTable 的数据模型增强的稀疏排序映射表（Key/Value），其中，键由行关键字、列关键字和时间戳构成。<br>HBase 提供了对大规模数据的随机、实时读写访问。HBase 的目标是存储并处理大型的数据，也就是仅用普通的硬件配置，就能够处理上千亿的行和几百万的列所组成的超大型数据库。</p>
<h2 id="9、了解大数据处理环节的主要思想：大数据采集、大数据预处理、大数据存储及管理、大数据分析及挖掘、大数据展现和应用（包括大数据检索、大数据可视化、大数据应用、大数据安全等）。"><a href="#9、了解大数据处理环节的主要思想：大数据采集、大数据预处理、大数据存储及管理、大数据分析及挖掘、大数据展现和应用（包括大数据检索、大数据可视化、大数据应用、大数据安全等）。" class="headerlink" title="9、了解大数据处理环节的主要思想：大数据采集、大数据预处理、大数据存储及管理、大数据分析及挖掘、大数据展现和应用（包括大数据检索、大数据可视化、大数据应用、大数据安全等）。"></a>9、了解大数据处理环节的主要思想：大数据采集、大数据预处理、大数据存储及管理、大数据分析及挖掘、大数据展现和应用（包括大数据检索、大数据可视化、大数据应用、大数据安全等）。</h2><h2 id="10、了解大数据处理与分析的代表性流行产品。"><a href="#10、了解大数据处理与分析的代表性流行产品。" class="headerlink" title="10、了解大数据处理与分析的代表性流行产品。"></a>10、了解大数据处理与分析的代表性流行产品。</h2><p>1、大数据平台，华为和星环。<br>华为- Fusioninsight，基于 Apache 进行功能增强的企业级大数据存储、查询和分析的统一平台。<br>星环，基于 Hadoop 生态系列的大数据平台公司。</p>
<p>2、云端大数据，阿里云和华为云。<br>阿里云实力不差，与亚马逊 AWS 抗衡，做公有云、私有云、混，面向中小型企业。<br>华为云，定位运营商和大中型企业，依傍数据安全</p>
<p>3、数据应用方面，围绕大数据和报表的帆软，特定业务应用的云 CRM 的纷享销客和等等。数据应用现在主要分为两种模式，一种是纯正 IT 类，围绕企业部暑应用的，如帆软。还有一类是互联网 2B 形式，主要是 SAAS 产品，如销售易。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="xuhj"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">xuhj</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">91</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xuhj</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  

</body>
</html>
