<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>开发管理（七）软件过程改进</title>
      <link href="/2021/10/11/%E8%BD%AF%E8%80%83/13%E3%80%81%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86/%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%83%EF%BC%89%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%94%B9%E8%BF%9B/"/>
      <url>/2021/10/11/%E8%BD%AF%E8%80%83/13%E3%80%81%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86/%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%83%EF%BC%89%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%94%B9%E8%BF%9B/</url>
      
        <content type="html"><![CDATA[<p>目前，使用最多的软件过程改进模型包括 CMM、CMMI、ISO9000 和 ITIL 等系列标准。</p><h1 id="1-CMM"><a href="#1-CMM" class="headerlink" title="1.CMM"></a>1.CMM</h1><p>W-CMM(软件能力成熟度模型)为软件企业的过程能力提供了一个阶梯式的进化框架， 阶梯共有五级。</p><p>(1)初始级。初始级的软件过程是未加定义的随意过程，项目的执行是随意甚至是混 乱的。</p><p>(2)可重复级。根据多年的经验和教训，人们总结出软件开发的首要问题不是技术问 题而是管理问题。因此，第二级的焦点集中在软件管理过程上。一个可管理的过程则是一个 可重复的过程，一个可重复的过程则能逐渐进化和成熟。第二级的管理过程包括了需求管理、 项目管理、质量管理、配置管理和子合同管理五个方面。其中项目管理分为计划过程和跟踪 与监控过程两个过程。实施这些过程，从管理角度可以看到一个按计划执行的且阶段可控的 软件开发过程。</p><p>(3)定义级。在第二级仅定义了管理的基本过程，而没有定义执行的步骤标准。在第 三级则要求制定企业范围的工程化标准，而且无论是管理还是工程开发都需要一套文档化的 标准，并将这些标准集成到企业软件开发标准过程中去。所有开发的项目需根据这个标准过 程，剪裁出与项目适宜的过程，并执行这些过程。过程的剪裁不是随意的，在使用前需经过 企业有关人员的批准。</p><p>(4)管理级。第四级的管理是量化的管理。所有过程需建立相应的度量方式，所有产 品的质量(包括工作产品和提交给用户的产品)需有明确的度量指标。这些度量应是详尽的， 且可用于理解和控制软件过程和产品。量化控制将使软件开发真正变成一种标准的工业生产 活动。</p><p>(5)优化级。第五级的目标是达到一个持续改善的境界。所谓持续改善是指可根据过 程执行的反馈信息来改善下一步的执行过程，即优化执行步骤。如果一个企业达到了这一级， 那么表明该企业能够根据实际的项目性质、技术等因素，不断调整软件生产过程以求达到最 佳。</p><h1 id="2-CMMI"><a href="#2-CMMI" class="headerlink" title="2.CMMI"></a>2.CMMI</h1><p>CMMI(Capability MaturityModel Integration)，即能力成熟度模型集成。CMMI 是 CMM 模型的最新版本。CMMI 与 CMM 最大的不同点在于:CMMISM-SE/SW/IPPD/SS 1.1 版本有 四个集成成分，即:系统工程(SE)和软件工程(SW)是基本的科目，对于有些组织还可 以应用集成产品和过程开发方面(IPPD)的内容，如果涉及供应商外包管理可以相应地应用<br>SS(Supplier Sourcing)部分。</p><p>CMMI 有两种表示方法，一种是和软件 CMM 一样的阶段式表现方法，另一种是连续式<br>的表现方法。这两种表现方法的区别是:阶段式表现方法仍然把 CMMI 中的若干个过程区 域分成了 5 个成熟度级别，帮助实施 CMMI 的组织建议一条比较容易实现的过程改进发 展道路。而连续式表现方法则通过将 CMMI 中过程区域分为四大类:过程管理、项目管理、 工程及支持。对于每个大类中的过程区域，又进一步分为基本的和高级的。这样，在按照连 续式表示方法实施 CMMI 的时候，一个组织可以把项目管理或者其他某类的实践一直做到 最好，而其他方面的过程区域可以完全不必考虑。</p><h1 id="3-ISO-9000"><a href="#3-ISO-9000" class="headerlink" title="3.ISO 9000"></a>3.ISO 9000</h1><p>ISO 9001 和 CMM 非常相似的是，两者都共同着眼于质量和过程管理，而且它 们都是基于戴明博士的全面质量管理 TQM 产生的，因此不存在任何矛盾的地方。但是，它 们的基础是不同的:ISO9001(ISO9000 标准系列中关于软件开发和维护的部分)确定一个 质量体系的最少需求，而 CMM 强调持续过程改进。</p><h1 id="4-ITIL"><a href="#4-ITIL" class="headerlink" title="4.ITIL"></a>4.ITIL</h1><p>ITIL(信息技术基础设施库)是英国政府中央计算机与电信管理中心(CCTA)在 20 世 纪 90 年代初期发布的一套 IT 服务管理最佳实践指南。</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-开发管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发管理（五）人力资源管理</title>
      <link href="/2021/10/11/%E8%BD%AF%E8%80%83/13%E3%80%81%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86/%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%94%EF%BC%89%E4%BA%BA%E5%8A%9B%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
      <url>/2021/10/11/%E8%BD%AF%E8%80%83/13%E3%80%81%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86/%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%94%EF%BC%89%E4%BA%BA%E5%8A%9B%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>包括组织规划、人员招募和团队建设三个主要过程。</p><h1 id="1-组织规划"><a href="#1-组织规划" class="headerlink" title="1.组织规划"></a>1.组织规划</h1><p>组织规划用于确定、记录并分派项目角色、职责和请示汇报关系。</p><h2 id="1-垂直团队组织。"><a href="#1-垂直团队组织。" class="headerlink" title="(1)垂直团队组织。"></a>(1)垂直团队组织。</h2><p>垂直团队由多面手组成。</p><h2 id="2-水平团队组织。"><a href="#2-水平团队组织。" class="headerlink" title="(2)水平团队组织。"></a>(2)水平团队组织。</h2><p>水平团队由专家组成。</p><h2 id="3-混合团队组织。"><a href="#3-混合团队组织。" class="headerlink" title="(3)混合团队组织。"></a>(3)混合团队组织。</h2><p>混合团队由专家和多面手共同组成。</p><h1 id="2-人员招募"><a href="#2-人员招募" class="headerlink" title="2.人员招募"></a>2.人员招募</h1><p>人员招募指获取分派到项目上、并在那里工作所需的人力资源(个人或集体)。在多数环境中，很可能无法到“最佳”资源，因此项目管理团队必须注意保证所物色 到的人力资源符合项目要求。</p><p>以往经验：这些个人或集体以前是否从事过类似或者相关的工作?工作表现如何?</p><p>个人兴趣：这些个人或集体对本项目的工作感兴趣吗?</p><p>能否得到：最理想的个人或集体人选能在规定期限内招募到手吗?</p><p>胜任与熟练程度：需要何种能力及何种水平?</p><h2 id="一般要求项目经理具备如下能力"><a href="#一般要求项目经理具备如下能力" class="headerlink" title="一般要求项目经理具备如下能力:"></a>一般要求项目经理具备如下能力:</h2><h3 id="1-领导能力。"><a href="#1-领导能力。" class="headerlink" title="(1)领导能力。"></a>(1)领导能力。</h3><p>首先，项目经理应懂得如何授权和分配职责，采取参与和顾问式的领导方式，发挥导向 和教练作用，让成员在职责范围内充分发挥能动性，自主地完成项目工作;<br>其次，项目经理应善于激励。<br>第三，项目经理应该为成员树立榜样，表现出积极的心态，成为团队的典范和信心的源 泉。<br>第四，项目经理应该能够果断抉择，负责人的重要任务是决策，特别是有多种选择的情 况下，一个正确的选择往往事半功倍。</p><h3 id="2-沟通技巧。"><a href="#2-沟通技巧。" class="headerlink" title="(2)沟通技巧。"></a>(2)沟通技巧。</h3><h3 id="3-人际交往能力。"><a href="#3-人际交往能力。" class="headerlink" title="(3)人际交往能力。"></a>(3)人际交往能力。</h3><h3 id="4-应付压力的能力。"><a href="#4-应付压力的能力。" class="headerlink" title="(4)应付压力的能力。"></a>(4)应付压力的能力。</h3><h3 id="5-培养员工的能力。"><a href="#5-培养员工的能力。" class="headerlink" title="(5)培养员工的能力。"></a>(5)培养员工的能力。</h3><h3 id="6-时间管理技能。"><a href="#6-时间管理技能。" class="headerlink" title="(6)时间管理技能。"></a>(6)时间管理技能。</h3><h2 id="3-团队建设项目"><a href="#3-团队建设项目" class="headerlink" title="3.团队建设项目"></a>3.团队建设项目</h2><p>团队的建设既包括提高项目干系人作为个人做出贡献的能力，也包括提高项目团队作为集体发挥作用的能力。个人的培养(管理能力与技术水平)是团队建设的 基础，而团队建设则是项目实现其目标的关键。</p><h3 id="1-形成阶段。"><a href="#1-形成阶段。" class="headerlink" title="(1)形成阶段。"></a>(1)形成阶段。</h3><p>形成阶段促使个体成员转变为团队成员。</p><h3 id="2-震荡阶段。"><a href="#2-震荡阶段。" class="headerlink" title="(2)震荡阶段。"></a>(2)震荡阶段。</h3><p>这一阶段，成员们开始着手执行分配到的任务，缓慢地推进工作。现 实也许会与个人当初的设想不一致。<br>震荡阶段的特点是人们有挫折、愤怨或者对立的情绪。这一阶段士气很低，成员可能会 抵制形成团队，因为他们要表达与团队联合相对立的个性。<br>因此在这一阶段，项目经理要做导向工作，致力于解决矛盾，决不能希望通过压制来使 其自行消失。这时，对于项目成员采取的激励方式主要是参与激励、责任激励和信息激励。</p><h3 id="3-正规阶段。"><a href="#3-正规阶段。" class="headerlink" title="(3)正规阶段。"></a>(3)正规阶段。</h3><p>经受了震荡阶段的考验，项目团队就进入了发展的正规阶段。项目团队逐渐接受了现有的工作环境，团队的凝聚力开始形成。这一阶段，随着成员之间开始相互 信任，团队内大量地交流信息、观点和感情，合作意识增强，团队成员互相交换看法，并感 觉到他们可以自由地、建设性地表达他们的情绪及意见。<br>在正规阶段，项目经理采取的激励方式除参与激励外，还有两个重要方式:一是发掘每 个成员的自我成就感和责任意识，引导员工进行自我激励;二是尽可能地多创造团队成员之 间互相沟通、相互学习的环境，以及从项目外部聘请专家讲解与项目有关的新知识、新技术， 给员工充分的知识激励。</p><h3 id="4-表现阶段。"><a href="#4-表现阶段。" class="headerlink" title="(4)表现阶段。"></a>(4)表现阶段。</h3><p>团队成长的最后阶段是表现阶段。这时，项目团队积极工作，急于实 现项目目标。这一阶段的工作绩效很高，团队有集体感和荣誉感，信心十足。团队能感觉到 被高度授权，如果出现技术难题，就由适当的团队成员组成临时攻关小组，解决问题后再将 相关知识或技巧在团队内部快速共享。<br>这一阶段，项目经理需要特别关注预算、进度计划、工作范围及计划方面的项目业绩。 如果实际进程落后于计划进程，项目经理就需要协助支持修正行动的制定与执行。这一阶段 激励的主要方式是危机激励、目标激励和知识激励。<br>需要强调的是，对于信息系统建设人才，要更多地引导他们进行自我激励和知识激励。 当然，足够的物质激励是不言而喻的，它从始至终都是最有效的激励。</p><h2 id="一个富有成效的项目团队具有如下特点"><a href="#一个富有成效的项目团队具有如下特点" class="headerlink" title="一个富有成效的项目团队具有如下特点:"></a>一个富有成效的项目团队具有如下特点:</h2><p>1、能清晰地理解项目的目标;<br>2、每位成员的角色和职责有明确的期望;<br>3、以项目的目标为行为的导向;<br>4、项目成员之间高度信任、高度合作互助。<br>总之，科学地进行团队建设有助于按期、保质、高效、在预算内完成软件项目。</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-开发管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发管理（六）软件的运行与评价</title>
      <link href="/2021/10/11/%E8%BD%AF%E8%80%83/13%E3%80%81%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86/%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86%EF%BC%88%E5%85%AD%EF%BC%89%E8%BD%AF%E4%BB%B6%E7%9A%84%E8%BF%90%E8%A1%8C%E4%B8%8E%E8%AF%84%E4%BB%B7/"/>
      <url>/2021/10/11/%E8%BD%AF%E8%80%83/13%E3%80%81%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86/%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86%EF%BC%88%E5%85%AD%EF%BC%89%E8%BD%AF%E4%BB%B6%E7%9A%84%E8%BF%90%E8%A1%8C%E4%B8%8E%E8%AF%84%E4%BB%B7/</url>
      
        <content type="html"><![CDATA[<p>(1)软件的稳定性和可靠性评价。<br>(2)软件是否满足了用户的需求。<br>(3)软件实施给用户带来的好处。</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-开发管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(一)法律法规</title>
      <link href="/2021/10/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%80%83%E8%AF%95/%E4%B8%80%E3%80%81%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84%E3%80%81%E6%94%BF%E7%AD%96%E6%96%87%E4%BB%B6%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%A0%87%E5%87%86/(%E4%B8%80)%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84/"/>
      <url>/2021/10/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%80%83%E8%AF%95/%E4%B8%80%E3%80%81%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84%E3%80%81%E6%94%BF%E7%AD%96%E6%96%87%E4%BB%B6%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%A0%87%E5%87%86/(%E4%B8%80)%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84/</url>
      
        <content type="html"><![CDATA[<h1 id="1、《中华人民共和国民法典》中华人民共和国主席令第四十五号"><a href="#1、《中华人民共和国民法典》中华人民共和国主席令第四十五号" class="headerlink" title="1、《中华人民共和国民法典》中华人民共和国主席令第四十五号"></a>1、《中华人民共和国民法典》中华人民共和国主席令第四十五号</h1><h2 id="1-了解隐私权和个人信息保护有关内容。"><a href="#1-了解隐私权和个人信息保护有关内容。" class="headerlink" title="(1)了解隐私权和个人信息保护有关内容。"></a>(1)了解隐私权和个人信息保护有关内容。</h2><p>第六章　隐私权和个人信息保护</p><p>第一千零三十二条　自然人享有隐私权。任何组织或者个人不得以刺探、侵扰、泄露、公开等方式侵害他人的隐私权。</p><p>隐私是自然人的私人生活安宁和不愿为他人知晓的私密空间、私密活动、私密信息。</p><p>第一千零三十三条　除法律另有规定或者权利人明确同意外，任何组织或者个人不得实施下列行为：</p><p>（一）以电话、短信、即时通讯工具、电子邮件、传单等方式侵扰他人的私人生活安宁；</p><p>（二）进入、拍摄、窥视他人的住宅、宾馆房间等私密空间；</p><p>（三）拍摄、窥视、窃听、公开他人的私密活动；</p><p>（四）拍摄、窥视他人身体的私密部位；</p><p>（五）处理他人的私密信息；</p><p>（六）以其他方式侵害他人的隐私权。</p><p>第一千零三十四条　自然人的个人信息受法律保护。</p><p>个人信息是以电子或者其他方式记录的能够单独或者与其他信息结合识别特定自然人的各种信息，包括自然人的姓名、出生日期、身份证件号码、生物识别信息、住址、电话号码、电子邮箱、健康信息、行踪信息等。</p><p>个人信息中的私密信息，适用有关隐私权的规定；没有规定的，适用有关个人信息保护的规定。</p><p>第一千零三十五条　处理个人信息的，应当遵循合法、正当、必要原则，不得过度处理，并符合下列条件：</p><p>（一）征得该自然人或者其监护人同意，但是法律、行政法规另有规定的除外；</p><p>（二）公开处理信息的规则；</p><p>（三）明示处理信息的目的、方式和范围；</p><p>（四）不违反法律、行政法规的规定和双方的约定。</p><p>个人信息的处理包括个人信息的收集、存储、使用、加工、传输、提供、公开等。</p><p>第一千零三十六条　处理个人信息，有下列情形之一的，行为人不承担民事责任：</p><p>（一）在该自然人或者其监护人同意的范围内合理实施的行为；</p><p>（二）合理处理该自然人自行公开的或者其他已经合法公开的信息，但是该自然人明确拒绝或者处理该信息侵害其重大利益的除外；</p><p>（三）为维护公共利益或者该自然人合法权益，合理实施的其他行为。</p><p>第一千零三十七条　自然人可以依法向信息处理者查阅或者复制其个人信息；发现信息有错误的，有权提出异议并请求及时采取更正等必要措施。</p><p>自然人发现信息处理者违反法律、行政法规的规定或者双方的约定处理其个人信息的，有权请求信息处理者及时删除。</p><p>第一千零三十八条　信息处理者不得泄露或者篡改其收集、存储的个人信息；未经自然人同意，不得向他人非法提供其个人信息，但是经过加工无法识别特定个人且不能复原的除外。</p><p>信息处理者应当采取技术措施和其他必要措施，确保其收集、存储的个人信息安全，防止信息泄露、篡改、丢失；发生或者可能发生个人信息泄露、篡改、丢失的，应当及时采取补救措施，按照规定告知自然人并向有关主管部门报告。</p><p>第一千零三十九条　国家机关、承担行政职能的法定机构及其工作人员对于履行职责过程中知悉的自然人的隐私和个人信息，应当予以保密，不得泄露或者向他人非法提供。</p><h1 id="2、《中华人民共和国数据安全法》中华人民共和国主席令第八十四号"><a href="#2、《中华人民共和国数据安全法》中华人民共和国主席令第八十四号" class="headerlink" title="2、《中华人民共和国数据安全法》中华人民共和国主席令第八十四号"></a>2、《中华人民共和国数据安全法》中华人民共和国主席令第八十四号</h1><h2 id="1-了解数据安全制度、数据安全保护义务、政务数据安全与开放等相关内容。"><a href="#1-了解数据安全制度、数据安全保护义务、政务数据安全与开放等相关内容。" class="headerlink" title="(1)了解数据安全制度、数据安全保护义务、政务数据安全与开放等相关内容。"></a>(1)了解数据安全制度、数据安全保护义务、政务数据安全与开放等相关内容。</h2><p>第三章 数据安全制度</p><p>第二十一条 国家建立数据分类分级保护制度，根据数据在经济社会发展中的重要程度，以及一旦遭到篡改、破坏、泄露或者非法获取、非法利用，对国家安全、公共利益或者个人、组织合法权益造成的危害程度，对数据实行分类分级保护。国家数据安全工作协调机制统筹协调有关部门制定重要数据目录，加强对重要数据的保护。</p><p>关系国家安全、国民经济命脉、重要民生、重大公共利益等数据属于国家核心数据，实行更加严格的管理制度。</p><p>各地区、各部门应当按照数据分类分级保护制度，确定本地区、本部门以及相关行业、领域的重要数据具体目录，对列入目录的数据进行重点保护。</p><p>第二十二条 国家建立集中统一、高效权威的数据安全风险评估、报告、信息共享、监测预警机制。国家数据安全工作协调机制统筹协调有关部门加强数据安全风险信息的获取、分析、研判、预警工作。</p><p>第二十三条 国家建立数据安全应急处置机制。发生数据安全事件，有关主管部门应当依法启动应急预案，采取相应的应急处置措施，防止危害扩大，消除安全隐患，并及时向社会发布与公众有关的警示信息。</p><p>第二十四条 国家建立数据安全审查制度，对影响或者可能影响国家安全的数据处理活动进行国家安全审查。</p><p>依法作出的安全审查决定为最终决定。</p><p>第二十五条 国家对与维护国家安全和利益、履行国际义务相关的属于管制物项的数据依法实施出口管制。</p><p>第二十六条 任何国家或者地区在与数据和数据开发利用技术等有关的投资、贸易等方面对中华人民共和国采取歧视性的禁止、限制或者其他类似措施的，中华人民共和国可以根据实际情况对该国家或者地区对等采取措施。</p><p>第四章 数据安全保护义务</p><p>第二十七条 开展数据处理活动应当依照法律、法规的规定，建立健全全流程数据安全管理制度，组织开展数据安全教育培训，采取相应的技术措施和其他必要措施，保障数据安全。利用互联网等信息网络开展数据处理活动，应当在网络安全等级保护制度的基础上，履行上述数据安全保护义务。</p><p>重要数据的处理者应当明确数据安全负责人和管理机构，落实数据安全保护责任。</p><p>第二十八条 开展数据处理活动以及研究开发数据新技术，应当有利于促进经济社会发展，增进人民福祉，符合社会公德和伦理。</p><p>第二十九条 开展数据处理活动应当加强风险监测，发现数据安全缺陷、漏洞等风险时，应当立即采取补救措施；发生数据安全事件时，应当立即采取处置措施，按照规定及时告知用户并向有关主管部门报告。</p><p>第三十条 重要数据的处理者应当按照规定对其数据处理活动定期开展风险评估，并向有关主管部门报送风险评估报告。</p><p>风险评估报告应当包括处理的重要数据的种类、数量，开展数据处理活动的情况，面临的数据安全风险及其应对措施等。</p><p>第三十一条 关键信息基础设施的运营者在中华人民共和国境内运营中收集和产生的重要数据的出境安全管理，适用《中华人民共和国网络安全法》的规定；其他数据处理者在中华人民共和国境内运营中收集和产生的重要数据的出境安全管理办法，由国家网信部门会同国务院有关部门制定。</p><p>第三十二条 任何组织、个人收集数据，应当采取合法、正当的方式，不得窃取或者以其他非法方式获取数据。</p><p>法律、行政法规对收集、使用数据的目的、范围有规定的，应当在法律、行政法规规定的目的和范围内收集、使用数据。</p><p>第三十三条 从事数据交易中介服务的机构提供服务，应当要求数据提供方说明数据来源，审核交易双方的身份，并留存审核、交易记录。</p><p>第三十四条 法律、行政法规规定提供数据处理相关服务应当取得行政许可的，服务提供者应当依法取得许可。</p><p>第三十五条 公安机关、国家安全机关因依法维护国家安全或者侦查犯罪的需要调取数据，应当按照国家有关规定，经过严格的批准手续，依法进行，有关组织、个人应当予以配合。</p><p>第三十六条 中华人民共和国主管机关根据有关法律和中华人民共和国缔结或者参加的国际条约、协定，或者按照平等互惠原则，处理外国司法或者执法机构关于提供数据的请求。非经中华人民共和国主管机关批准，境内的组织、个人不得向外国司法或者执法机构提供存储于中华人民共和国境内的数据。</p><p>第五章 政务数据安全与开放</p><p>第三十七条 国家大力推进电子政务建设，提高政务数据的科学性、准确性、时效性，提升运用数据服务经济社会发展的能力。</p><p>第三十八条 国家机关为履行法定职责的需要收集、使用数据，应当在其履行法定职责的范围内依照法律、行政法规规定的条件和程序进行；对在履行职责中知悉的个人隐私、个人信息、商业秘密、保密商务信息等数据应当依法予以保密，不得泄露或者非法向他人提供。</p><p>第三十九条 国家机关应当依照法律、行政法规的规定，建立健全数据安全管理制度，落实数据安全保护责任，保障政务数据安全。</p><p>第四十条 国家机关委托他人建设、维护电子政务系统，存储、加工政务数据，应当经过严格的批准程序，并应当监督受托方履行相应的数据安全保护义务。受托方应当依照法律、法规的规定和合同约定履行数据安全保护义务，不得擅自留存、使用、泄露或者向他人提供政务数据。</p><p>第四十一条 国家机关应当遵循公正、公平、便民的原则，按照规定及时、准确地公开政务数据。依法不予公开的除外。</p><p>第四十二条 国家制定政务数据开放目录，构建统一规范、互联互通、安全可控的政务数据开放平台，推动政务数据开放利用。</p><p>第四十三条 法律、法规授权的具有管理公共事务职能的组织为履行法定职责开展数据处理活动，适用本章规定。</p><h1 id="3、《中华人民共和国网络安全法》中华人民共和国主席令第五十三号"><a href="#3、《中华人民共和国网络安全法》中华人民共和国主席令第五十三号" class="headerlink" title="3、《中华人民共和国网络安全法》中华人民共和国主席令第五十三号"></a>3、《中华人民共和国网络安全法》中华人民共和国主席令第五十三号</h1><h2 id="1-熟悉数据分类、重要数据备份和加密等措施。"><a href="#1-熟悉数据分类、重要数据备份和加密等措施。" class="headerlink" title="(1)熟悉数据分类、重要数据备份和加密等措施。"></a>(1)熟悉数据分类、重要数据备份和加密等措施。</h2><p>第三章网络运行安全</p><p>第一节一般规定</p><p>第二十一条国家实行网络安全等级保护制度。网络运营者应当按照网络安全等级保护制度的要求，履行下列安全保护义务，保障网络免受干扰、破坏或者未经授权的访问，防止网络数据泄露或者被窃取、篡改：</p><p>（一）制定内部安全管理制度和操作规程，确定网络安全负责人，落实网络安全保护责任；</p><p>（二）采取防范计算机病毒和网络攻击、网络侵入等危害网络安全行为的技术措施；</p><p>（三）采取监测、记录网络运行状态、网络安全事件的技术措施，并按照规定留存相关的网络日志不少于六个月；</p><p>（四）采取数据分类、重要数据备份和加密等措施；</p><p>（五）法律、行政法规规定的其他义务。</p><h1 id="4、《中华人民共和国电子签名法-2019-版-》中华人民共和国主席令第二十九号"><a href="#4、《中华人民共和国电子签名法-2019-版-》中华人民共和国主席令第二十九号" class="headerlink" title="4、《中华人民共和国电子签名法(2019 版)》中华人民共和国主席令第二十九号"></a>4、《中华人民共和国电子签名法(2019 版)》中华人民共和国主席令第二十九号</h1><h2 id="1-了解电子签名、数据电文基本概念。"><a href="#1-了解电子签名、数据电文基本概念。" class="headerlink" title="(1)了解电子签名、数据电文基本概念。"></a>(1)了解电子签名、数据电文基本概念。</h2><p>第一章　总　　则</p><p>第一条　为了规范电子签名行为，确立电子签名的法律效力，维护有关各方的合法权益，制定本法。</p><p>第二条　本法所称电子签名，是指数据电文中以电子形式所含、所附用于识别签名人身份并表明签名人认可其中内容的数据。</p><p>本法所称数据电文，是指以电子、光学、磁或者类似手段生成、发送、接收或者储存的信息。</p><p>第三条　民事活动中的合同或者其他文件、单证等文书，当事人可以约定使用或者不使用电子签名、数据电文。</p><p>当事人约定使用电子签名、数据电文的文书，不得仅因为其采用电子签名、数据电文的形式而否定其法律效力。</p><p>前款规定不适用下列文书：</p><p>（一）涉及婚姻、收养、继承等人身关系的；</p><p>（二）涉及停止供水、供热、供气等公用事业服务的；</p><p>（三）法律、行政法规规定的不适用电子文书的其他情形。</p><p>第二章　数据电文</p><p>第四条　能够有形地表现所载内容，并可以随时调取查用的数据电文，视为符合法律、法规要求的书面形式。</p><p>第五条　符合下列条件的数据电文，视为满足法律、法规规定的原件形式要求：</p><p>（一）能够有效地表现所载内容并可供随时调取查用；</p><p>（二）能够可靠地保证自最终形成时起，内容保持完整、未被更改。但是，在数据电文上增加背书以及数据交换、储存和显示过程中发生的形式变化不影响数据电文的完整性。</p><p>第六条　符合下列条件的数据电文，视为满足法律、法规规定的文件保存要求：</p><p>（一）能够有效地表现所载内容并可供随时调取查用；</p><p>（二）数据电文的格式与其生成、发送或者接收时的格式相同，或者格式不相同但是能够准确表现原来生成、发送或者接收的内容；</p><p>（三）能够识别数据电文的发件人、收件人以及发送、接收的时间。</p><p>第七条　数据电文不得仅因为其是以电子、光学、磁或者类似手段生成、发送、接收或者储存的而被拒绝作为证据使用。</p><p>第八条　审查数据电文作为证据的真实性，应当考虑以下因素：</p><p>（一）生成、储存或者传递数据电文方法的可靠性；</p><p>（二）保持内容完整性方法的可靠性；</p><p>（三）用以鉴别发件人方法的可靠性；</p><p>（四）其他相关因素。</p><p>第九条　数据电文有下列情形之一的，视为发件人发送：</p><p>（一）经发件人授权发送的；</p><p>（二）发件人的信息系统自动发送的；</p><p>（三）收件人按照发件人认可的方法对数据电文进行验证后结果相符的。</p><p>当事人对前款规定的事项另有约定的，从其约定。</p><p>第十条　法律、行政法规规定或者当事人约定数据电文需要确认收讫的，应当确认收讫。发件人收到收件人的收讫确认时，数据电文视为已经收到。</p><p>第十一条　数据电文进入发件人控制之外的某个信息系统的时间，视为该数据电文的发送时间。</p><p>收件人指定特定系统接收数据电文的，数据电文进入该特定系统的时间，视为该数据电文的接收时间；未指定特定系统的，数据电文进入收件人的任何系统的首次时间，视为该数据电文的接收时间。</p><p>当事人对数据电文的发送时间、接收时间另有约定的，从其约定。</p><p>第十二条　发件人的主营业地为数据电文的发送地点，收件人的主营业地为数据电文的接收地点。没有主营业地的，其经常居住地为发送或者接收地点。</p><p>当事人对数据电文的发送地点、接收地点另有约定的，从其约定。</p><p>第三章　电子签名与认证</p><p>第十三条　电子签名同时符合下列条件的，视为可靠的电子签名：</p><p>（一）电子签名制作数据用于电子签名时，属于电子签名人专有；</p><p>（二）签署时电子签名制作数据仅由电子签名人控制；</p><p>（三）签署后对电子签名的任何改动能够被发现；</p><p>（四）签署后对数据电文内容和形式的任何改动能够被发现。</p><p>当事人也可以选择使用符合其约定的可靠条件的电子签名。</p><p>第十四条　可靠的电子签名与手写签名或者盖章具有同等的法律效力。</p><p>第十五条　电子签名人应当妥善保管电子签名制作数据。电子签名人知悉电子签名制作数据已经失密或者可能已经失密时，应当及时告知有关各方，并终止使用该电子签名制作数据。</p><p>第十六条　电子签名需要第三方认证的，由依法设立的电子认证服务提供者提供认证服务。</p><p>第十七条　提供电子认证服务，应当具备下列条件：</p><p>（一）取得企业法人资格；</p><p>（二）具有与提供电子认证服务相适应的专业技术人员和管理人员；</p><p>（三）具有与提供电子认证服务相适应的资金和经营场所；</p><p>（四）具有符合国家安全标准的技术和设备；</p><p>（五）具有国家密码管理机构同意使用密码的证明文件；</p><p>（六）法律、行政法规规定的其他条件。</p><p>第十八条　从事电子认证服务，应当向国务院信息产业主管部门提出申请，并提交符合本法第十七条规定条件的相关材料。国务院信息产业主管部门接到申请后经依法审查，征求国务院商务主管部门等有关部门的意见后，自接到申请之日起四十五日内作出许可或者不予许可的决定。予以许可的，颁发电子认证许可证书；不予许可的，应当书面通知申请人并告知理由。</p><p>取得认证资格的电子认证服务提供者，应当按照国务院信息产业主管部门的规定在互联网上公布其名称、许可证号等信息。</p><p>第十九条　电子认证服务提供者应当制定、公布符合国家有关规定的电子认证业务规则，并向国务院信息产业主管部门备案。</p><p>电子认证业务规则应当包括责任范围、作业操作规范、信息安全保障措施等事项。</p><p>第二十条　电子签名人向电子认证服务提供者申请电子签名认证证书，应当提供真实、完整和准确的信息。</p><p>电子认证服务提供者收到电子签名认证证书申请后，应当对申请人的身份进行查验，并对有关材料进行审查。</p><p>第二十一条　电子认证服务提供者签发的电子签名认证证书应当准确无误，并应当载明下列内容：</p><p>（一）电子认证服务提供者名称；</p><p>（二）证书持有人名称；</p><p>（三）证书序列号；</p><p>（四）证书有效期；</p><p>（五）证书持有人的电子签名验证数据；</p><p>（六）电子认证服务提供者的电子签名；</p><p>（七）国务院信息产业主管部门规定的其他内容。</p><p>第二十二条　电子认证服务提供者应当保证电子签名认证证书内容在有效期内完整、准确，并保证电子签名依赖方能够证实或者了解电子签名认证证书所载内容及其他有关事项。</p><p>第二十三条　电子认证服务提供者拟暂停或者终止电子认证服务的，应当在暂停或者终止服务九十日前，就业务承接及其他有关事项通知有关各方。</p><p>电子认证服务提供者拟暂停或者终止电子认证服务的，应当在暂停或者终止服务六十日前向国务院信息产业主管部门报告，并与其他电子认证服务提供者就业务承接进行协商，作出妥善安排。</p><p>电子认证服务提供者未能就业务承接事项与其他电子认证服务提供者达成协议的，应当申请国务院信息产业主管部门安排其他电子认证服务提供者承接其业务。</p><p>电子认证服务提供者被依法吊销电子认证许可证书的，其业务承接事项的处理按照国务院信息产业主管部门的规定执行。</p><p>第二十四条　电子认证服务提供者应当妥善保存与认证相关的信息，信息保存期限至少为电子签名认证证书失效后五年。</p><p>第二十五条　国务院信息产业主管部门依照本法制定电子认证服务业的具体管理办法，对电子认证服务提供者依法实施监督管理。</p><p>第二十六条　经国务院信息产业主管部门根据有关协议或者对等原则核准后，中华人民共和国境外的电子认证服务提供者在境外签发的电子签名认证证书与依照本法设立的电子认证服务提供者签发的电子签名认证证书具有同等的法律效力。</p><h1 id="5、《中华人民共和国密码法》中华人民共和国主席令第三十五号"><a href="#5、《中华人民共和国密码法》中华人民共和国主席令第三十五号" class="headerlink" title="5、《中华人民共和国密码法》中华人民共和国主席令第三十五号"></a>5、《中华人民共和国密码法》中华人民共和国主席令第三十五号</h1><h2 id="1-了解核心密码、普通密码、商用密码之间的区别。"><a href="#1-了解核心密码、普通密码、商用密码之间的区别。" class="headerlink" title="(1)了解核心密码、普通密码、商用密码之间的区别。"></a>(1)了解核心密码、普通密码、商用密码之间的区别。</h2><p>第一章　总　　则</p><p>第一条　为了规范密码应用和管理，促进密码事业发展，保障网络与信息安全，维护国家安全和社会公共利益，保护公民、法人和其他组织的合法权益，制定本法。</p><p>第二条　本法所称密码，是指采用特定变换的方法对信息等进行加密保护、安全认证的技术、产品和服务。</p><p>第三条　密码工作坚持总体国家安全观，遵循统一领导、分级负责，创新发展、服务大局，依法管理、保障安全的原则。</p><p>第四条　坚持中国共产党对密码工作的领导。中央密码工作领导机构对全国密码工作实行统一领导，制定国家密码工作重大方针政策，统筹协调国家密码重大事项和重要工作，推进国家密码法治建设。</p><p>第五条　国家密码管理部门负责管理全国的密码工作。县级以上地方各级密码管理部门负责管理本行政区域的密码工作。</p><p>国家机关和涉及密码工作的单位在其职责范围内负责本机关、本单位或者本系统的密码工作。</p><p>第六条　国家对密码实行分类管理。</p><p>密码分为核心密码、普通密码和商用密码。</p><p>第七条　核心密码、普通密码用于保护国家秘密信息，核心密码保护信息的最高密级为绝密级，普通密码保护信息的最高密级为机密级。</p><p>核心密码、普通密码属于国家秘密。密码管理部门依照本法和有关法律、行政法规、国家有关规定对核心密码、普通密码实行严格统一管理。</p><p>第八条　商用密码用于保护不属于国家秘密的信息。</p><p>公民、法人和其他组织可以依法使用商用密码保护网络与信息安全。</p><p>第九条　国家鼓励和支持密码科学技术研究和应用，依法保护密码领域的知识产权，促进密码科学技术进步和创新。</p><p>国家加强密码人才培养和队伍建设，对在密码工作中作出突出贡献的组织和个人，按照国家有关规定给予表彰和奖励。</p><p>第十条　国家采取多种形式加强密码安全教育，将密码安全教育纳入国民教育体系和公务员教育培训体系，增强公民、法人和其他组织的密码安全意识。</p><p>第十一条　县级以上人民政府应当将密码工作纳入本级国民经济和社会发展规划，所需经费列入本级财政预算。</p><p>第十二条　任何组织或者个人不得窃取他人加密保护的信息或者非法侵入他人的密码保障系统。</p><p>任何组织或者个人不得利用密码从事危害国家安全、社会公共利益、他人合法权益等违法犯罪活动。</p><p>第二章　核心密码、普通密码</p><p>第十三条　国家加强核心密码、普通密码的科学规划、管理和使用，加强制度建设，完善管理措施，增强密码安全保障能力。</p><p>第十四条　在有线、无线通信中传递的国家秘密信息，以及存储、处理国家秘密信息的信息系统，应当依照法律、行政法规和国家有关规定使用核心密码、普通密码进行加密保护、安全认证。</p><p>第十五条　从事核心密码、普通密码科研、生产、服务、检测、装备、使用和销毁等工作的机构（以下统称密码工作机构）应当按照法律、行政法规、国家有关规定以及核心密码、普通密码标准的要求，建立健全安全管理制度，采取严格的保密措施和保密责任制，确保核心密码、普通密码的安全。</p><p>第十六条　密码管理部门依法对密码工作机构的核心密码、普通密码工作进行指导、监督和检查，密码工作机构应当配合。</p><p>第十七条　密码管理部门根据工作需要会同有关部门建立核心密码、普通密码的安全监测预警、安全风险评估、信息通报、重大事项会商和应急处置等协作机制，确保核心密码、普通密码安全管理的协同联动和有序高效。</p><p>密码工作机构发现核心密码、普通密码泄密或者影响核心密码、普通密码安全的重大问题、风险隐患的，应当立即采取应对措施，并及时向保密行政管理部门、密码管理部门报告，由保密行政管理部门、密码管理部门会同有关部门组织开展调查、处置，并指导有关密码工作机构及时消除安全隐患。</p><p>第十八条　国家加强密码工作机构建设，保障其履行工作职责。</p><p>国家建立适应核心密码、普通密码工作需要的人员录用、选调、保密、考核、培训、待遇、奖惩、交流、退出等管理制度。</p><p>第十九条　密码管理部门因工作需要，按照国家有关规定，可以提请公安、交通运输、海关等部门对核心密码、普通密码有关物品和人员提供免检等便利，有关部门应当予以协助。</p><p>第二十条　密码管理部门和密码工作机构应当建立健全严格的监督和安全审查制度，对其工作人员遵守法律和纪律等情况进行监督，并依法采取必要措施，定期或者不定期组织开展安全审查。</p><p>第三章　商用密码</p><p>第二十一条　国家鼓励商用密码技术的研究开发、学术交流、成果转化和推广应用，健全统一、开放、竞争、有序的商用密码市场体系，鼓励和促进商用密码产业发展。</p><p>各级人民政府及其有关部门应当遵循非歧视原则，依法平等对待包括外商投资企业在内的商用密码科研、生产、销售、服务、进出口等单位（以下统称商用密码从业单位）。国家鼓励在外商投资过程中基于自愿原则和商业规则开展商用密码技术合作。行政机关及其工作人员不得利用行政手段强制转让商用密码技术。</p><p>商用密码的科研、生产、销售、服务和进出口，不得损害国家安全、社会公共利益或者他人合法权益。</p><p>第二十二条　国家建立和完善商用密码标准体系。</p><p>国务院标准化行政主管部门和国家密码管理部门依据各自职责，组织制定商用密码国家标准、行业标准。</p><p>国家支持社会团体、企业利用自主创新技术制定高于国家标准、行业标准相关技术要求的商用密码团体标准、企业标准。</p><p>第二十三条　国家推动参与商用密码国际标准化活动，参与制定商用密码国际标准，推进商用密码中国标准与国外标准之间的转化运用。</p><p>国家鼓励企业、社会团体和教育、科研机构等参与商用密码国际标准化活动。</p><p>第二十四条　商用密码从业单位开展商用密码活动，应当符合有关法律、行政法规、商用密码强制性国家标准以及该从业单位公开标准的技术要求。</p><p>国家鼓励商　用密码从业单位采用商用密码推荐性国家标准、行业标准，提升商用密码的防护能力，维护用户的合法权益。</p><p>第二十五条　国家推进商用密码检测认证体系建设，制定商用密码检测认证技术规范、规则，鼓励商用密码从业单位自愿接受商用密码检测认证，提升市场竞争力。</p><p>商用密码检测、认证机构应当依法取得相关资质，并依照法律、行政法规的规定和商用密码检测认证技术规范、规则开展商用密码检测认证。</p><p>商用密码检测、认证机构应当对其在商用密码检测认证中所知悉的国家秘密和商业秘密承担保密义务。</p><p>第二十六条　涉及国家安全、国计民生、社会公共利益的商用密码产品，应当依法列入网络关键设备和网络安全专用产品目录，由具备资格的机构检测认证合格后，方可销售或者提供。商用密码产品检测认证适用《中华人民共和国网络安全法》的有关规定，避免重复检测认证。</p><p>商用密码服务使用网络关键设备和网络安全专用产品的，应当经商用密码认证机构对该商用密码服务认证合格。</p><p>第二十七条　法律、行政法规和国家有关规定要求使用商用密码进行保护的关键信息基础设施，其运营者应当使用商用密码进行保护，自行或者委托商用密码检测机构开展商用密码应用安全性评估。商用密码应用安全性评估应当与关键信息基础设施安全检测评估、网络安全等级测评制度相衔接，避免重复评估、测评。</p><p>关键信息基础设施的运营者采购涉及商用密码的网络产品和服务，可能影响国家安全的，应当按照《中华人民共和国网络安全法》的规定，通过国家网信部门会同国家密码管理部门等有关部门组织的国家安全审查。</p><p>第二十八条　国务院商务主管部门、国家密码管理部门依法对涉及国家安全、社会公共利益且具有加密保护功能的商用密码实施进口许可，对涉及国家安全、社会公共利益或者中国承担国际义务的商用密码实施出口管制。商用密码进口许可清单和出口管制清单由国务院商务主管部门会同国家密码管理部门和海关总署制定并公布。</p><p>大众消费类产品所采用的商用密码不实行进口许可和出口管制制度。</p><p>第二十九条　国家密码管理部门对采用商用密码技术从事电子政务电子认证服务的机构进行认定，会同有关部门负责政务活动中使用电子签名、数据电文的管理。</p><p>第三十条　商用密码领域的行业协会等组织依照法律、行政法规及其章程的规定，为商用密码从业单位提供信息、技术、培训等服务，引导和督促商用密码从业单位依法开展商用密码活动，加强行业自律，推动行业诚信建设，促进行业健康发展。</p><p>第三十一条　密码管理部门和有关部门建立日常监管和随机抽查相结合的商用密码事中事后监管制度，建立统一的商用密码监督管理信息平台，推进事中事后监管与社会信用体系相衔接，强化商用密码从业单位自律和社会监督。</p><p>密码管理部门和有关部门及其工作人员不得要求商用密码从业单位和商用密码检测、认证机构向其披露源代码等密码相关专有信息，并对其在履行职责中知悉的商业秘密和个人隐私严格保密，不得泄露或者非法向他人提供。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据分析应用-中级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据-法律法规 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>干啊，大数据考试之路</title>
      <link href="/2021/10/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%80%83%E8%AF%95/start/"/>
      <url>/2021/10/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%80%83%E8%AF%95/start/</url>
      
        <content type="html"><![CDATA[<p>干啊，大数据考试~</p><p>大数据分析应用-中级大纲</p>]]></content>
      
      
      <categories>
          
          <category> 大数据分析应用-中级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据分析应用-中级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(二)政策文件</title>
      <link href="/2021/10/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%80%83%E8%AF%95/%E4%B8%80%E3%80%81%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84%E3%80%81%E6%94%BF%E7%AD%96%E6%96%87%E4%BB%B6%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%A0%87%E5%87%86/(%E4%BA%8C)%E6%94%BF%E7%AD%96%E6%96%87%E4%BB%B6/"/>
      <url>/2021/10/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%80%83%E8%AF%95/%E4%B8%80%E3%80%81%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84%E3%80%81%E6%94%BF%E7%AD%96%E6%96%87%E4%BB%B6%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%A0%87%E5%87%86/(%E4%BA%8C)%E6%94%BF%E7%AD%96%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="1、《促进大数据发展行动纲要》国发〔2015〕50-号"><a href="#1、《促进大数据发展行动纲要》国发〔2015〕50-号" class="headerlink" title="1、《促进大数据发展行动纲要》国发〔2015〕50 号"></a>1、《促进大数据发展行动纲要》国发〔2015〕50 号</h1><h2 id="1-熟悉数据共享的范围边界和使用方式。"><a href="#1-熟悉数据共享的范围边界和使用方式。" class="headerlink" title="(1)熟悉数据共享的范围边界和使用方式。"></a>(1)熟悉数据共享的范围边界和使用方式。</h2><p>三、主要任务</p><p>（一）加快政府数据开放共享，推动资源整合，提升治理能力。</p><p>1.大力推动政府部门数据共享。加强顶层设计和统筹规划，明确各部门数据共享的范围边界和使用方式，厘清各部门数据管理及共享的义务和权利，依托政府数据统一共享交换平台，大力推进国家人口基础信息库、法人单位信息资源库、自然资源和空间地理基础信息库等国家基础数据资源，以及金税、金关、金财、金审、金盾、金宏、金保、金土、金农、金水、金质等信息系统跨部门、跨区域共享。加快各地区、各部门、各有关企事业单位及社会组织信用信息系统的互联互通和信息共享，丰富面向公众的信用信息服务，提高政府服务和监管水平。结合信息惠民工程实施和智慧城市建设，推动中央部门与地方政府条块结合、联合试点，实现公共服务的多方数据共享、制度对接和协同配合。</p><h1 id="2、《山东省“十四五”数字强省建设规划》"><a href="#2、《山东省“十四五”数字强省建设规划》" class="headerlink" title="2、《山东省“十四五”数字强省建设规划》"></a>2、《山东省“十四五”数字强省建设规划》</h1><h2 id="1-了解数字强省“十四五”规划发展目标及主要任务。"><a href="#1-了解数字强省“十四五”规划发展目标及主要任务。" class="headerlink" title="(1)了解数字强省“十四五”规划发展目标及主要任务。"></a>(1)了解数字强省“十四五”规划发展目标及主要任务。</h2><p>(三) 发展目标。</p><p>到2025年,数字强省建设实现重大突破,以数字化转型整体驱动生产方式、生活方式和治理方式变革取得显著成效,数字经济与实体经济深度融合发展,数字基础设施、数字政府、数字社会建设成效大幅提升,整体工作始终处在全国“第一方阵”。</p><p>1、数字基础设施实现走在前列。“双千兆”网络覆盖全省所有城区和乡镇,存算一体、边云协同的算力基础设施体系构建完成,亿级物联感知节点加快部署,交通、水利、能源、市政等融合基础设施建设水平国内领先,构建起泛在连接、高效协同、全域感知、智能融合、安全可信的数字基础设施体系,打造全国信息基础设施先行区和融合基础设施示范区。</p><p>2、数字科技创新实现走在前列。突破一批关键数字技术,数字科技基础研究和前沿研究水平大幅提高,取得一批前瞻性、原创性重大成果。高端服务器、高效网络存储方面技术优势不断巩固,实现引领性数字技术攻关。打造一批数字化领域重点实验室、创新中心、技术转移中心,充分发挥科技创新对经济社会数字化转型发展的支撑带动作用。</p><p>3、数字经济发展实现走在前列。数字产业化竞争力显著提升,形成具有国际竞争力的数字产业集群。实现一、二、三产业重点行业领域数字化改造全覆盖,高水平建成山东半岛工业互联网示范区,规模以上工业企业智能化改造覆盖面达到90%以上,打造具有全球重要影响力的产业数字化创新发展策源地。全省数字经济总量年均增幅达到11%,数字经济核心产业增加值占GDP比重力争超过10%,建成全国数字经济发展示范区。</p><p>4、数字政府建设实现走在前列。全省统一的“云、网、数、用”体系不断完善,全面建成数字机关,企业和群众找政府办事线上只进一网、线下只进一窗,省级及以下政府部门出具的实体证照证明“免提交”,基本建成整体、泛在、高效、透明的数字政府,打造一流数字化营商环境,成为全国公共服务和政府治理示范区。</p><p>5、数字社会构建实现走在前列。城乡数字化均衡发展,所有设区市和60%的县(市、区)建成四星级以上新型智慧城市,力争打造3个以上的五星级标杆城市,数字乡村建设取得重大进展,高质量打造乡村振兴齐鲁样板。建成全生命周期数字化惠民服务体系,数字化高品质生活走进千家万户,全民数字素养大幅提升,群众的获得感幸福感安全感显著增强。</p><p>6、数字生态打造实现走在前列。数字强省建设推进机制不断完善,形成共建共享、科学高效的数字强省建设运营模式。构建起科学完备的数字化发展政策法规体系,推出一批引领全国的标准规范,安全保障和风险防范能力显著增强。数据资源供给水平位居全国前列,数据要素市场化配置改革取得重大进展。开放包容、富有活力的数字化发展环境不断优化,成为大数据赋能创新创业示范省。</p><h1 id="3、《关于促进大数据发展的意见》鲁政发〔2016〕25-号"><a href="#3、《关于促进大数据发展的意见》鲁政发〔2016〕25-号" class="headerlink" title="3、《关于促进大数据发展的意见》鲁政发〔2016〕25 号"></a>3、《关于促进大数据发展的意见》鲁政发〔2016〕25 号</h1><h2 id="1-了解山东省促进大数据发展的总体目标以及大数据应用生态体系。"><a href="#1-了解山东省促进大数据发展的总体目标以及大数据应用生态体系。" class="headerlink" title="(1)了解山东省促进大数据发展的总体目标以及大数据应用生态体系。"></a>(1)了解山东省促进大数据发展的总体目标以及大数据应用生态体系。</h2><p>（三）总体目标。到2020年，初步形成发展氛围浓厚、体制机制较完善、共享开放程度较高、创新应用范围较广的大数据发展格局，大数据成为提升政府治理能力、推动经济转型升级、塑造山东竞争新优势的战略路径。</p><p>支撑体系更为完善。制定出台大数据发展条例，大数据采集、管理、共享、开放、交易等标准规范基本健全。省、市两级大数据基础设施建成并投入使用。济南、青岛成为全国性社会化大数据中心。</p><p>数据共享开放加快。跨部门、跨地区、跨层级的信息资源共享交换机制基本形成。全省统一的政府数据开放平台建成使用，政府数据开放行动计划顺利实施，政府数据的增值性、公益性开发应用有序推进。</p><p>示范应用成效显现。政务服务、经济运行、市政公用、城乡建设、社会治理、创业创新、产业发展等重要领域特色专题数据库搭建完成，面向政务、交通、旅游、警务、民政、规划、城市管理、住区服务等领域需求的大数据示范应用全面推广，在线公共平台服务更加普惠便利。</p><p>产业体系逐步健全。大数据关键技术创新能力显著增强，掌握一批自主关键技术，大数据产业集聚发展、链式发展的格局基本形成，安全保障能力明显提高，培育形成一批大数据龙头企业和知名品牌。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据分析应用-中级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据-政策文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(三)相关标准</title>
      <link href="/2021/10/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%80%83%E8%AF%95/%E4%B8%80%E3%80%81%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84%E3%80%81%E6%94%BF%E7%AD%96%E6%96%87%E4%BB%B6%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%A0%87%E5%87%86/(%E4%B8%89)%E7%9B%B8%E5%85%B3%E6%A0%87%E5%87%86/"/>
      <url>/2021/10/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%80%83%E8%AF%95/%E4%B8%80%E3%80%81%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84%E3%80%81%E6%94%BF%E7%AD%96%E6%96%87%E4%BB%B6%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%A0%87%E5%87%86/(%E4%B8%89)%E7%9B%B8%E5%85%B3%E6%A0%87%E5%87%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1、GB-T-35295-2017-信息技术-大数据-术语"><a href="#1、GB-T-35295-2017-信息技术-大数据-术语" class="headerlink" title="1、GB/T 35295-2017 信息技术 大数据 术语"></a>1、GB/T 35295-2017 信息技术 大数据 术语</h1><h2 id="1-了解本标准的范围、术语和定义，以及密切相关的通用术语。"><a href="#1-了解本标准的范围、术语和定义，以及密切相关的通用术语。" class="headerlink" title="(1)了解本标准的范围、术语和定义，以及密切相关的通用术语。"></a>(1)了解本标准的范围、术语和定义，以及密切相关的通用术语。</h2><p>1范 围</p><p>本标准界定了信息技术大数据领域中的常用术语和定义。</p><p>本标准适用于大数据领域的科研、教学和应用。</p><p>2术语和定义</p><p>2.1 大数据及其应用领域术语</p><p>2.1.1 大数据 big data 具有体量巨大、来源多样、生成极快、且多变等特征并且难以用传统数据体系结构有效处理的包含大量数据集的数据。</p><p>注：国际上，大数据的4个特征普遍不加修饰地直接用volume、variety、velocity和variability予以表述，并分别赋予了它们在大数据语境下的定义：</p><p>a）体量volume：构成大数据的数据集的规模。</p><p>b）多样性 variety：数据可能来自多个数据仓库、数据领域或多种数据类型。</p><p>c）速度velocity：单位时间的数据流量。</p><p>d）多变性variability：大数据其他特征，即体量、速度和多样性等特征都处于多变状态。</p><p>2.1.2 数据生存周期 data lifecycle 将原始数据转化为可用于行动的知识的一组过程。</p><p>2.1.3 大数据参考体系结构 big data reference architecture 一种用作工具以便于对大数据内在的要求、设计结构和运行进行开放性探讨的高层概念模型。</p><p>注：比较普遍认同的大数据参考体系结构一般包含系统协调者、数据提供者、大数据应用提供者、大数据框架提供者和数据消费者等5个逻辑功能构件。</p><p>2.1.4 系统协调者 system orchestrator 大数据参考体系结构中的一种逻辑功能构件，它定义所需的数据应用活动并将它们整合到可运行的垂直系统中。</p><p>注1：系统协调者可以是人、软件或这二者。</p><p>注2：系统协调者一般包括：业务领导者、咨询师、数据科学家、信息体系结构设计师、软件体系结构设计师、安全体系结构设计师、个人信息保护体系结构设计师和网络体系结构设计师。</p><p>2.1.5 数据提供者 data provider 大数据参考体系结构中的一种逻辑功能构件，它将新的数据或信息引入大数据系统。</p><p>注：数据提供者一般包括：企业、公共机构、科学家、调研人员、从事数据搜素的工程师、网络应用软件、网络运营商和末端用户。</p><p>2.1.6 大数据应用提供者 big data application provider 大数据参考体系结构中的一种逻辑功能构件，它执行数据生存周期操作，以满足系统协调者定义的需求以及安全和隐私保护需求。</p><p>注：大数据应用提供者一般包括：应用领域专家、平台领域专家和咨询师。</p><p>2.1.7 大数据框架提供者 big data framework provider 大数据参考体系结构中的一种逻辑功能构件，它建立一种计算框架，在此框架中执行转换应用，同时保护数据完整性和隐私。</p><p>注：大数据框架提供者一般包括：内嵌数据集集群、数据中心和云提供者。</p><p>2.1.8 数据消费者 data consumer 大数据参考体系结构中的一种逻辑功能构件，它是使用大数据应用提供者提供的应用的末端用户或其他系统。</p><p>注：数据消费者一般包括：末端用户、调研人员、应用和系统。</p><p>2.1.9 基础设施框架 infrastructure framework 由网络、计算、存储和环境等功能构件构成的一种集合。</p><p>注1：网络、计算、存储和环境的解释如下：</p><p>a）网络：支持将数据从一个资源传输到另一个资源的资源（如，已定义的物理资源、软件资源、虚拟资源等）。</p><p>b）计算：执行和驻留其他大数据系统构件（如，物理资源、操作系统、虚拟实现、逻辑分布）的软件的物理处理器和存储器。</p><p>c）存储：在大数据系统中保存数据的资源（如，存储器、本地磁盘、独立磁盘的软/硬件冗余阵列、存储域网、附网存储）。</p><p>d）环境：建立大数据系统时必须考虑的物理辅助资源（如，供电、冷却等）。</p><p>注2：这是大数据框架提供者可能提供的一种框架。</p><p>2.1.10 数据平台框架 data platform framework 用于指导实现结合相关应用编程接口（API）访问的逻辑数据组织和分发的集合。</p><p>注1：此类框架一般还包含数据注册和连同语义数据描述（如格式化本体或分类）的元数据服务。逻辑数据组织的覆盖范围从简单限定的平面文件到完全分布式关系数据存储或分栏数据存储。</p><p>注2：这是大数据框架提供者可能提供的一种框架。</p><p>2.1.11 处理框架 processing framework 覆盖为支持大数据应用实现所需基础设施软件的、定义数据的计算和处理的集合。</p><p>注：这是大数据框架提供者可能提供的一种框架。</p><p>2.1.12 消息/通信框架 messaging/communications framework 源于高性能计算环境、为水平扩展集群中节点之间的可靠查询、传输和接收数据提供API的集合。</p><p>注：这是大数据框架提供者可能提供的一种框架。</p><p>2.1.13 资源管理框架 resource management framework 大数据框架提供者可能提供的、利用数据本地化作为一种输入变量来确定是否安装新的处理框架元素（如，主节点、处理节点、作业位置），从而实现对CPU和存储两大资源高效且有效管理的集合。</p><p>注：这是大数据框架提供者可能提供的一种框架。</p><p>2.1.14 大数据系统 big data system 实现大数据参考体系结构的全部或部分功能的系统。</p><p>2.1.15 大数据服务 big data service 基于大数据参考体系结构提供的数据服务。</p><p>2.1.16 垂直扩展 vertical scaling 为提高性能而提高处理速度、存储和内存等系统参数的过程。</p><p>2.1.17 水平扩展 horizontal scaling 将集成的一群个体资源作为一个单系统使用的过程。</p><p>2.1.18 大数据范例 big data paradigm 一种由水平耦合分布式数据系统和独立资源组成的、用于实现为有效处理众多数据集所必需的可伸缩性的知识。</p><p>2.1.19 大数据工程化 big data engineering为适应大数据对于有效存储、操作和分析的需求而运用治理独立资源的先进技术构建可伸缩数据系统的过程。</p><p>2.1.20 大规模并行处理 massively parallel processing 多个处理器并行工作以执行一个特定计算任务的过程。</p><p>2.1.21 分布式文件系统 distributed file system 多个结构化数据集分布在一个或多个服务器集群的各个计算节点的文件系统。</p><p>注：此类系统中，数据可能分布在文件和/或数据集层，更为普遍的是在数据块这个层级分布，同时支持集群中多个节点与大型文件和/或数据集的不同部分交互。</p><p>2.1.22 分布式计算 distributed computing一种覆盖存储层和处理层的、用于实现多类型程序设计算法模型的计算模式。</p><p>注：分布式计算结果通常加载到分析环境。MapReduce是数据分布式计算中默认的处理构件。</p><p>2.1.23 分散-聚集 scatter-gather 大数据集的处理形式，其中所需的计算被划分并分布在集群的多个节点上，整体结果由每个节点的结果合并而成。</p><p>注：分散-聚集通常要求对处理软件的算法进行改变。</p><p>示例：MapReduce（包含Map和Reduce两个计算过程的一种计算模型）就是采用分散聚集的处理形式。</p><p>2.1.24 流数据 streaming data 经由接口传递，从连续运行的数据源产生的数据。</p><p>2.1.25 非结构化数据 unstructured data 不具有预定义模型或未以预定义方式组织的数据。</p><p>2.1.26 大数据生存周期模型 lifecycle model for big data 用于描述大数据的“数据一信息一知识一价值”生存周期和指导大数据相关活动的模型；这些活动主要由收集、准备、分析和行动等阶段覆盖。</p><p>注：几个阶段的主要活动如下：</p><p>a）收集阶段：采集原始数据并按原始数据形式存储；</p><p>b）准备阶段：将原始数据转化为干净的、有组织的信息；</p><p>c）分析阶段：利用有组织的信息产生合成的知识；</p><p>d）行动阶段：运用合成的知识为组织生成价值。</p><p>2.1.27 读时模式 schema-on-read 一种数据模式应用；按此应用，在从数据库读取数据之前，先经过诸如转换、净化、整合之类准备步骤。</p><p>2.1.28 计算可移植性 computational portability 使计算移动到数据所在位置的能力。</p><p>2.1.29 真实性 veracity 数据在跨边界传送的情况下，与数据完整性和隐私保护相关的一种数据特征；亦简单指数据的准确性。</p><p>2.1.30 价值 value 从分析学角度考虑的数据对组织的重要性。</p><p>注：大数据应用领域越来越看重大数据带来的价值，确定数据的价值也趋向于作为大数据分祈的一个重要日标。</p><p>2.1.31 波动性 volatility 数据结构随时间变化的趋势。</p><p>注：这个术语与大数据主要特征之一的“多变性（variability）”不同，多变性主要用于表述大数据的体量、速度和多样性等特征呈现的多变性。</p><p>2.1.32 正确性 validity 就数据预期用途而言的数据适当性。</p><p>2.1.33 大数据动态应用 big data velocity application 数据的收集、准备和分析（预警）在动态改变中发生，并可能在数据存储之前进行归纳或聚合。</p><p>2.1.34 大数据卷系统 big data volume system 在数据准备阶段前以数据原始形式存储的一种数据系统。</p><p>注：在这种系统中，在数据读出时开始启动准备阶段，因此被称为“读时模式”。</p><p>2.1.35 数据仓库 data warehouse 在数据准备之后用于永久性存储数据的数据库。</p><p>2.1.36 动态数据 data in motion 处于活动状态，其典型特征表现为大数据的速度和多变性特征的数据。</p><p>注：它们在网络上传输或暂时驻留于计算机内存中供读取或更新。对它们以实时或近实时方式进行处理和分析。</p><p>2.1.37 静态数据 data at rest 处于静止状态，其典型特征表现为大数据的体量和多样性特征的数据。</p><p>注：它们通常是存储于物理媒体中的数据。</p><p>2.1.38 非关系模型 non-relational models用于数据存储和处理、不遵循关系代数的逻辑数据模型。</p><p>注：非关系模型也常称为NoSQL，通常理解为非SQL（结构化查询语言）或不仅是SQL。</p><p>2.1.39 联合数据库系统 federated database system 一种元数据库管理系统，它透明地将多个自治数据库系统映射到一个单一联合数据库。</p><p>2.1.40 数据科学 data science 根据原始数据，经过整个数据生存周期过程凭借经验合成可用于行动的知识的一种科学。</p><p>2.1.41 数据科学范例 data science paradigm 通过发现、假设和假设测试过程直接从数据萃取的可用于行动的知识。</p><p>2.1.42 数据科学家 data scientist 数据科学专业人员：他们具有足够的业务需求管理机制方面的知识、领域知识、分析技能以及用于管理数据生存周期中每个阶段的端到端数据过程的软件和系统工程知识。</p><p>2.1.43 数据治理 data governance 对数据进行处置、格式化和规范化的过程。</p><p>注1：数据治理是数据和数据系统管理的基本要素。</p><p>注2：数据治理涉及数据全生存周期管理，无论数据是处于静态、动态、未完成状态还是交易状态。</p><p>2.1.44 开放数据 open data 可为其他数据使用的数据。</p><p>2.1.45 链接数据 linked data 连接其他数据的数据。</p><p>2.1.46 数据集 data set 数据记录汇聚的数据形式。</p><p>注：它可以具有大数据的体量、速度、多样性和易变性特征。数据集的特征表征的是数据本身或静态数据，而数据的特征，当其在网络上传输时或暂时驻留于计算机存储器中以备读出或更新时，表征的是动态数据。</p><p>2.1.47 追溯provenance 对数据集的历史元数据的讨论。</p><p>注1：此词条的中文名是对同一个英文名词的动词性定义的表示。</p><p>注2：这是大数据分析中的一个必不可少的因素。</p><p>2.1.48 分析 analytics 根据信息合成知识的过程。</p><p>2.1.49 分析过程特征 analytic processes characteristics 用以表征大数据分析过程的发现、开发和应用。</p><p>“发现”是形成最初的假设性构想，“开发”是针对具体构想构建分析过程，“应用”则是将分析结果打包到特定运行的系统。</p><p>2.1.50 共享磁盘文件系统 shared-disk file systems 使用单一存储池且与多个计算资源关联的存储数据的方法。</p><p>注：此类系统的技术实现支持同时从多个节点访问许多大型数据集。</p><p>示例1：</p><p>存储域网（Storage Area Networks，简称SAN）。</p><p>示例2：</p><p>附网存储（Network Attached Storage，简称NAS）。</p><p>2.1.51 数据特征层次 data characteristic hierarchy 从不同粗细粒度表征数据特征的数据层次结构。</p><p>注：大数据的特征层级一般包括以下层级：</p><p>——数据元素；</p><p>——记录（数据元素的汇集）；</p><p>——数据集（记录的汇集）；</p><p>——多数据集（数据集的汇集）。</p><p>2.1.52 可伸缩流处理 scalable stream processing 数据存储器之间动态数据的处理形式。</p><p>注：主要用于数据的过滤、转换或路由选择。对于大数据流，流处理往往是可伸缩的，以便支持分布式处理和流水线式处理。</p><p>2.1.53 可伸缩数据存储 scalable data stores 用以支持应对数据存储无限增长的一种存储技术。</p><p>注：此类技术的运用往往伴之以容错能力，以便应对大数据系统构件的某些失效。</p><p>2.1.54 本体 ontology 在大数据语境下，它是一些约束后续各种不同层次逻辑模型的语义模型。</p><p>注：本体，从本质上看，既可以是非常概括性的，也可以是极其专门化的。</p><p>2.1.55 分类 taxonomies 在数据分析语境下表示关于数据元素关系的元数据。</p><p>注：它是实体之间的层次关系，在这种情况下，一个数据元素被分解为较小的组成部分。</p><p>2.1.56 图解模型 graphical model 一种可以呈现数据元素之间关系的大数据记录存储类型。</p><p>注：在此种模型中，数据元素是节点，关系表现为节点之间链接。</p><p>2.1.57 复杂性 complexity 在大数据语境下，复杂性是指各数据元素之间内部关系的或跨数据记录之间的一种互动关系繁简程度。</p><p>2.1.58 资源协商 resource negotiation 一种支持多租户以及要求高可用性和低延迟的环境的资源访问模式。</p><p>注：按此模式，资源管理器是若干节点管理器的集线器；各个客户（或用户）依次请求节点管理器中的应用管理器，紧接前一个请求者的后一个请求者分配到同一个或不同的节点管理器的应用管理器。根据中央处理器（CPUD和存储器可用情况为所请求的任务确定先后次序并在节点提供适当的处理资源。</p><p>2.1.59 集群管理 cluster management 在以非关系模型方式驻留数据的集群资源之间提供通信的一种机制。</p><p>2.1.60 软件定义存储 software defined storage 利用软件来确定存储器的动态层级分配的一种存储管理技术。</p><p>注：此类技术可以以较低的存储开销来维护必要的数据检索性能，常用于内存、高速缓存、固态硬盘、网络驱动等应用领域。</p><p>2.1.61 软件定义网络 software defined network；SDN 支持作为大数据关键实现的网络资源高效且有效管理的一种技术。</p><p>注：亦称虚拟网络（virtual network），与传统的用于数据、管理、I/O（输入/输出）和控制的专用物理网络链接不同，SDN包含资源池化的链接和实际交换设施，实施特定功能和特定应用的按需分配（包括传输的原始带宽、服务质量和数据路由等）。</p><p>2.1.62 网络功能虚拟化 network function virtualization 对路由器/路由选择、周界防护、远程访问鉴别以及网络流量/载荷监控等网络功能的虚拟应用实现。</p><p>注：网络功能虚拟化支持信息系统的高弹性、容错和资源管理，是应对大数据巨大数据体量下用户数据连接的峰、谷起伏问题的至关重要的应用。</p><p>2.1.63 本地虚拟化 native virtualization大数据环境下的一种虚拟化基本形式，按此种形式，在本地裸机上运行管理程序，该程序管理由操作系统和应用组成的多个虚拟机。</p><p>2.1.64 主机虚拟化 hosted virtualization大数据环境下的一种虚拟化基本形式，按此种形式，在本地裸机上运行操作系统，在驻留客户操作系统和应用的顶层运行管理程序。</p><p>2.1.65 容器式虚拟化 containerized virtualization 大数据环境下的一种虚拟化基本形式，按此种形式，在本地裸机上运行操作系统，管理程序功能嵌入操作系统中，应用在内部各个容器中运行，控制或限制对操作系统和物理机器资源的访问。</p><p>2.2 密切相关的通用术语</p><p>2.2.1 数据 data 信息的可再解释的形式化表示，以适用于通信、解释或处理。</p><p>注：可以通过人工或自动手段处理数据。</p><p>[GB/T 5271.1-2000，定义01.01.02]</p><p>2.2.2 数据处理 data processing 数据操作的系统执行。</p><p>注：术语“数据处理”不能用作“信息处理”的同义词。</p><p>[GB/T 5271.1-2000，定义01.01.06]</p><p>2.2.3 数据管理 data management 在数据处理系统中，提供对数据的访问，执行或监视数据的存储，以及控制输入输出操作等功能。</p><p>[GB/T 5271.1-2000，定义01.08.02]</p><p>2.2.4 关系模型 relational model 结构基于一组关系的数据模型。</p><p>示例：结构查询语言（SQL）即表示这样一种模型。</p><p>[GB/T 5271.17-2010，定义17.04.04]</p><p>2.2.5 关系数据库 relational database 数据按关系模型来组织的数据库。</p><p>[GB/T 5271.17-2010，定义17.04.05]</p><p>2.2.6 分布式数据处理 distributed data processing；DDP 将操作分散到计算机网络的各结点进行的数据处理。</p><p>注：DDP需要借助各结点之间的数据通信做到集体协作。</p><p>[GB/T 5271.18-2008，定义18.01.08]</p><p>2.2.7 元数据 metadata 关于数据或数据元素的数据（可能包括其数据描述），以及关于数据拥有权、存取路径、访问权和数据易变性的数据。</p><p>[GB/T 5271.17-2010，定义17.06.05]</p><p>2.2.8 语义元数据 semantic metadata 元数据的一个类型；给出有助于恰当理解数据元素的定义性描述的元数据，或，作为数据元素的定义的一类元数据。</p><p>2.2.9 数据挖掘 data mining 从大量的数据中通过算法搜索隐藏于其中信息的过程。</p><p>注：一般通过包括统计、在线分析处理、情报检索、机器学习、专家系统（依靠过去的经验法则）和模式识别等方法来实现。</p><p>[GB/T 33745-2017，定义2.5.3]</p><p>2.2.10 云计算 cloud computing 一种通过网络将可伸缩、弹性的共享物理和虚拟资源池以按需自服务的方式供应和管理的模式。</p><p>注：资源包括服务器、操作系统、网络、软件、应用和存储设备等。</p><p>[GB/T 32400-2015，定义3.2.5]</p><p>2.2.11 物联网 internet of things；IOT 通过感知设备，按照约定协议，连接物、人、系统和信息资源，实现对物理和虚拟世界的信息进行处理并作出反应的智能服务系统。</p><p>注：物即物理实体。</p><p>[GB/T 33745-2017，定义2.1.1]</p><p>2.2.12 数据中心 data center 由计算机场站（机房）、机房基础设施、信息系统硬件（物理和虚拟资源）、信息系统软件、信息资源（数据）和人员以及相应的规章制度组成的组织。</p><p>[GB/T 33136-2016，定义3.1.1]</p><p>2.2.13 结构化数据 structured data 一种数据表示形式，按此种形式，由数据元素汇集而成的每个记录的结构都是一致的并且可以使用关系模型予以有效描述。</p><p>2.2.14 表结构 table structure 为主体层内容提供表示语义的一种存储范例。</p><p>2.2.15 键值结构 key-value structure 一种存储范例，按此范例存储的记录由值中的关键词和一串数据组成。</p><p>注：在键值结构下，数据通过关键词检索，同时由非关系数据库软件处理对于值中的数据的访问。其作用相当于带单一索引字段和列的关系数据库表的子集和/或简化版。其变体之一是文档存储，在这种情况下，文档有多个值字段，其中任何一个都可以用作索引/关键词。</p><h1 id="2、GB-T-35589-2017-信息技术-大数据-技术参考模型"><a href="#2、GB-T-35589-2017-信息技术-大数据-技术参考模型" class="headerlink" title="2、GB/T 35589-2017 信息技术 大数据 技术参考模型"></a>2、GB/T 35589-2017 信息技术 大数据 技术参考模型</h1><h2 id="1-了解本标准的范围、术语和定义，熟悉大数据参考架构的目的、目标，熟悉大数据参考架构及其各组成部分。"><a href="#1-了解本标准的范围、术语和定义，熟悉大数据参考架构的目的、目标，熟悉大数据参考架构及其各组成部分。" class="headerlink" title="(1)了解本标准的范围、术语和定义，熟悉大数据参考架构的目的、目标，熟悉大数据参考架构及其各组成部分。"></a>(1)了解本标准的范围、术语和定义，熟悉大数据参考架构的目的、目标，熟悉大数据参考架构及其各组成部分。</h2><p>1.范围</p><p>本标准描述了大数据的参考架构，包括角色、活动和功能组件以及它们之间的关系。本标准适用于对大数据复杂操作的理解，可为大数据系列标准的制定提供基础。</p><p>2 规范性引用文件</p><p>下列文件对于本文件的应用是必不可少的。凡是注日期的引用文件，仅注日期的版本适用于本文件。凡是不注日期的引用文件，其最新版本（包括所有的修改单）适用于本文件。</p><p>GB/T35295信息技术大数据术语</p><p>3 术语和定义</p><p>GB/T35295界定的以及下列术语和定义适用于本文件。</p><p>3.1 大数据参考架构 big data reference architecture</p><p>一种用作工具以便于对大数据内在的要求、设计结构和运行进行开放性探讨的高层概念模型。</p><p>注：比较普遍认同的大数据参考架构一般包含系统协调者、数据提供者、大数据应用提供者、大数据框架提供者和数据消费者等 5 个逻辑功能构件。</p><p>3.2 系统协调者 system orchestrator</p><p>大数据参考架构中的一种逻辑功能构件，定义所需的数据应用活动并将它们整合到可运行的垂直系统中。</p><p>注：系统协调者可以是人、软件或这二者。</p><p>3.3 数据提供者 data provider</p><p>大数据参考架构中的一种逻辑功能构件，将新的数据或信息引人大数据系统 </p><p>3.4 大数据应用提供者 big data application provider</p><p>大数据参考架构中的一种逻辑功能构件，执行数据生命周期操作，以满足系统协调者定义的需求以及安全和隐私保护需求。</p><p>3.5 大数据框架提供者 big data framework provider</p><p>大数据参考架构中的一种逻辑功能构件，建立一种计算框架，在此框架中执行转换应用，同时保护数据完整性和隐私。</p><p>3.6 数据消费者 data consumer</p><p>大数据参考架构中的一种逻辑功能构件，是使用大数据应用提供者提供的应用的末端用户或其他系统。</p><p>3.7 数据科学家 data scientist</p><p>数据科学专业人员；他们具有足够的业务需求管理机制方面的知识、领域知识、分析技能以及用于管理数据生命周期中每个阶段的端到端数据过程的软件和系统工程知识。</p><p>4 缩略语</p><p>下列缩略语适用于本文件。</p><p>BDRA：大数据参考架构（Big Data Reference Architecture)</p><p>POSIX：可移植操作系统接口（Portable Operating System Interface)</p><p>5 大数据参考架构的目的和目标</p><p>本标准中的 BDRA 提供了一个体系架构，用于有效描述大数据角色、活动和功能组件。</p><p>BDRA 目的包括：</p><p>（1）为各种利益相关者提供一种交流大数据技术的通用语言；</p><p>（2）鼓励大数据实践者遵守通用标准、规范和模式；</p><p>（3）为解决相似的问题集提供一致的技术实现方法。</p><p>BDRA 的目的是为了方便对大数据复杂性操作的认识。它不代表一个特定的大数据系统的系统架构；相反，它是一种工具，使用通用的架构来描述、讨论和开发特定系统的架构。</p><p>BDRA 是一个通用的大数据系统概念模型，对于讨论大数据需求、结构和操作，它是一种有效的工具。该模型不依赖于任何特定的产品和服务供应商，也不定义规范的解决方案。</p><p>BDRA 支持以下标准化目标：</p><p>（1）一在一个与供应商和技术无关的大数据高层概念模型语境下，增进对大数据构件、处理过程及系统的理解；</p><p>（2）为政府部门、相关机构和其他用户在理解、讨论、分类和比较大数据解决方案的过程中提供技术参考</p><p>（3）促进对大数据互操作性、可移植性、可重用性和可扩展性的备选标准的分析。</p><p>6 大数据参考架构概述</p><p>本标准定义的 BDRA 为大数据标准化提供了基本参考点，为大数据系统的基本概念和原理提供了个总体架构，见图 1。</p><p><img src="/images/bigdata/1-1.png"></p><p>BDRA 围绕代表大数据价值链的两个维度组织展开：信息价值链（水平轴）和信息技术价值链（垂直轴）。信息价值链表现大数据作为一种数据科学方法对从数据到知识的处理过程中所实现的信息流价值。信息价值链的核心价值通过数据收集、预处理、分析、可视化和访问等活动实现。信息技术价值链表现大数据作为一种新兴的数据应用范式对信息技术产生的新需求所带来的价值。信息技术价值链的核心价值通过为大数据应用提供存放和运行大数据的网络、基础设施、平台、应用工具以及其他信息技术服务实现。大数据应用提供者位于两个价值链的交点上，大数据分析及其实现为两个价值链上的大数据利益相关者提供特定价值。</p><p>BDRA 提供了一个构件层级分类体系，用于描述 BDRA 中的逻辑构件以及定义逻辑构件的分类。BDRA 中的逻辑构件被划分为 3 个层级，从高到低依次为角色、活动和组件。最顶层级的逻辑构件是代表大数据系统中存在的 5 个角色，包括系统协调者、数据提供者、大数据应用提供者、大数据框架提供者、数据消费者 5 个角色。另外两个非常重要的逻辑构件是安全和隐私以及管理，它们为大数据系统的 5 个角色提供服务和功能。第二层级的逻辑构件是每个角色执行的活动。第三层级的逻辑构件是执行每个活动需要的功能组件。</p><p>该架构可以用于表示由多个大数据系统组成的堆叠式或链式系统，其中一个系统的数据消费者可以作为后面一个系统的数据提供者。</p><p>该架构持各种商业环境，包括紧密集成的企业系统和松散耦合的垂直行业，有助于理解大数据系统如何补充并有别于已有的分析、商业智能、数据库等传统的数据应用系统。</p><p>7 大数据参考架构的组成</p><p>7.1 系统协调者</p><p>系统协调者职责在于规范和集成各类所需的数据应用活动，以构建一个可运行的垂直系统。系统协调者具体功能包括：配置和管理 BDRA 中其他组件执行一个或多个工作负载，以确保各工作项能正常运行。负责为其他组件分配对应的物理或虚拟节点并对各组件的运行情况进行监控，并通过动态调配资源等方式来确保各组件的服务质量水平达到所需要求。</p><p>系统协调者的功能可由管理员、软件或二者的组合以集中式或分布式的形式实现。</p><p>7.2 数据提供者</p><p>数据提供者的职责是将数据和信息引人到大数据系统中，供大数据系统发现、访问和转换。</p><p>其具体活动包括：</p><p>（1）收集、固化数据。</p><p>（2）创建描述数据源的元数据。</p><p>（3）发布信息的可用性和访问方法。</p><p>（4）确保数据传输质量。</p><p>数据提供者和大数据应用提供者的接口涉及 3 个阶段：开始、数据传输和终止。</p><p>7.3 大数据应用提供者</p><p>7.3.1 概述</p><p>大数据应用提供者的职责是通过在数据生命周期中执行的一组特定操作，来满足由系统协调者规定的要求，以及安全性、隐私性要求。</p><p>大数据应用提供者包括收集、预处理、分析、可视化和访问 5 个活动。</p><p>7.3.2 收集</p><p>负责处理与数据提供者的接口和数据引。</p><p>7.3.3 预处理</p><p>包括数据验证、清洗、标准化、格式化和存储。</p><p>7.3.4 分析</p><p>基于数据科学家的需求或垂直应用的需求，确定处理数据的算法来产生新的分析，解决技术目标，从而实现从数据中提取知识的技术。</p><p>7.3.5 可视化</p><p>提供给最终的数据消费者处理中的数据元素和呈现分析功能的输出</p><p>7.3.6 访问</p><p>与可视化和分析功能交互，响应应用程序请求，通过使用处理和平台框架来检索数据，并响应数据消费者请求。</p><p>7.4.1 概述</p><p>大数据框架提供者的职责是为大数据应用提供者在创建具体应用时提供使用的资源和服务。 大数据框架提供者包括基础设施、平台、处理框架、信息交互/通信和资源管理5个活动。</p><p>7.4.2 基础设施</p><p>为大数据系统中的所有其他要素提供必要的资源，这些资源是由一些物理资源的组合构成，这些物 理资源可以控制/支持相似的虚拟资源。这些资源分为下面几类：</p><p>（1）网络：从一个资源向另一个资源传输数据的资源。</p><p>（2）计算：用于执行和保持其他组件的软件的实际处理器和存储器。</p><p>（3）存储：大数据系统中保存数据的资源。</p><p>（4）环境：在建立大数据实例的时候必须考虑的物理厂房资源（电力、制冷等）。</p><p>7.4.3 平台</p><p>包含逻辑数据的组织和分布，支持文件系统方式存储和索引存储方法：</p><p>（1）文件系统：实施某种级别的 POSIX 标准以获取权限，进行相关的文件操作。</p><p>（2）索引存储：无需扫描整个数据集，便可以迅速定位数据的具体要素。</p><p>7.4.4 处理框架</p><p>提供必要的基础设施软件以支持实现应用程序能够满足数据数量、速度和多样性的处理。包括批处理、流处理，以及两者的数据交换与数据操作。</p><p>7.4.5 信息交互/通信</p><p>包含点对点传输和存储转发两种通信模型。在点对点传输模型中，发送者通过信道直接将所传输的信息发送给接收者；而在后者中，发送者会将信息先发送给中间实体，然后中间实体再逐条转发给接收者。点对点传输模型还包括多播这种特殊的通信模式，在多播中，一个发送者可将信息发送给多个而不是一个接收者。</p><p>7.4.6 资源管理</p><p>计算、存储及实现两者互联互通的网络连接管理。主要目标是实现分布式的、弹性的资源调配，具体包括对存储资源的管理和对计算资源的管理。</p><p>7.5 数据消费者</p><p>通过调用大数据应用提供者提供的接口按需访问信息，与其产生可视的，事后可査的交互。</p><p>7.6 安全和隐私</p><p>在安全和隐私管理模块，通过不同的技术手段和安全措施，构建大数据平台安全防护体系，实现覆盖硬件、软件和上层应用的安全保护，从网络安全、主机安全、应用安全、数据安全四个方面来保证大数据平台的安全性：</p><p>（1）网络安全：通过网络安全技术，保证数据处理、存储安全和维护正常运行。</p><p>（2）主机安全：通过对集群内节点的操作系统安全加固等手段保证节点正常运行</p><p>（3）应用安全：具有身份鉴别和认证、用户和权限管理、数据库加固、用户口令管理、审计控制等安全措施，实施合法用户合理访问资源的安全策略。</p><p>（4）数据安全：从集群容灾、备份、数据完整性、数据分角色存储、数据访问控制等方面保证用户数据的安全。</p><p>同时应提供一个合理的灾备框架，提升灾备恢复能力，实现数据的实时异地容灾功能，跨数据中心数据备份。</p><p>隐私保护主要是在不暴露用户敏感信息的前提下进行有效的数据挖掘；根据需要保护的内容不同，可分为位置隐私保护、标识符匿名保护和连接关系匿名保护等。</p><p>7.7 管理</p><p>提供大规模集群统一的运维管理系统，能够对包括数据中心、基础硬件、平台软件和应用软件进行集中运维、统一管理，实现安装部署、参数配置、监控、告警、用户管理、权限管理、审计、服务管理、健康检査、问题定位、升级和补丁等功能。</p><p>具有自动化运维的能力，通过对多个数据中心的资源进行统一管理，合理的分配和调度业务所需要的资源，做到自动化按需分配。同时提供对多个数据中心的信息技术基础设施进行集中运维的能力，自动化监控数据中心内各种信息技术设备的事件、告警、性能，实现从业务纬度来进行运维的能力。</p><p>对主管理系统节点及所有业务组件中心管理节点实现高可靠性的双机机制，采用主备或负荷分担配置，避免单点故障场景对系统可靠性的影响。</p><h1 id="3、GB-T-37973-2019-信息安全技术-大数据安全管理指南"><a href="#3、GB-T-37973-2019-信息安全技术-大数据安全管理指南" class="headerlink" title="3、GB/T 37973-2019 信息安全技术 大数据安全管理指南"></a>3、GB/T 37973-2019 信息安全技术 大数据安全管理指南</h1><h2 id="1-了解本标准的范围、术语和定义，了解大数据安全需求、大数据分类分级、大数据活动及安全要求、大数据安全风险评估等方面的内容。"><a href="#1-了解本标准的范围、术语和定义，了解大数据安全需求、大数据分类分级、大数据活动及安全要求、大数据安全风险评估等方面的内容。" class="headerlink" title="(1)了解本标准的范围、术语和定义，了解大数据安全需求、大数据分类分级、大数据活动及安全要求、大数据安全风险评估等方面的内容。"></a>(1)了解本标准的范围、术语和定义，了解大数据安全需求、大数据分类分级、大数据活动及安全要求、大数据安全风险评估等方面的内容。</h2><p>1 范围</p><p>本标准提出了大数据安全管理基本原则，规定了大数据安全需求、数据分类分级、大数据活动的安全要求、评估大数据安全风险。</p><p>本标准适用于各类组织进行数据安全管理，也可供第三方评估机构参考。</p><p>3 术语和定义</p><p>GB/T 25069-2010、GB/T 20984-2007和GB/T 35274-2017界定的以及下列术语和定义适用于本文件。</p><p>3.1 大数据 big data</p><p>具有数量巨大、种类多样、流动速度快、特征多变等特性，并且难以用传统数据体系结构和数据处理技术进行有效组织、存储、计算、分析和管理的数据集。</p><p>3.2 组织 organization</p><p>由作用不同的个体为实施共同的业务目标而建立的结构注：组织可以是一个企业、事业单位、政府部门等。</p><p>3.3 大数据平台 big data platform</p><p>采用分布式存储和计算技术，提供大数据的访问和处理，支持大数据应用安全高效运行的软硬件集合。</p><p>3.4 大数据环境 big data environment</p><p>开展大数据活动所涉及的数据、平台、规程及人员等的要素集合。</p><p>3.5 大数据活动 big data activity</p><p>组织针对大数据开展的一组特定任务的集合。</p><p>注：大数据活动主要包括采集、存储、处理、分发、删除等活动。</p><p>6 大数据安全需求</p><p>6.1 保密性</p><p>大数据环境下的保密性需求应考虑以下几个方面：</p><p>a）数据传输的保密性，使用不同的安全协议保障数据采集、分发等操作中的传输保密要求；<br>b）数据存储的保密性，例如使用访问控制、加密机制等；<br>c）加密数据的运算，例如使用同态加密等算法；<br>d）数据汇聚时敏感性保护，例如通过数据隔离等机制确保汇聚大量数据时不暴露敏感信息；<br>e）个人信息的保护，例如通过数据匿名化使得个人信息主体无法被识别<br>f）密钥的安全，应建立适合大数据环境的密钥管理系统</p><p>6.2 完整性</p><p>大数据环境下的完整性需求应考虑以下方面：</p><p>A）数据来源验证，应确保数据来自于已认证的数据源；<br>b）数据传输完整性，应确保大数据活动中的数据传输安全；<br>c）数据计算可靠性，应确保只对数据执行了期望的计算；<br>d）数据存储完整性，应确保分布式存储的数据及其副本的完整性；<br>e）数据可审计，应建立数据的细粒度审计机制</p><p>6.3 可用性</p><p>大数据环境下的可用性需求应考虑以下方面：</p><p>a）大数据平台抗攻击能力；<br>b）基于大数据的安全分析能力，如安全情报分析、数据驱动的误用检测、安全事件检测等；<br>c）大数据平台的容灾能力</p><p>6.4 其他需求</p><p>大数据安全除了考虑信息系统的保密性、完整性和可用性，还应针对大数据的特点组织还应从大数据活动的其他方面分析安全需求，包括但不限于</p><p>a）与法律法规、国家战略、标准等的合规性<br>b）可能产生的社会和公共安全影响，与文化的包容性；<br>c）跨组织之间数据共享；<br>d）跨境数据流动；<br>e）知识产权保护及数据价值保护。</p><div class="pdfobject-container" data-target="test.pdf" data-height="500px"></div><h1 id="4、GB-T-38667-2020-信息技术-大数据-数据分类指南"><a href="#4、GB-T-38667-2020-信息技术-大数据-数据分类指南" class="headerlink" title="4、GB/T 38667-2020 信息技术 大数据 数据分类指南"></a>4、GB/T 38667-2020 信息技术 大数据 数据分类指南</h1><h2 id="1-了解本标准的范围、术语和定义，熟悉数据分类的过程，以及分类视角、分类维度和分类方法。"><a href="#1-了解本标准的范围、术语和定义，熟悉数据分类的过程，以及分类视角、分类维度和分类方法。" class="headerlink" title="(1)了解本标准的范围、术语和定义，熟悉数据分类的过程，以及分类视角、分类维度和分类方法。"></a>(1)了解本标准的范围、术语和定义，熟悉数据分类的过程，以及分类视角、分类维度和分类方法。</h2><h1 id="5、GB-T-38673-2020-信息技术-大数据-大数据系统基本要求"><a href="#5、GB-T-38673-2020-信息技术-大数据-大数据系统基本要求" class="headerlink" title="5、GB/T 38673-2020 信息技术 大数据 大数据系统基本要求"></a>5、GB/T 38673-2020 信息技术 大数据 大数据系统基本要求</h1><h2 id="1-了解本标准的范围、术语和定义，熟悉大数据系统框架、功能要求、非功能要求。"><a href="#1-了解本标准的范围、术语和定义，熟悉大数据系统框架、功能要求、非功能要求。" class="headerlink" title="(1)了解本标准的范围、术语和定义，熟悉大数据系统框架、功能要求、非功能要求。"></a>(1)了解本标准的范围、术语和定义，熟悉大数据系统框架、功能要求、非功能要求。</h2>]]></content>
      
      
      <categories>
          
          <category> 大数据分析应用-中级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据-相关标准 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发管理（二）配置管理与文档管理</title>
      <link href="/2021/10/09/%E8%BD%AF%E8%80%83/13%E3%80%81%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86/%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E4%B8%8E%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86/"/>
      <url>/2021/10/09/%E8%BD%AF%E8%80%83/13%E3%80%81%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86/%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E4%B8%8E%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>随着软件规模和复杂性的增大，许多大型开发项目往往都会延迟和超出预算，软件开发 不得不直面越来越多的问题，表现为开发的环境日益复杂，代码共享日益困难，需跨越的平 台增多;软件的重用性需要提高;软件的维护越来越困难。</p><p>软件配置管理(Software Configuration Management，SCM)，其主要作用是通过结构化的、有序化的、产品 化的管理软件工程的方法来维护产品的历史，鉴别和定位产品独有的版本，并在产品的开发 和发布阶段控制变化;通过有序管理和减少重复性工作，配置管理保证了生产的质量和效率; 它涵盖了软件生命周期的所有领域并影响所有数据和过程。</p><h1 id="一、软件配置管理的概念"><a href="#一、软件配置管理的概念" class="headerlink" title="一、软件配置管理的概念"></a>一、软件配置管理的概念</h1><p>SCM 是指在软件系统中确定和定义构件(源代码、可执行程序、文档等)，在整个生命周期中控制发布和变更，记录和报告构件的状态 和变更请求，并定义完整的、正确的系统构件的过程。</p><h2 id="在-IEEE-标准-729-1983-中，软件配置管理包括以下几个方面功能"><a href="#在-IEEE-标准-729-1983-中，软件配置管理包括以下几个方面功能" class="headerlink" title="在 IEEE 标准 729-1983 中，软件配置管理包括以下几个方面功能:"></a>在 IEEE 标准 729-1983 中，软件配置管理包括以下几个方面功能:</h2><h3 id="配置标识"><a href="#配置标识" class="headerlink" title="配置标识"></a>配置标识</h3><p>产品的结构、产品的构件及其类型，为其分配唯一的标识符，并以某种形式提供对它们的存取。</p><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><p>过建立产品基线，控制软件产品的发布和在整个软件生命周期中对软件产品的 修改。例如，它将解决哪些修改会在该产品的最新版本中实现的问题。</p><h3 id="状态统计"><a href="#状态统计" class="headerlink" title="状态统计"></a>状态统计</h3><p>记录并报告构件和修改请求的状态，并收集关于产品构件的重要统计信息。例如， 它将解决修改这个错误会影响多少个文件的问题。</p><h3 id="审计和审查"><a href="#审计和审查" class="headerlink" title="审计和审查"></a>审计和审查</h3><p>确认产品的完整性并维护构件间的一致性，即确保产品是一个严格定义的构件 集合。例如，它将解决目前发布的产品所用的文件的版本是否正确的问题。</p><h3 id="生产"><a href="#生产" class="headerlink" title="生产"></a>生产</h3><p>对产品的生产进行优化管理。它将解决最新发布的产品应由哪些版本的文件和工具来 生成的问题。</p><h3 id="过程管理"><a href="#过程管理" class="headerlink" title="过程管理"></a>过程管理</h3><p>确保软件组织的规程、方针和软件周期得以正确贯彻执行。它将解决要交付给用 户的产品是否经过测试和质量检查的问题。</p><h3 id="小组协作"><a href="#小组协作" class="headerlink" title="小组协作"></a>小组协作</h3><p>控制开发统一产品的多个开发人员之间的协作。例如，它将解决是否所有本地程 序员所做的修改都已被加入新版本的产品中的问题。</p><h2 id="而在另外一个标准-ISO9000-3-中，对软件配置管理系统做了如下要求"><a href="#而在另外一个标准-ISO9000-3-中，对软件配置管理系统做了如下要求" class="headerlink" title="而在另外一个标准 ISO9000.3 中，对软件配置管理系统做了如下要求:"></a>而在另外一个标准 ISO9000.3 中，对软件配置管理系统做了如下要求:</h2><p>唯一地标识每个软件项的版本;<br>标识共同构成一个完整产品的特定版本的每一软件项的版本;<br>控制由两个或多个独立工作的人员同时对一个给定软件项的更新;<br>按要求在一个或多个位置对复杂产品的更新进行协调;<br>标识并跟踪所有的措施和更改;<br>这些措施和更改是在从开始直到放行期间，由于更改请求或问题引起的。</p><h2 id="版本管理应完成以下主要任务"><a href="#版本管理应完成以下主要任务" class="headerlink" title="版本管理应完成以下主要任务:"></a>版本管理应完成以下主要任务:</h2><p>建立项目;<br>重构任何修订版的某一项或某一文件;<br>利用加锁技术防止覆盖;<br>当增加一个修订版时要求输入变更描述;<br>提供比较任意两个修订版的使用工具;<br>采用增量存储方式;<br>提供对修订版历史和锁定状态的报告功能;<br>提供归并功能;<br>允许在任何时候重构任何版本;<br>权限的设置;<br>晋升模型的建立;<br>提供各种报告。</p><h1 id="二、软件配置管理的解决方案"><a href="#二、软件配置管理的解决方案" class="headerlink" title="二、软件配置管理的解决方案"></a>二、软件配置管理的解决方案</h1><p>常用的软件配置管理工具，主要有如下产品:Rational ClearCase，Merant PVCS， Microsoft VSS，CVS。</p><h1 id="三、软件文档管理"><a href="#三、软件文档管理" class="headerlink" title="三、软件文档管理"></a>三、软件文档管理</h1><h2 id="1-软件文档的作用"><a href="#1-软件文档的作用" class="headerlink" title="1.软件文档的作用"></a>1.软件文档的作用</h2><p>(1)管理依据。<br>(2)任务之间联系的凭证。<br>(3)质量保证。<br>(4)培训与参考。<br>(5)软件维护支持。<br>(6)历史档案。<br>(7)销售可能。</p><h2 id="2-文档的归类"><a href="#2-文档的归类" class="headerlink" title="2.文档的归类"></a>2.文档的归类</h2><p>软件文档大致可分为 3 类:开发文档;管理文档;产品文档。</p><h3 id="1-开发文档。"><a href="#1-开发文档。" class="headerlink" title="(1)开发文档。"></a>(1)开发文档。</h3><p>软件需求、软件设计、软件测试、保证软件质量的一类文档</p><h3 id="2-产品文档。"><a href="#2-产品文档。" class="headerlink" title="(2)产品文档。"></a>(2)产品文档。</h3><p>关于软件产品的使用、维护、增强、转换和传输的信息。</p><h3 id="3-管理文档。"><a href="#3-管理文档。" class="headerlink" title="(3)管理文档。"></a>(3)管理文档。</h3><p>项目开发计划、测试计划;<br>开发过程的每个阶段的进度和进度变更的记录;<br>软件变更情况的记录;<br>相对于开发的判定记录;<br>开发人员职责定义;<br>测试报告、开发进度月报;<br>项目开发总结等。</p><p>内部文档包括项目开发计划、需求分析、架构设计说明、详细设计说明、构件索引、构件成分说明、构件接口及调用说明、构件索引、构件接口及调用说明、类索引、类属性及方法说明、测试报告、测试 统计报告、质量监督报告、源代码、文档分类版本索引和软件安装打包文件等。</p><p>外部文档主要包括软件安装手册、软件操作手册、在线帮助、系统性能指标报告和系统操作索引等。</p><h2 id="3-文档编制计划"><a href="#3-文档编制计划" class="headerlink" title="3.文档编制计划"></a>3.文档编制计划</h2><p>文档计划一般包括以下几方面内容:<br>列出应编制文档的目录;<br>提示编制文档应参考的标准;<br>指定文档管理员;<br>提供编制文档所需要的条件，落实文档编写人员、所需经费及编制工具等;<br>明确保证文档质量的方法，为了确保文档内容的正确性、合理性，应采取一定的措施，如评审、鉴定等;<br>绘制进度表，以图表形式列出在软件生存期各阶段应产生的文档、编制人员、编制日期、完成日期、评审日期等。<br>要编制哪几种文档，详细程度如何;<br>各文档的编制负责人和进度要求;<br>审查/批准负责人和时间进度安排;<br>在开发时期内各文档的维护、修改和管理的负责人，以及批准手续。</p><h2 id="4-对文档质量的要求"><a href="#4-对文档质量的要求" class="headerlink" title="4.对文档质量的要求"></a>4.对文档质量的要求</h2><p>好的软件文档要求具备如下特征：</p><h3 id="1-针对性。"><a href="#1-针对性。" class="headerlink" title="(1)针对性。"></a>(1)针对性。</h3><p>文档编制前应分清读者对象。对不同的类型、不同层次的读者，决定如何满足适应他们的需要。<br>管理文档主要面向管理人员。<br>用户文档主要面向用户。</p><h3 id="2-精确性。"><a href="#2-精确性。" class="headerlink" title="(2)精确性。"></a>(2)精确性。</h3><p>文档的行文应当十分确切，不能出现多义性的描述。同一课题几个文档 的内容应当是协调一致、没有矛盾的。</p><h3 id="3-清晰性。"><a href="#3-清晰性。" class="headerlink" title="(3)清晰性。"></a>(3)清晰性。</h3><p>文档编写应力求简明，如有可能，配以适当的图表，以增强其清晰性。</p><h3 id="4-完整性。"><a href="#4-完整性。" class="headerlink" title="(4)完整性。"></a>(4)完整性。</h3><p>任何一个文档都应当是完整的、独立的，它应自成体系。</p><h3 id="5-灵活性。"><a href="#5-灵活性。" class="headerlink" title="(5)灵活性。"></a>(5)灵活性。</h3><p>各个不同软件项目，其规模和复杂程度有着许多实际差别，不能相同看 待。应根据具体的软件开发项目，决定编制的文档种类。</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-开发管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发管理（一）项目的范围、时间与成本</title>
      <link href="/2021/10/09/%E8%BD%AF%E8%80%83/13%E3%80%81%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86/%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%8C%83%E5%9B%B4%E3%80%81%E6%97%B6%E9%97%B4%E4%B8%8E%E6%88%90%E6%9C%AC/"/>
      <url>/2021/10/09/%E8%BD%AF%E8%80%83/13%E3%80%81%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86/%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%8C%83%E5%9B%B4%E3%80%81%E6%97%B6%E9%97%B4%E4%B8%8E%E6%88%90%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>一般的项目管理可以分为范围管理、时间管理、费用管理、质量管理、人力资源管理、沟通管理、风险管理、采购管理和整体管理 9 个知识领域。</p><p>对于软件的开发管理来讲，软件范围管理、软件进度管理、软件成本管理、软件配置管理(属于整体管理)、软件质量管理、软件风险管理、开发人员管理(属于人力资源管理)7 个方面的管理尤为重要</p><h1 id="一、项目范围管理"><a href="#一、项目范围管理" class="headerlink" title="一、项目范围管理"></a>一、项目范围管理</h1><p>目的是控制项目的全部活动都在需求范围内，以确保项目资源的高效利用。</p><p>它主要包括项目启动、范围计划编制、范围定义、范围核实和范围变更控制 5 个部分的内容。</p><p>当范围定义不明确时，不可避免的变更会使最终 项目成本大大超出预算，因为这些不可避免的变更会破坏项目节奏，导致返工、增加项目历 时、降低生产率和工作人员的士气。</p><h1 id="二、项目成本管理"><a href="#二、项目成本管理" class="headerlink" title="二、项目成本管理"></a>二、项目成本管理</h1><p>软件项目的成本不仅包括开发成本，也包括开发之前立项阶段及软件在运行中的费用。此外，操作者的培训费用和项目所使用的各种硬件设施费用也都是整个项目成本的一部分，这些成本都需要很好地计划和控制。</p><p>项目成本管理包括资源计划编制、成本估算、成本预算、成本控制 4 个主要部分内容。</p><h1 id="三、项目时间管理"><a href="#三、项目时间管理" class="headerlink" title="三、项目时间管理"></a>三、项目时间管理</h1><p>时间管理包括确保项目按时完成所需的各个过程。</p><p>它包括活动定义、活动排序、活动历时估算、进度计划编制、进度控制 5 个部分内容。</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-开发管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发管理（三）软件需求管理</title>
      <link href="/2021/10/09/%E8%BD%AF%E8%80%83/13%E3%80%81%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86/%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E7%AE%A1%E7%90%86/"/>
      <url>/2021/10/09/%E8%BD%AF%E8%80%83/13%E3%80%81%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86/%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="需求变更"><a href="#需求变更" class="headerlink" title="需求变更"></a>需求变更</h1><p>进行需求变更控制的主要依据是项目计划、变更请求和反映项目执行状况的绩效报告。</p><p>为保证项目变更的规范性和项目的有效实施，通常软件开发机构会采取如下措施。</p><h2 id="1-项目启动阶段的变更预防。"><a href="#1-项目启动阶段的变更预防。" class="headerlink" title="(1)项目启动阶段的变更预防。"></a>(1)项目启动阶段的变更预防。</h2><p>基准文件定义的范围越详细、清晰，用户跟项目经理的分歧就越少。<br>如果需求做得好，文档清晰且有客户签字，那么后期客户提出的变更超出了合同范围，就需要另外处理。</p><h2 id="2-项目实施阶段的需求变更。"><a href="#2-项目实施阶段的需求变更。" class="headerlink" title="(2)项目实施阶段的需求变更。"></a>(2)项目实施阶段的需求变更。</h2><p>“需求变更是必然的、可控的、有益的”</p><p>需求一定要与投入有联系，如果需求变更的成本由开发方来承担，则项目需求的变更就成为 必然了。所以，在项目的开始，无论是开发方还是出资方都要明确这一条:需求变，软件开 发的投入也要变。</p><p>需求的变更要经过出资者的认可，使需求的变更有成本的概念。这样项目实施涉及各方就能 够慎重地对待需求的变更。</p><p>小的需求变更也要经过正规的需求管理流程。在实践中，人们往往不愿意为小的需求变更去 执行正规的需求管理过程，认为降低了开发效率，浪费了时间。但正是由于这种观念才使需 求逐渐变为不可控，最终导致项目的失败。</p><h1 id="需求跟踪"><a href="#需求跟踪" class="headerlink" title="需求跟踪"></a>需求跟踪</h1><h2 id="1-确定需求变更控制过程。"><a href="#1-确定需求变更控制过程。" class="headerlink" title="(1)确定需求变更控制过程。"></a>(1)确定需求变更控制过程。</h2><p>制定一个选择、分析和决策需求变更的标准过程，所有的需求变更都需遵循此过程。</p><h2 id="2-进行需求变更影响分析。"><a href="#2-进行需求变更影响分析。" class="headerlink" title="(2)进行需求变更影响分析。"></a>(2)进行需求变更影响分析。</h2><p>评估每项需求变更，以确定它对项目计划安排和其他需求的影响，明确与变更相关的任务，并评估完成这些任务需要的工作量。通过这些分析将有助于需求变更控制部门做出更好的决策。</p><h2 id="3-建立需求基准版本和需求控制版本文档。"><a href="#3-建立需求基准版本和需求控制版本文档。" class="headerlink" title="(3)建立需求基准版本和需求控制版本文档。"></a>(3)建立需求基准版本和需求控制版本文档。</h2><p>确定需求基准，这是项目各方对需求达成一致认识时刻的一个快照，之后的需求变更遵循变更控制过程即可。每个版本的需求规格说明都必须是独立说明，以避免将底稿和基准或新旧版本相混淆。</p><h2 id="4-维护需求变更的历史记录。"><a href="#4-维护需求变更的历史记录。" class="headerlink" title="(4)维护需求变更的历史记录。"></a>(4)维护需求变更的历史记录。</h2><p>将需求变更情况写成文档，记录变更日期、原因、负责人、版本号等内容，及时通知到项目开发所涉及的人员。为了尽量减少困惑、冲突、误传，应指定专人来负责更新需求。</p><h2 id="5-跟踪每项需求的状态。"><a href="#5-跟踪每项需求的状态。" class="headerlink" title="(5)跟踪每项需求的状态。"></a>(5)跟踪每项需求的状态。</h2><p>可以把每一项需求的状态属性(如已推荐的，已通过的，已实施的，或已验证的)保存在数据库中，这样可以在任何时候得到每个状态类的需求数量。</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-开发管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发管理（四）软件开发的质量与风险</title>
      <link href="/2021/10/09/%E8%BD%AF%E8%80%83/13%E3%80%81%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86/%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86%EF%BC%88%E5%9B%9B%EF%BC%89%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84%E8%B4%A8%E9%87%8F%E4%B8%8E%E9%A3%8E%E9%99%A9/"/>
      <url>/2021/10/09/%E8%BD%AF%E8%80%83/13%E3%80%81%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86/%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86%EF%BC%88%E5%9B%9B%EF%BC%89%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84%E8%B4%A8%E9%87%8F%E4%B8%8E%E9%A3%8E%E9%99%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="一、软件质量管理"><a href="#一、软件质量管理" class="headerlink" title="一、软件质量管理"></a>一、软件质量管理</h1><p>项目质量管理包括保证项目能满足原先规定的各项要求所需要的过程。</p><p>总体管理功能中决定质量方针、目标与责任的所有活动，并通过诸如质量规划、质量保证、质量控制、质量改进等手段在质量体系内加以实施。</p><h2 id="1、质量计划"><a href="#1、质量计划" class="headerlink" title="1、质量计划"></a>1、质量计划</h2><p>判断哪些质量标准与本项目相关，并决定应如何达到这些质量标准。</p><p>在软件质量计划阶段应该完成如下活动:</p><p>1.对项目的软件质量活动做出计划。<br>2.对软件产品质量的可测量的目标及其优先级进行定义。<br>3.确定软件产品质量目标的实现过程是可量化和可管理的。<br>4.为管理软件产品的质量提供适当的资源和资金。<br>5.对实施和支持软件质量管理的人员进行实施和支持过程中所要求的培训。<br>6.对软件开发项目组和其他与软件项目有关的人员进行软件质量管理方面的培训。<br>7.按照已文档化的规程制订和维护项目的软件质量计划。<br>8.项目的软件质量管理活动要以项目的软件质量计划为基础。<br>9.在整个软件生命周期，要确定、监控和更新软件产品的质量目标。</p><h2 id="2、质量保证"><a href="#2、质量保证" class="headerlink" title="2、质量保证"></a>2、质量保证</h2><p>定期评估项目总体绩效，建立项目能达到相关质量标准的信心。</p><p>质量保证应贯穿于项目的始终，在事件驱动的基础上，对软件产品的质量进行测量、分析，并将分析结果与既定的质量标准相比较，以提供质量改进的依据。</p><p>如果属于软件外包，还需要对软件产品的定量质量目标进行合理的分工，分派给项目交付软件产品的承包商。</p><h2 id="3、质量控制"><a href="#3、质量控制" class="headerlink" title="3、质量控制"></a>3、质量控制</h2><p>监测项目的总体结果，判断它们是否符合相关质量标准，并找出如何消除不合格绩效的方法。</p><p>软件质量的控制不单单是一个软件测试问题，评审、调试和测试是保证软件质量的重要手段。</p><p>质量控制应贯穿于项目的始终。 </p><p>项目结果既包括产品结果(例如可交付成果)、也包括项目管理结果(例如成本与进度绩效)。</p><p>软件质量控制包括如下活动:<br>1.对软件产品进行测试，并将测试结果用于软件质量管理活动的状态。<br>2.高级管理者定期参与评审软件质量管理的活动。<br>3.软件项目负责人定期参与评审软件质量管理的活动。<br>4.软件质量保证评审小组负责评审软件的质量管理活动和工作产品，并填写相关报告。</p><p>评审目标包括如下部分:<br>1.发现任何形式表现的软件功能、逻辑或实现方面的错误;<br>2.通过评审验证软件的需求;<br>3.保证软件按预先定义的标准表示;<br>4.已获得的软件是以统一的形式开发的;<br>5.使项目更容易管理。</p><h1 id="二、项目风险管理"><a href="#二、项目风险管理" class="headerlink" title="二、项目风险管理"></a>二、项目风险管理</h1><p>事前控制——风险管理规划，事中控制——风险管理方法，事后控制——风险管理报告。</p><h2 id="1-项目风险管理的概念"><a href="#1-项目风险管理的概念" class="headerlink" title="1.项目风险管理的概念"></a>1.项目风险管理的概念</h2><p>(1)内部技术风险:技术变化和创新是项目风险的重要来源之一。</p><p>(2)内部非技术风险:公司的经营战略发生了变化相关的战略风险、涉及公司管理/ 项 目管理人员管理水平等的管理风险，以及与范围变更有关的风险;没有按照要求的技术性能 和质量水平完成任务的质量风险;没有在预算的时间范围内完成任务的进度风险;没有在预 算的成本范围内完成任务的成本风险。</p><p>(3)外部法律风险:包括与项目相关的规章或标准的变化，如许可权、专利、合同失效、诉讼等。</p><p>(4)外部非法律风险:主要是指项目的政治、社会影响、经济环境的变化，组织中雇佣关系的变化，如公司并购、政府干预、货币变动、通货膨胀、税收、自然灾害等。这类风险对项目的影响和项目性质的关系较大。</p><h2 id="2-风险管理的过程"><a href="#2-风险管理的过程" class="headerlink" title="2.风险管理的过程"></a>2.风险管理的过程</h2><p>1 风险管理规划，决定如何指导和规划项目的风险管理活动。<br>2 项目风险识别，找到哪些风险可能影响项目，并记录其特征。<br>3 定性风险分析，完成风险和环境的定性分析，并按其对项目目标的影响进行排序。<br>4 定量风险分析，度量风险的可能性和后果，估量其对项目目标的潜在影响。<br>5 风险应对计划，创建过程和技术来为项目目标增进机会和减小威胁。<br>6 风险监督与控制，在项目生命周期中监视现存的风险、识别新的风险、执行缓解风险计划及评估其效果。</p><h3 id="1-风险识别。"><a href="#1-风险识别。" class="headerlink" title="(1)风险识别。"></a>(1)风险识别。</h3><p><img src="/images/ruankao/8-9.png"></p><h3 id="2-风险分析。"><a href="#2-风险分析。" class="headerlink" title="(2)风险分析。"></a>(2)风险分析。</h3><h4 id="风险得失值"><a href="#风险得失值" class="headerlink" title="风险得失值:"></a>风险得失值:</h4><p>指一旦风险发生可能对项目造成的影响大小，说明可能造成的损失。如果 损失的大小不容易直接估计，可以将损失分解为更小部分再评估它们。风险得失值可用相对 数值表示，建议将损失大小折算成对计划影响的时间表示。</p><h4 id="风险概率"><a href="#风险概率" class="headerlink" title="风险概率:"></a>风险概率:</h4><p>它是风险发生可能性的百分比表示，是一种主观判断。</p><h4 id="风险值"><a href="#风险值" class="headerlink" title="风险值:"></a>风险值:</h4><p>风险值又叫风险曝光度或风险暴露，他是评估风险的重要参数，“风险值”=“风险概率” * “风险影响”。如:某一风险概率是 25%，一旦发生会导致项目计划延长 4 周，因而，风险值为25% * 4周 = 1周。</p><h3 id="3-风险应对方法。"><a href="#3-风险应对方法。" class="headerlink" title="(3)风险应对方法。"></a>(3)风险应对方法。</h3><p>制订风险应对策略主要考虑以下 4 个方面的因素:可规避性、可转移性、可缓解性、可接受性。</p><h3 id="4-风险应对计划。"><a href="#4-风险应对计划。" class="headerlink" title="(4)风险应对计划。"></a>(4)风险应对计划。</h3><h3 id="5-风险监控。"><a href="#5-风险监控。" class="headerlink" title="(5)风险监控。"></a>(5)风险监控。</h3>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-开发管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式（一）设计模式概述</title>
      <link href="/2021/10/09/%E8%BD%AF%E8%80%83/10%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/"/>
      <url>/2021/10/09/%E8%BD%AF%E8%80%83/10%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、设计模式的概念"><a href="#一、设计模式的概念" class="headerlink" title="一、设计模式的概念"></a>一、设计模式的概念</h1><p>设计模式解决的是一类问题。<br>工厂模式就是为了解决类创建的问题，<br>适配器模式则是为了解决类接口不匹配的问题。</p><p>(1)学习这些模式是一个方面，另一方面更要了解模式中的思想。<br>(2)设计模式虽然可以使设计变得更精妙，但滥用设计模式会适得其反。</p><h1 id="二、设计模式的组成"><a href="#二、设计模式的组成" class="headerlink" title="二、设计模式的组成"></a>二、设计模式的组成</h1><p>在描述一个设计模式时，至少需要包含四个方面:<br>模式名称(Pattern name)、<br>问题(Problem)、<br>解决方案(Solution)、<br>效果(Consequence)。</p><h1 id="三、GoF设计模式"><a href="#三、GoF设计模式" class="headerlink" title="三、GoF设计模式"></a>三、GoF设计模式</h1><h2 id="补充-简单工厂"><a href="#补充-简单工厂" class="headerlink" title="(补充)简单工厂"></a>(补充)简单工厂</h2><p>1、写一个工厂类，使用静态方法，根据传参来new不同的产品对象<br>2、客户端调用这个工厂类的静态方法，就可以获取想要的产品</p><h2 id="1-Factory-Method-模式。工厂模式"><a href="#1-Factory-Method-模式。工厂模式" class="headerlink" title="(1)Factory Method 模式。工厂模式"></a>(1)Factory Method 模式。工厂模式</h2><p>Factory Method 模式提供了一种延迟创建类的方法，使用 这个方法可以在运行期由子类决定创建哪一个类的实例。<br>1、写一个抽象工厂类，每个工厂实现类负责将new不同种类的产品。<br>2、客户端new不同的工厂实现类就可以获得不同的产品。</p><h2 id="2-Abstract-Factory-模式。抽象工厂模式"><a href="#2-Abstract-Factory-模式。抽象工厂模式" class="headerlink" title="(2)Abstract Factory 模式。抽象工厂模式"></a>(2)Abstract Factory 模式。抽象工厂模式</h2><p>Abstract Factory 又称为抽象工厂模式，该模式主要为解决 复杂系统中对象创建的问题。抽象工厂模式提供了一个一致的对象创建接口来创建一系列具 有相似基类或相似接口的对象。<br>1、写一个抽象工厂类，然后每个工厂实现类负责new一组不同的种类的产品。<br>2、客户端new需要某一组的产品，只需要new一个工厂即可。</p><h2 id="3-Builder-模式。建造者模式"><a href="#3-Builder-模式。建造者模式" class="headerlink" title="(3)Builder 模式。建造者模式"></a>(3)Builder 模式。建造者模式</h2><p>Builder 模式与 Abstract Factory 模式非常类似，但 Builder 模式是逐步地构造出一个复杂对象，并在最后返回对象的实例。Builder 模式可以把复杂对象的创建与表示分离，使得同样的创建过程可以创建不同的表示。<br>1、Builder：给出一个抽象接口，以规范产品对象的各个组成成分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br>2、ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。在建造过程完成后，提供产品的实例。<br>3、Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建，是一个具体的类。<br>4、Product：要创建的复杂对象类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Director &#123;</span><br><span class="line">    </span><br><span class="line">    public Product constructProduct(ConcreteBuilder concreteBuilder)&#123;</span><br><span class="line">        concreteBuilder.buildBasic();</span><br><span class="line">        concreteBuilder.buildWalls();</span><br><span class="line">        concreteBuilder.roofed();</span><br><span class="line">        return concreteBuilder.buildProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Prototype-模式。原型模式"><a href="#4-Prototype-模式。原型模式" class="headerlink" title="(4)Prototype 模式。原型模式"></a>(4)Prototype 模式。原型模式</h2><p>Prototype 模式可以根据原型实例制定创建的对象的种类，并通过深复制这个原型来创建新的对象。Prototype 模式有着同 Abstract Factory 模式和 Builder 模式相同的效果，不过当需要实例化的类是在运行期才被指定的而且要避免创建一个与产品 曾是平行的工厂类层次时，可以使用 Prototype 模式。使用 Prototype 模式可以在运行时 增加或减少原型，比 Abstract Factory 和 Builder 模式更加灵活。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Prototype pro = new Prototype();</span><br><span class="line">Prototype pro1 = (Prototype)pro.clone();</span><br></pre></td></tr></table></figure><h2 id="5-Singleton-模式。单例模式"><a href="#5-Singleton-模式。单例模式" class="headerlink" title="(5)Singleton 模式。单例模式"></a>(5)Singleton 模式。单例模式</h2><p>Singleton 模式也是一种很有代表性的模式。使用 Singleton 模式 可以保证一个类仅有一个实例，从而可以提供一个单一的全局访问点。</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>在定义类的静态私有变量同时进行实例化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance = new Singleton();  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static Singleton getInstance() &#123;  </span><br><span class="line">        return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好处：线程安全；获取实例速度快<br>缺点：类加载即初始化实例，内存浪费</p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private volatile static Singleton singleton;</span><br><span class="line">    private Singleton ()&#123;&#125;</span><br><span class="line">    public static Singleton getSingleton() &#123;</span><br><span class="line">        if (singleton == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (singleton == null) &#123;</span><br><span class="line">                    singleton = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：线程安全，进行双重检查，保证只在实例未初始化前进行同步，效率高<br>缺点：实例非空判断，耗费一定资源</p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        private static final Singleton INSTANCE = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    private Singleton ()&#123;&#125;</span><br><span class="line">    public static final Singleton getInstance() &#123;</span><br><span class="line">        return SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式利用了classloder的机制来保证初始化instance时只有一个线程，但singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。如果实例化instance很消耗资源，我们想让他延迟加载，此外，我们不希望在Singleton类加载时就实例化，因为不能确保Singleton类还可能在其他的地方被主动使用从而被加载。这个时候，这种方式相比饿汉式就显得更合理。</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    public void whateverMethod() &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：写法简单，天然线程安全，可防止反射生成实例，是Effective Java作者Josh Bloch提倡的方式。</p><h2 id="6-Adapter-模式。适配者模式"><a href="#6-Adapter-模式。适配者模式" class="headerlink" title="(6)Adapter 模式。适配者模式"></a>(6)Adapter 模式。适配者模式</h2><p>Adapter 模式可以解决系统间接口不相容的问题。通过 Adapter 可以把类的接口转化为客户程序所希望的接口，从而提高复用性。<br>实现原来的接口，方法体却是另一个对象的实现。</p><h3 id="接口适配"><a href="#接口适配" class="headerlink" title="接口适配"></a>接口适配</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">interface Mp4&#123;</span><br><span class="line">    void playMp4();</span><br><span class="line">&#125;</span><br><span class="line">interface Avi&#123;</span><br><span class="line">    void playAvi();</span><br><span class="line">&#125;</span><br><span class="line">class VideoPlayer implements Mp4&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void playMp4() &#123;</span><br><span class="line">        System.out.println(&quot;播放Mp4格式的视频文件.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class FormatFactory extends VideoPlayer  implements Avi&#123;    </span><br><span class="line">    @Override</span><br><span class="line">    public void playAvi() &#123;</span><br><span class="line">        //转换成MP4格式的视频</span><br><span class="line">        playMp4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;        </span><br><span class="line">    Mp4 mp4=new VideoPlayer();</span><br><span class="line">    mp4.playMp4();</span><br><span class="line">    Avi avi=new FormatFactory();</span><br><span class="line">    avi.playAvi();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类适配"><a href="#类适配" class="headerlink" title="类适配"></a>类适配</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class FormatFactory2 implements Rvmb&#123;</span><br><span class="line">    private Mp4 mp4;</span><br><span class="line">    public FormatFactory2(Mp4 mp4) &#123;</span><br><span class="line">        this.mp4=mp4;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void playRvmb() &#123;</span><br><span class="line">        mp4.playMp4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Rvmb rvmb=new FormatFactory2(new VideoPlayer());</span><br><span class="line">    rvmb.playRvmb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-Bridge-模式。桥接模式"><a href="#7-Bridge-模式。桥接模式" class="headerlink" title="(7)Bridge 模式。桥接模式"></a>(7)Bridge 模式。桥接模式</h2><p>Bridge 模式把类的抽象部分同实现部分相分离，这样类的抽象和实现都可以独立地变化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">interface Pen&#123;</span><br><span class="line">    void write();</span><br><span class="line">&#125;</span><br><span class="line">class RedPen implements Pen&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void write() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">abstract class  Paper&#123;</span><br><span class="line">    protected  Pen pen;</span><br><span class="line">    void setPen(Pen pen)&#123;</span><br><span class="line">        this.pen=pen;</span><br><span class="line">    &#125;   </span><br><span class="line">    abstract void writing();</span><br><span class="line">&#125;</span><br><span class="line">class ExaminationPaper extends Paper&#123;</span><br><span class="line">    @Override</span><br><span class="line">    void writing() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Paper paper=new ExaminationPaper();</span><br><span class="line">    paper.setPen(new RedPen());</span><br><span class="line">    paper.writing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-Composite-模式。复合模式"><a href="#8-Composite-模式。复合模式" class="headerlink" title="(8)Composite 模式。复合模式"></a>(8)Composite 模式。复合模式</h2><p>Composite 模式提供了一种以树形结构组合对象的方法，使用Composite 可以使单个对象和组合后的对象具有一致性以提高软件的复用性。</p><h2 id="9-Decorator-模式。装饰模式"><a href="#9-Decorator-模式。装饰模式" class="headerlink" title="(9)Decorator 模式。装饰模式"></a>(9)Decorator 模式。装饰模式</h2><p>Decorator 模式可以动态地为对象的某一个方法增加更多的功能。在很多时候，使用 Decorator 模式可以不必继承出新的子类从而维护简洁的类继承结构。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public interface Beverage&#123;&#125; // 饮料接口</span><br><span class="line">public class CoffeeBean implements Beverage&#123;&#125; // 具体被装饰的对象类</span><br><span class="line">public class Decorator implements Beverage&#123;&#125; // 装饰类</span><br><span class="line">public class Milk extends Decorator&#123; // 具体装饰类，给咖啡加入牛奶</span><br><span class="line">private String description = &quot;加了牛奶！&quot;;</span><br><span class="line">private Beverage beverage = null;</span><br><span class="line">public Milk(Beverage beverage)&#123;</span><br><span class="line">this.beverage = beverage;</span><br><span class="line">&#125;</span><br><span class="line">public String getDescription()&#123;</span><br><span class="line">return beverage.getDescription()+&quot;\n&quot;+description;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Beverage beverage = new CoffeeBean();</span><br><span class="line">    beverage = new Milk(beverage); // 给咖啡加了牛奶</span><br><span class="line">    System.out.println(beverage.getDescription());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-Facade-模式。外观模式，门面模式"><a href="#10-Facade-模式。外观模式，门面模式" class="headerlink" title="(10)Facade 模式。外观模式，门面模式"></a>(10)Facade 模式。外观模式，门面模式</h2><p>Facade 模式为一组类提供了一致的访问接口。使用 Facade 可以 封装内部具有不同接口的类，使其对外提供统一的访问方式。Facade 模式在 J2EE 系统开 发中发展为 Session Facade 模式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class FacadePattern &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Facade f = new Facade();</span><br><span class="line">        f.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Facade &#123; //外观角色</span><br><span class="line">    private SubSystem01 obj1 = new SubSystem01();</span><br><span class="line">    private SubSystem02 obj2 = new SubSystem02();</span><br><span class="line">    private SubSystem03 obj3 = new SubSystem03();</span><br><span class="line">    public void method() &#123;</span><br><span class="line">        obj1.method1();</span><br><span class="line">        obj2.method2();</span><br><span class="line">        obj3.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-Flyweight-模式。享元模式，共享元素"><a href="#11-Flyweight-模式。享元模式，共享元素" class="headerlink" title="(11)Flyweight 模式。享元模式，共享元素"></a>(11)Flyweight 模式。享元模式，共享元素</h2><p>Flyweight 模式可以共享大量的细粒度对象，从而节省创建对象 所需要分配的空间，不过在时间上的开销会变大。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Flyweight factory(int state)&#123;</span><br><span class="line">    if(map.containsKey(state))&#123;</span><br><span class="line">        return (Flyweight)map.get(state);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        map.put(state, new ConcreteFlyweight(state));</span><br><span class="line">        return (Flyweight)map.get(state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-Proxy-模式。代理模式"><a href="#12-Proxy-模式。代理模式" class="headerlink" title="(12)Proxy 模式。代理模式"></a>(12)Proxy 模式。代理模式</h2><p>Proxy 模式为对象提供了一种访问代理对象，通过对象 Proxy 可以控制客户程序的访问。例如:访问权限的控制、访问地址的控制、访问方式的控制等， 甚至可以通过 Proxy 将开销较大的访问化整为零，提高访问效率。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Customer customer=new Customer();</span><br><span class="line">customer.setCash(120000);</span><br><span class="line">BuyCarProxy buyCarProxy=new BuyCarProxy(customer);</span><br><span class="line">buyCarProxy.buyCar();</span><br></pre></td></tr></table></figure><h2 id="13-Interpreter-模式。解释器模式"><a href="#13-Interpreter-模式。解释器模式" class="headerlink" title="(13)Interpreter 模式。解释器模式"></a>(13)Interpreter 模式。解释器模式</h2><p>定义了一个解释器，来解释遵循给定语言和文法的句子。<br>只需要向计算机输入一个句子或文件，就能按照预定的文法规则来对句子或文件进行解释。<br>例如输入“1+2+3-4+1”时，将输出计算结果为3。</p><h2 id="14-Template-Method-模式。模板方法模式"><a href="#14-Template-Method-模式。模板方法模式" class="headerlink" title="(14)Template Method 模式。模板方法模式"></a>(14)Template Method 模式。模板方法模式</h2><p>定义一个操作的模板，其中的一些步骤会在子类中实现，以适应不同的情况。<br>在父类中定义处理流程的框架，在子类中实现具体的处理方式。</p><h2 id="15-Chain-of-Responsibility-模式。责任链模式"><a href="#15-Chain-of-Responsibility-模式。责任链模式" class="headerlink" title="(15)Chain of Responsibility 模式。责任链模式"></a>(15)Chain of Responsibility 模式。责任链模式</h2><p>Chain of Responsibility 模式把可以响应请求的对象 组织成一条链，并在这条对象链上传递请求，从而保证多个对象都有机会处理请求而且可以 避免请求方和相应方的耦合。</p><p>一个纯的责任链模式要求一个具体的处理者对象只能在两个行为中选择一个：一个是承担责任，二是把责任推给下家。不允许出现某一个具体处理者对象在承担了一部分责任后又把责任向下传的情况。</p><p>在一个纯的责任链模式里面，一个请求必须被某一个处理者对象所接收；在一个不纯的责任链模式里面，一个请求可以最终不被任何接收端对象所接收。纯的责任链模式的例子是不容易找到的，一般看到的例子均是不纯的责任链模式的实现。</p><h2 id="16-Command-模式。命令模式"><a href="#16-Command-模式。命令模式" class="headerlink" title="(16)Command 模式。命令模式"></a>(16)Command 模式。命令模式</h2><p>将请求封装为对象，从而增强请求的能力，如参数化、排队、 记录日志等。</p><p>Command有时也被称为事件（event）。它与“事件驱动编程”中的“事件”是一样的意思。当发生点击鼠标、按下键盘按键等事件时，我们可以先将这些事件作成实例，然后按照发生顺序放入队列中。接着，再依次去处理它们。在GUI（graphical user interface）编程中，经常需要与“事件”打交道。即为在有多个命令，并且这些命令有一定的逻辑顺序，且可能需要保存的这些命令的数据，那么可以使用Command设计模式。</p><h2 id="17-Iterator-模式。迭代器模式"><a href="#17-Iterator-模式。迭代器模式" class="headerlink" title="(17)Iterator 模式。迭代器模式"></a>(17)Iterator 模式。迭代器模式</h2><p>Iterator 模式提供了顺序访问一个对象集合中的各元素的方法， 使用 Iterator 可以避免暴露集合中对象的耦合关系。</p><h2 id="18-Mediator-模式。仲裁者模式、中介者模式"><a href="#18-Mediator-模式。仲裁者模式、中介者模式" class="headerlink" title="(18)Mediator 模式。仲裁者模式、中介者模式"></a>(18)Mediator 模式。仲裁者模式、中介者模式</h2><p>Mediator 模式可以减少系统中对象间的耦合性。Mediator 模式 使用中介对象封装其他的对象，从而使这些被封装的对象间的关系就成了松散耦合。</p><p>例如：QQ聊天</p><h2 id="19-Memento-模式。备忘录模式"><a href="#19-Memento-模式。备忘录模式" class="headerlink" title="(19)Memento 模式。备忘录模式"></a>(19)Memento 模式。备忘录模式</h2><p>Memento 模式提供了一种捕获对象状态的方法，且不会破坏对 象的封装。并且可以在对象外部保存对象的状态，并在需要的时候恢复对象状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Memento&gt; savedTimes = new ArrayList&lt;&gt;();</span><br><span class="line">    Life life = new Life();</span><br><span class="line">    life.set(&quot;3000 A.D.&quot;);</span><br><span class="line">    savedTimes.add(life.saveToMemento());</span><br><span class="line">    life.set(&quot;4000 A.D.&quot;);</span><br><span class="line">    life.restoreFromMemento(savedTimes.get(0));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="20-Observer-模式。观察者模式"><a href="#20-Observer-模式。观察者模式" class="headerlink" title="(20)Observer 模式。观察者模式"></a>(20)Observer 模式。观察者模式</h2><p>Observer 模式提供了将对象的状态广播到一组观察者的方式， 从而可以让每个观察者随时可以得到对象更新的通知。</p><h2 id="21-State-模式。状态模式"><a href="#21-State-模式。状态模式" class="headerlink" title="(21)State 模式。状态模式"></a>(21)State 模式。状态模式</h2><p>State 模式允许一个对象在其内部状态改变的时候改变它的行为。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void setState(State state) &#123;</span><br><span class="line">    System.out.println(&quot;订单信息已更新！&quot;);</span><br><span class="line">    this.state = state;</span><br><span class="line">    this.state.handle();</span><br><span class="line">&#125;</span><br><span class="line">public static  void  main(String [] args) &#123;</span><br><span class="line">    Context context = new Context();</span><br><span class="line">    context.setState(new Booked());</span><br><span class="line">    context.setState(new Payed());</span><br><span class="line">    context.setState(new Sended());</span><br><span class="line">    context.setState(new InWay());</span><br><span class="line">    context.setState(new Recieved());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="22-Strategy-模式。策略模式"><a href="#22-Strategy-模式。策略模式" class="headerlink" title="(22)Strategy 模式。策略模式"></a>(22)Strategy 模式。策略模式</h2><p>使用 Strategy 模式可以让对象中算法的变化独立于客户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">状态模式和策略模式的不同点：</span><br><span class="line">策略模式中，类的功能是根据当前条件主动更改；</span><br><span class="line">状态模式中，类的功能是被动由当前状态更改；</span><br><span class="line">策略模式中每个行为或算法之间没有关联；</span><br><span class="line">状态模式中的状态之间有关联，并且状态本身控制着状态转移；</span><br></pre></td></tr></table></figure><h2 id="23-Visitor-模式。访问者模式"><a href="#23-Visitor-模式。访问者模式" class="headerlink" title="(23)Visitor 模式。访问者模式"></a>(23)Visitor 模式。访问者模式</h2><p>表示对某对象结构中各元素的操作，使用 Visitor 模式可以在不改<br>变各元素类的前提下定义作用于这些元素的新操作。</p><p>双重分发</p><h1 id="四、其他设计模式"><a href="#四、其他设计模式" class="headerlink" title="四、其他设计模式"></a>四、其他设计模式</h1><h2 id="1-Intercepting-Filter-模式。拦截过滤器模式"><a href="#1-Intercepting-Filter-模式。拦截过滤器模式" class="headerlink" title="(1)Intercepting Filter 模式。拦截过滤器模式"></a>(1)Intercepting Filter 模式。拦截过滤器模式</h2><p>在 J2EE 的 BPS(Basic Programming System，基本编程系 统)应用框架下，在真正响应客户端请求前经常需要进行一些预处理，如客户身份验证、客 户 Session 的合法性验证、字符集转码、客户请求记录等。</p><h2 id="2-Session-Facade-模式。"><a href="#2-Session-Facade-模式。" class="headerlink" title="(2)Session Facade 模式。"></a>(2)Session Facade 模式。</h2><p>在 J2EE 开发领域，人们把Session Bean 和 Facade 模式结合起来， 封装业务逻辑的接口，形成了 Session Facade 模式。</p><h1 id="五、设计模式与软件架构"><a href="#五、设计模式与软件架构" class="headerlink" title="五、设计模式与软件架构"></a>五、设计模式与软件架构</h1><p>软件架构更倾向于从整体和全局上描述软件的组成。<br>设计模式更侧重于类与类、对象与对象之间的关系。<br>设计模式和软件架构是面向不同层次问题的解决方案。</p><h1 id="六、设计模式分类"><a href="#六、设计模式分类" class="headerlink" title="六、设计模式分类"></a>六、设计模式分类</h1><p>设计模式分为三类，分别为创建型、结构型和行为型。</p><p><img src="/images/ruankao/8-1.png"></p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式（二）设计模式及实现</title>
      <link href="/2021/10/09/%E8%BD%AF%E8%80%83/10%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
      <url>/2021/10/09/%E8%BD%AF%E8%80%83/10%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/ruankao/8-2.png"></p><p><img src="/images/ruankao/8-3.png"></p><p><img src="/images/ruankao/8-4.png"></p><p><img src="/images/ruankao/8-5.png"></p><p><img src="/images/ruankao/8-6.png"></p><p><img src="/images/ruankao/8-7.png"></p><p><img src="/images/ruankao/8-8.png"></p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式（三）设计模式总结</title>
      <link href="/2021/10/09/%E8%BD%AF%E8%80%83/10%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2021/10/09/%E8%BD%AF%E8%80%83/10%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>学习设计模式最重要的是理解，而不是生搬硬套。</p><p>不能滥用设计模式</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息系统基础知识（三）政府信息化与电子政务</title>
      <link href="/2021/10/08/%E8%BD%AF%E8%80%83/14%E3%80%81%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%89%EF%BC%89%E6%94%BF%E5%BA%9C%E4%BF%A1%E6%81%AF%E5%8C%96%E4%B8%8E%E7%94%B5%E5%AD%90%E6%94%BF%E5%8A%A1/"/>
      <url>/2021/10/08/%E8%BD%AF%E8%80%83/14%E3%80%81%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%89%EF%BC%89%E6%94%BF%E5%BA%9C%E4%BF%A1%E6%81%AF%E5%8C%96%E4%B8%8E%E7%94%B5%E5%AD%90%E6%94%BF%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>政府信息化是传统政府向信息化政府的演变过程。具体地说，政府信息化就是应用现代 信息技术、网络技术和通信技术，通过信息资源的开发和利用来集成管理和服务，从而提高 政府的工作效率、决策质量、调控能力，并节约开支，改进政府的组织结构、业务流程和工 作方式，全方位地向社会提供优质、规范、透明的管理和服务。</p><p>第一，政府信息化必须借助于信息技术和网络技术，离不开信息基础设施和软件产品;</p><p>第二，政府信息化是一个系统工程，它不仅是与行政有关部门的信息化，还包括立法、司法部门及其他一些公共组织的信息化;</p><p>第三，政府信息化并不是简单地将传统的政府管理事务原封不动地搬到互联网上，而是要对已有的组织结构和业务流程进行重组或再造。</p><p>政府信息化的主要内容是电子政务。因此，在大多数情况下，电子 政务可以作为政府信息化的同义语来使用。</p><h1 id="一、我国政府信息化的历程和策略"><a href="#一、我国政府信息化的历程和策略" class="headerlink" title="一、我国政府信息化的历程和策略"></a>一、我国政府信息化的历程和策略</h1><h2 id="20-世纪-80-年代末期“中国国家经济信息系统”的建设和运行。"><a href="#20-世纪-80-年代末期“中国国家经济信息系统”的建设和运行。" class="headerlink" title="20 世纪 80 年代末期“中国国家经济信息系统”的建设和运行。"></a>20 世纪 80 年代末期“中国国家经济信息系统”的建设和运行。</h2><p>国家经济信息系统包括着重为国家宏观经济服务的主系统，以及各部门各行业的专业经济信息系统在内的全国系统。</p><h2 id="20-世纪-90-年代"><a href="#20-世纪-90-年代" class="headerlink" title="20 世纪 90 年代"></a>20 世纪 90 年代</h2><p>一是以“金”字头为代表的多项信息工程项目取得了突破性进展。金桥、金关、金卡“三金”工程。<br>二是政府上网工程初具规模，“十二金”工程。第一类是对加强监管、提高效率和推进 公共服务起到核心作用的办公业务资源系统、宏观经济管理系统建设;第二类是增强政府收 入能力、保证公共支出合理性的金税、金关、金财、金融监管(含金卡)、金审 5 个业务系 统;第三类是保障社会秩序、为国民经济和社会发展打下坚实基础的金盾、金保、金农、金 水、金质 5 个业务系统建设。<br>三是各级政府都加强了电子政务的软件和硬件两方面的基础建设，建成了覆盖广泛的“两网、一站、四库”。“两网”是指政务内网和政务外网，两网之间物理隔离，政务外网与互联网之间逻辑隔离;“一站”，是政府门户网站;“四库”，即建立人口、法人单位、空间地理和自然资源、宏观经济 4 个基础数据库。<br>四是各地在推动政府信息化方面健康发展，并在全国普遍实行了 政府上网工程。</p><p>政府信息化的一个中心任务是实现由传统政务到电子政务的转变。</p><p>(1)做好战略数据规划。<br>(2)面向主导业务流程。<br>(3)重视资源条件。<br>(4)以人为本。<br>(5)设立 CIO。<br>(6)加强规范化和标准化。<br>(7)充分利用社会资源。</p><h1 id="二、电子政务的内容"><a href="#二、电子政务的内容" class="headerlink" title="二、电子政务的内容"></a>二、电子政务的内容</h1><h2 id="1-政府与政府-Government-To-Government"><a href="#1-政府与政府-Government-To-Government" class="headerlink" title="(1)政府与政府(Government To Government)"></a>(1)政府与政府(Government To Government)</h2><h2 id="2-政府对企业-Government-To-Business"><a href="#2-政府对企业-Government-To-Business" class="headerlink" title="(2)政府对企业(Government To Business)"></a>(2)政府对企业(Government To Business)</h2><h2 id="3-政府对公民（G2C）"><a href="#3-政府对公民（G2C）" class="headerlink" title="(3)政府对公民（G2C）"></a>(3)政府对公民（G2C）</h2><h2 id="4-企业对政府"><a href="#4-企业对政府" class="headerlink" title="(4)企业对政府"></a>(4)企业对政府</h2><h2 id="5-公民对政府"><a href="#5-公民对政府" class="headerlink" title="(5)公民对政府"></a>(5)公民对政府</h2><h2 id="6-政府对公务员（G2E）"><a href="#6-政府对公务员（G2E）" class="headerlink" title="(6)政府对公务员（G2E）"></a>(6)政府对公务员（G2E）</h2><h1 id="三、电子政务建设的过程模式和技术模式"><a href="#三、电子政务建设的过程模式和技术模式" class="headerlink" title="三、电子政务建设的过程模式和技术模式"></a>三、电子政务建设的过程模式和技术模式</h1><h2 id="1-电子政务建设的过程模式"><a href="#1-电子政务建设的过程模式" class="headerlink" title="1.电子政务建设的过程模式"></a>1.电子政务建设的过程模式</h2><p>(1)以用户为中心<br>(2)引进“客户关系管理”技术<br>(3)政府门户</p><h2 id="2-电子政务的技术模式"><a href="#2-电子政务的技术模式" class="headerlink" title="2.电子政务的技术模式"></a>2.电子政务的技术模式</h2><p>(1)网络管理模式<br>电子政务在网络管理上分为政府专网和通用网络两部分，包括专用网络、内部网络和外部网络。<br>(2)信息资源管理模式<br>电子政务可以选用的信息资 源管理模式有多种，目前主要有两种，即元数据管理模式和 XML 数据管理模式。<br>(3)应用开发模式<br>(4)电子政务的安全体系<br>电子政务的安全体系包括物理安全、网络安全、信息安全及安全管理等方面。<br>(5)电子政务的标准化<br>《国家电子政务标准化指南》共分为以下六个部分。<br>第一部分:总则。概括描述电子政务标准体系及标准化的机制。<br>第二部分:工程管理。概括描述电子政务工程管理须遵循或参考的技术要求、标准和管理规定。<br>第三部分:网络建设。概括描述网络建设须遵循或参考的技术要求、标准和管理规定。<br>第四部分:信息共享。概括描述信息共享须遵循或参考的技术要求、标准和管理规定。<br>第五部分:支撑技术。概括描述支撑技术须遵循或参考的技术要求、标准和管理规定。<br>第六部分:信息安全。概括描述保障信息安全须遵循或参考的技术要求、标准和管理规定。</p><p>六项电子政务标准分别如下:<br>1 基于 XML 电子公文格式规范第一部分:总则，第二部分:公文体;<br>2 XML 在电子政务中的应用指南;<br>3 电子政务业务流程设计方法通用规范;<br>4 信息化工程监理规范;<br>5 电子政务数据元第一部分:设计和管理规范;<br>6 电子政务主题词表编制规则。</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-信息系统基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息系统基础知识（七）业务流程重组</title>
      <link href="/2021/10/08/%E8%BD%AF%E8%80%83/14%E3%80%81%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E5%85%AD%EF%BC%89%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E9%87%8D%E7%BB%84/"/>
      <url>/2021/10/08/%E8%BD%AF%E8%80%83/14%E3%80%81%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E5%85%AD%EF%BC%89%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E9%87%8D%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>业务流程重组(BusinessProcess Reengineering，BPR)</p><h1 id="一、BPR-的内容"><a href="#一、BPR-的内容" class="headerlink" title="一、BPR 的内容"></a>一、BPR 的内容</h1><p>BPR 强调 4 个核心内容，即根本性、彻底性、戏剧性和流程。</p><h1 id="二、BPR-的作用"><a href="#二、BPR-的作用" class="headerlink" title="二、BPR 的作用"></a>二、BPR 的作用</h1><p>(1)BPR 的实施使企业更贴近市场。<br>(2)BPR 使生产成本成倍压缩。<br>(3)BPR 使产品质量得到全面提升。<br>(4)服务质量更趋完美。</p><h1 id="三、BPR-遵循的原则"><a href="#三、BPR-遵循的原则" class="headerlink" title="三、BPR 遵循的原则"></a>三、BPR 遵循的原则</h1><h2 id="1-流程中心原则"><a href="#1-流程中心原则" class="headerlink" title="(1)流程中心原则"></a>(1)流程中心原则</h2><p>BPR 注重的是业务流程整体最优，通过理顺和优化业务流程，使得业务流程 中每一个环节上的活动尽可能实现最大化增值，尽可能减少无效的或不增值的活动，并从整 体最优的目标出发，设计和优化业务流程中的各项活动，消除本位主义和利益分散主义。</p><h2 id="2-团队管理原则"><a href="#2-团队管理原则" class="headerlink" title="(2)团队管理原则"></a>(2)团队管理原则</h2><p>首先是设计、重组业 务流程，而后依据业务流程建立或改造企业组织，尽量消除或弱化“中间层”。这不仅降低 了管理费用和成本，更重要的是提高了组织的运转效率及对市场的反应速度。</p><h2 id="3-客户导向原则"><a href="#3-客户导向原则" class="headerlink" title="(3)客户导向原则"></a>(3)客户导向原则</h2><p>利用信息技术能够有效地帮助企业 BPR 得以很好地实施，采用计算机网络、数据库和多媒体等技术 建立的信息网络，能够加快信息传递，实现信息共享，其结果是将传统的串行工作方式变为 并行工作方式，将企业组织结构由垂直型变为水平型，使企业成为协同工作的组织，使得企 业的业务流程，特别是关键业务流程与市场接通，与顾客接通。<br>另一方面，科学技术的发展和管理模式的日臻完善，也为 BPR 创造了条件。</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-信息系统基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息系统基础知识（六）知识管理与商业智能</title>
      <link href="/2021/10/08/%E8%BD%AF%E8%80%83/14%E3%80%81%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%94%EF%BC%89%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86%E4%B8%8E%E5%95%86%E4%B8%9A%E6%99%BA%E8%83%BD/"/>
      <url>/2021/10/08/%E8%BD%AF%E8%80%83/14%E3%80%81%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%94%EF%BC%89%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86%E4%B8%8E%E5%95%86%E4%B8%9A%E6%99%BA%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>知识管理是企业信息化发展的高级阶段，而商业智能则是知识管理的实际应用。</p><h1 id="一、知识管理"><a href="#一、知识管理" class="headerlink" title="一、知识管理"></a>一、知识管理</h1><p>在组织中建构一个人文与技术兼备的知识系统，让组织中的信息 与知识，通过获得、创造、分享、整合、记录、存取、更新等过程，实现不断创新。同时， 这种创新知识又不断回馈到组织之内，从而使得组织的知识不间断地累积和升华，进而转化 为企业的智慧资本。</p><p>知识管理应以人为中心，以信息为基础，以知识 创新为目标，将知识看作一种可开发资源。</p><h2 id="知识管理工具的分类"><a href="#知识管理工具的分类" class="headerlink" title="知识管理工具的分类"></a>知识管理工具的分类</h2><h3 id="1-用于知识生成的工具"><a href="#1-用于知识生成的工具" class="headerlink" title="1 用于知识生成的工具"></a>1 用于知识生成的工具</h3><p>搜索引擎、数据挖掘技术、用于知识合成的工具、辅助创新知识的工具。</p><h3 id="2-用于知识编码的工具"><a href="#2-用于知识编码的工具" class="headerlink" title="2 用于知识编码的工具"></a>2 用于知识编码的工具</h3><p>知识仓库和知识地图。</p><h3 id="3-用于知识转移的工具"><a href="#3-用于知识转移的工具" class="headerlink" title="3 用于知识转移的工具"></a>3 用于知识转移的工具</h3><h1 id="二、商业智能"><a href="#二、商业智能" class="headerlink" title="二、商业智能"></a>二、商业智能</h1><p>商业智能(Business Intelligence，BI)是企业对商业数据的搜集、管理和分析的系统过 程，目的是使企业的各级决策者获得知识或洞察力，帮助他们做出对企业更有利的决策。</p><p>商业智能技术并不是基础技术或者产品技术，它是数据仓库、联机分析处理 OLAP 和数据挖掘等相关技术走向商业应用后形成的一种应用技术。</p><p>商业智能系统主要包括数据预处理、建立数据仓库、数据分析及数据展现 4 个主要阶段。</p><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>数据预处理是整合企业原始数据的第一步，它包括数据的抽取、转换和装载三个过程。</p><h2 id="建立数据仓库"><a href="#建立数据仓库" class="headerlink" title="建立数据仓库"></a>建立数据仓库</h2><p>建立数据仓库则是处理海量数据的基础。</p><h2 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h2><p>数据分析是体现系统智能的关键，一般采用联机分 析处理和数据挖掘两大技术。<br>联机分析处理不仅进行数据汇总/聚集，同时还提供切片、切块、下钻、上卷和旋转等数据分析功能，用户可以方便地对海量数据进行多维分析。<br>数据挖掘的目标则是挖掘数据背后隐藏的知识，通过关联分析、聚类和分类等方法建立分析模型，预测企业未来发展趋势和将要面临的问题。</p><h2 id="数据展现"><a href="#数据展现" class="headerlink" title="数据展现"></a>数据展现</h2><p>数据展现则主要保障系统分析结果的可视化。</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-信息系统基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于中间件的开发（一）中间件技术</title>
      <link href="/2021/10/06/%E8%BD%AF%E8%80%83/15%E3%80%81%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91/%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
      <url>/2021/10/06/%E8%BD%AF%E8%80%83/15%E3%80%81%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91/%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p>中间件(middleware)是基础软件的一大类，属于可复用软件的范畴。</p><p>中间件处在操作系统、网络和数据库之上，应用软件的下层(如图 15-1 所示)，也有人认为它应该属于操作系统中的一部分。</p><p><img src="/images/ruankao/7-1.png"></p><h1 id="中间件的概念"><a href="#中间件的概念" class="headerlink" title="中间件的概念"></a>中间件的概念</h1><p>中间件发展迅速，但在技术上还处于成长阶段，没有统一的标准和模型。</p><p>中间件要涉及软件的所有标准、规范和技术，它有更多的内涵，因为它包括平台功能，自身具有自治性、自主性、隔离性、社会化、激发性、主动性、并发性、认识能力等特性，是近似于 Agent(代理)的结构。</p><p>中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件 在不同的技术之间共享资源，中间件位于客户机服务器的操作系统之上，管理计算资源和网 络通信。这些服务程序或软件具有标准的程序接口和协议。针对不同的操作系统和硬件平台， 它们可以有符合接口和协议规范的多种实现。中间件为处于其上层的应用软件提供运行与开 发的环境，帮助用户灵活、高效地开发和集成复杂的应用软件。</p><h2 id="中间件应具有如下的一些特-点"><a href="#中间件应具有如下的一些特-点" class="headerlink" title="中间件应具有如下的一些特 点:"></a>中间件应具有如下的一些特 点:</h2><p>满足大量应用的需要;<br>运行于多种硬件和 OS 平台;<br>支持分布计算，提供跨网络、硬件和 OS 平台的透明性的应用或服务的交互;<br>支持标准的协议;<br>支持标准的接口。</p><h2 id="中间件的十大优越性"><a href="#中间件的十大优越性" class="headerlink" title="中间件的十大优越性:"></a>中间件的十大优越性:</h2><p>缩短应用的开发周期;<br>节约应用的开发成本;<br>减少系统初期的建设成本;<br>降低应用开发的失败率;<br>保护已有的投资;<br>简化应用集成;<br>减少维护费用;<br>提高应用的开发质量;<br>保证技术进步的连续性;<br>增强应用的生命力。</p><h1 id="中间件的分类"><a href="#中间件的分类" class="headerlink" title="中间件的分类"></a>中间件的分类</h1><h2 id="1-通信处理-消息-中间件"><a href="#1-通信处理-消息-中间件" class="headerlink" title="(1)通信处理(消息)中间件"></a>(1)通信处理(消息)中间件</h2><p>在分布式系统中，人们要建网和制定出通信协议，以保 证系统能在不同平台之间通信，实现分布式系统中可靠的、高效的、实时的跨平台数据传输， 这类中间件称为消息中间件。</p><h2 id="2-事务处理-交易-中间件"><a href="#2-事务处理-交易-中间件" class="headerlink" title="(2)事务处理(交易)中间件"></a>(2)事务处理(交易)中间件</h2><p>在分布式事务处理系统中， 经常要处理大量事务，特别是 OLTP 中，每项事务常常要多台服务器上的程序按顺序协调完 成，一旦中间发生某种故障，不但要完成恢复工作，而且要自动切换系统，达到系统永不停 机，实现高可靠性运行。要使大量事务在多台应用服务器上能实时并发运行，并进行负载平 衡的调度，实现与昂贵的可靠性机和大型计算机系统同等的功能，为了实现这个目标，要求 中间件系统具有监视和调度整个系统的功能。</p><h2 id="3-数据存取管理中间件"><a href="#3-数据存取管理中间件" class="headerlink" title="(3)数据存取管理中间件"></a>(3)数据存取管理中间件</h2><p>在分布式系统中，重要的数据都集中存放在数据服务器中， 它们可以是关系型的、复合文档型、具有各种存放格式的多媒体型，或者是经过加密或压缩 存放的，该中间件将为在网络上虚拟缓冲存取、格式转换、解压等带来方便。</p><h2 id="4-Web-服务器中间件"><a href="#4-Web-服务器中间件" class="headerlink" title="(4)Web 服务器中间件"></a>(4)Web 服务器中间件</h2><p>浏览器图形用户界面已成为公认规范，然而它的会话能力差、 不擅长做数据写入、受 HTTP 协议的限制等，就必须进行修改和扩充，形成了 Web 服务器 中间件。</p><h2 id="5-安全中间件"><a href="#5-安全中间件" class="headerlink" title="(5)安全中间件"></a>(5)安全中间件</h2><p>如防火墙、加密、认证等。<br>产生不安全因素是由操作系统引起的，但必须要用中间件去解决，以适应灵活多变的要求。</p><h2 id="6-跨平台和架构的中间件"><a href="#6-跨平台和架构的中间件" class="headerlink" title="(6)跨平台和架构的中间件"></a>(6)跨平台和架构的中间件</h2><p>在分布式系统中，还需要集成各节点上的不同系统平台上的构件或新老版本的构件，由此产 生了架构中间件。</p><h2 id="7-专用平台中间件"><a href="#7-专用平台中间件" class="headerlink" title="(7)专用平台中间件"></a>(7)专用平台中间件</h2><p>为特定应用领域设计领域参考模式，建立相应架构，配置相应的构件库和中间件，为应用服务器开发和运行特定领域的关键任务(如电子商务、网站等)。</p><h2 id="8-网络中间件"><a href="#8-网络中间件" class="headerlink" title="(8)网络中间件"></a>(8)网络中间件</h2><p>它包括网管、接入、网络测试、虚拟社区、虚拟缓冲等，也是当前最热门的研发项目。</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-基于中间件的开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于中间件的开发（三）J2EE</title>
      <link href="/2021/10/06/%E8%BD%AF%E8%80%83/15%E3%80%81%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91/%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89J2EE/"/>
      <url>/2021/10/06/%E8%BD%AF%E8%80%83/15%E3%80%81%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91/%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89J2EE/</url>
      
        <content type="html"><![CDATA[<p>J2EE 是针对 Web Service、业务对象、数据访问和消息报传送的一组规范。这组应用编 程接口确定了 Web 应用与驻留它们的服务器之间的通信方式。J2EE 注重两件事，一是建 立标准，使 Web 应用的部署与服务器无关;二是使服务器能控制构件的生命周期和其他资 源，以便能够处理扩展、并发、事务处理管理和安全性问题。</p><p>J2EE 规范定义了以下几种构件:应用客户端构件、EJB 构件、Servlets 和 JSP、Applet 构 件。</p><p>J2EE 采用的是多层分布式应用模型，意味着应用逻辑将根据功能分成几个部分， 用户 可以在相同或不同的服务器上安装不同应用构件组成的 J2EE 应用。</p><p><img src="/images/ruankao/7-2.png"></p><h1 id="一、表示层"><a href="#一、表示层" class="headerlink" title="一、表示层"></a>一、表示层</h1><p>J2EE 客户端可以基于 Web，也可以基于 Java。</p><p>分布式企业应用可以同时包括多种客户端，并且这些客户端都可以访问相同的业务逻辑。</p><p><img src="/images/ruankao/7-3.png"></p><h1 id="二、应用服务层"><a href="#二、应用服务层" class="headerlink" title="二、应用服务层"></a>二、应用服务层</h1><p>一般情况下，应用服务层包含表示层请求的表示逻辑和业务逻辑。</p><p>表示层由显示 HTML 页面的 JSP 页面和 Servlets 实现。<br>业务逻辑通过 RMI 对象和 EJB 实现。EJB 依靠容器来 实现事务处理、生命周期和状态管理、资源池、安全等问题，容器是 EJB 运行的环境。</p><h2 id="1-Servlet"><a href="#1-Servlet" class="headerlink" title="1.Servlet"></a>1.Servlet</h2><p>Java Servlets 是指可以扩展 Web 服务器功能的程序。Servlet 从客户端接受请求，动态 生成响应，然后将包含 HTML 或 XML 文档的请求发送给客户端。</p><h2 id="2-JSP"><a href="#2-JSP" class="headerlink" title="2.JSP"></a>2.JSP</h2><p>JSP 页面是基于文本的 Servlet 开发方式。JSP 页面具有 Servlet 的所有优点，如果与 JavaBeans 类结合在一起，可以容易地将内容和显示逻辑分开。这使得无须了解 Java 代码 就能更新页面的外观，更新 Java Beans 类的人也无须深入了解 Web 页面的设计。</p><h2 id="3-EJB"><a href="#3-EJB" class="headerlink" title="3.EJB"></a>3.EJB</h2><p>EJB 构件用于封装业务逻辑，使开发人员无须再担心数据访问、事务处理支持、安全性、 高速缓存和迸发等琐碎任务的编程。在 EJB 规范中，它们由 EJB 容器负责。EJB 包含接口 和类。</p><p>EJB 共有三种类型:EntityBean(实体 Bean)、Session Bean(会话 Bean)和 Message Driven Bean(消息驱动 Bean)</p><h2 id="4-JMS"><a href="#4-JMS" class="headerlink" title="4.JMS"></a>4.JMS</h2><p>JMS 是支持 Java 程序之间信息交换的 J2EE 机制。</p><h2 id="5-JNDI"><a href="#5-JNDI" class="headerlink" title="5.JNDI"></a>5.JNDI</h2><p>由于 J2EE 应用的构件可以独立运行，而且是在不同的设备上运行，因此客户端和应用服务器层代码必须以某种方式查找和参考其他代码和资源。客户端和应用代码使用 JNDI (Java Naming and Directory Interface，Java 命名和目录接口)查找用户定义对象(如 EJB) 和环境实体(Environment Entities)。在 JDBC2.0 中，数据源可以绑定到 JNDI 上，并允许 应用程序访问。</p><h2 id="6-事务处理"><a href="#6-事务处理" class="headerlink" title="6.事务处理"></a>6.事务处理</h2><p>J2EE 事务处理模型可以在部署过程中定义组成一个事务处理的方法之间的联系，以便 事务处理中的所有方法可以作为一个整体存在。</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-基于中间件的开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于中间件的开发（二）应用服务器技术</title>
      <link href="/2021/10/06/%E8%BD%AF%E8%80%83/15%E3%80%81%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91/%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
      <url>/2021/10/06/%E8%BD%AF%E8%80%83/15%E3%80%81%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91/%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p>Web 应用开发大致经历了三个阶段。</p><p>在第一阶段，大家都使用 Web 服务器提供的服 务器扩展接口，使用 C 或者 Perl 等语言进行开发，例如 CGI、API 等。这种方式可以让开 发者自由地处理各种不同的 Web 请求，动态地产生响应页面，实现各种复杂的 Web 系统 要求。但是，这种开发方式的主要问题是对开发者的素质要求很高，往往需要懂得底层的编 程方法，了解 HTTP 协议，此外，这种系统的调试也相当困难。</p><p>在第二阶段，大家开始使用一些服务器端的脚本语言进行开发，主要包括 ASP、PHP、 Livewire 等。其实现方法实质上是在 Web 服务器端放入一个通用的脚本语言解释器，负责 解释各种不同的脚本语言文件。</p><p>第三阶段应用服务器的方式。目前，应用服务器已经成为电子商务应用中一种非常关键的中间件技术。如今，各大主要软件厂商纷纷将应用服务器作为其电子商务平台的基础，如 IBM 的 Websphere，Oracle 的 Internet 应用服务器，Sybase 的 Enterprise 应用服务器等。本节将阐述应用服务器的概念、 相关技术及发展方向，并就目前主流的应用服务器产品进行简单的介绍。</p><h1 id="应用服务器的概念"><a href="#应用服务器的概念" class="headerlink" title="应用服务器的概念"></a>应用服务器的概念</h1><p>在分布式、多层结构及基于构件和服务器端程序设计的企业级应用开发 中，它提供的是一个开发、部署、运行和管理、维护的平台。它可以提供软件“集群” 的 功能，因而可以让多个不同的、异构服务器协同工作、相互备份，以满足企业级应用所需要 的可用性、高性能、可靠性和可伸缩性等。</p><p>应用服务 器可以帮助企业快速架构一个基 Internet 的电子商务系统，而且拥有极高的稳定性、可扩展 性和安全性。</p><p>它能够：<br>(1)更合理地分工企业级应用开发，加快应用的开发速度，减少应用的开发量。<br>(2)应用设计、开发、部署、运行、管理、维护的平台。<br>设计:应用服务器完成底层通信、服务，并屏蔽掉复杂的底层技术细节，向用户提供结 构简单、功能完善的编程接口，让用户可以专心于商务逻辑的设计。<br>开发:应用服务器提供了完全开放的编程语言和应用接口，用户可以用任何自己习惯的 开发工具来工作。另外应用服务器自己也提供快速开发的工具和手段，帮助用户提高开发效 率。<br>部署:应用服务器可以部署在任何硬件平台、任何操作系统上，而且可以分布在异构网 络中，应用服务器帮助用户在复杂的网络环境中配置系统参数，使系统发挥最大的性能，拥 有最好的稳定可靠性。<br>运行:应用服务器采用的是开放技术标准，它提供了一个完整的标准实现，即提供了系 统的运行环境，任何基于同样标准的系统都能很好地运行于这个环境中。在运行中提供应用 系统的名字解析、路由选择、负载平衡、事务控制等服务，并提供系统容错、修复、迁移、 升级扩展等功能。<br>管理:应用服务器让用户通过图形化的界面方便地管理自己的资源，而且在系统运行时 也能动态监控和管理。<br>(3)使得应用与底层平台无关，便于商业逻辑的实现与扩展。<br>(4)为企业应用提供现成的、稳定而强健的、灵活的、成熟的基础架构。</p><p>应用服务器通过分布式体系来保障这一点，表现为:<br>当系统处理能力不够时，可以通过简单地增加硬件来解决;<br>动态调整不同主机间的负载可以最大地利用系统资源，同时提高单机的稳定性;<br>当系统中的某台机器出现故障时，它的工作可由其他机器来承担，不会影响系统整体的运行， 即无单点故障。</p><h1 id="主要的应用服务器"><a href="#主要的应用服务器" class="headerlink" title="主要的应用服务器"></a>主要的应用服务器</h1><h2 id="1-BEA-WebLogic"><a href="#1-BEA-WebLogic" class="headerlink" title="1.BEA WebLogic"></a>1.BEA WebLogic</h2><h2 id="2-IBM-WebSphere"><a href="#2-IBM-WebSphere" class="headerlink" title="2.IBM WebSphere"></a>2.IBM WebSphere</h2><h2 id="3-SUN-iPlanet"><a href="#3-SUN-iPlanet" class="headerlink" title="3.SUN iPlanet"></a>3.SUN iPlanet</h2><h2 id="4-Oracle-Internet-ApplicationServer"><a href="#4-Oracle-Internet-ApplicationServer" class="headerlink" title="4.Oracle Internet ApplicationServer"></a>4.Oracle Internet ApplicationServer</h2><h2 id="5-Sybase-Enterprise-ApplicationServer"><a href="#5-Sybase-Enterprise-ApplicationServer" class="headerlink" title="5.Sybase Enterprise ApplicationServer"></a>5.Sybase Enterprise ApplicationServer</h2>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-基于中间件的开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于中间件的开发（五）企业应用集成</title>
      <link href="/2021/10/06/%E8%BD%AF%E8%80%83/15%E3%80%81%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91/%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%94%EF%BC%89%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8%E9%9B%86%E6%88%90/"/>
      <url>/2021/10/06/%E8%BD%AF%E8%80%83/15%E3%80%81%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91/%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%94%EF%BC%89%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8%E9%9B%86%E6%88%90/</url>
      
        <content type="html"><![CDATA[<p>许多企业的信息系统在最初设计时没有考虑多个系统“协同工作”的需要。</p><p>企业信息化建设缺乏一个整体规划。</p><p>企业的信息化往往是从单项业务系统开始的，不同系统的开发方式及对于 开发规范的遵从程度都有所不同，这使得系统间存在很强的孤立性，再加上对企业外部的信 息未予以足够的重视，致使各部门开发出的信息系统最终成为一个个信息孤岛，一个系统很 难与其他系统交换信息。</p><p>EAI(Enterprise ApplicationIntegration，企业应用集成)，可以在一定程度上帮助人们解决这一问题。</p><p>EAI 是指通过将业务流程，应用软件、硬件和各种标准联合起来，对企业中完 成不同业务功能的应用系统进行无缝集成，使它们像一个整体一样进行业务处理和信息共享， 从而提高企业效率，为客户提供灵活的业务服务。</p><p>EAI 可以通过中间件技术来连接企业级各种应用，使异构应用系统之间能够相互“交流” 与“协作”</p><p><img src="/images/ruankao/7-4.png"></p><h1 id="1-应用集成"><a href="#1-应用集成" class="headerlink" title="1.应用集成"></a>1.应用集成</h1><p>应用层次的集成主要为两个以上的应用中的数据和函数提供接近实时的集成。</p><p>应 用层次的集成一般来说是通过处理多个应用系统之间的消息交换，实现系统间的集成</p><h1 id="2-业务过程集成"><a href="#2-业务过程集成" class="headerlink" title="2.业务过程集成"></a>2.业务过程集成</h1><p>业务过程集成需要处理企业范围内的业务过程和把企业存在的应用系统整合到这些业 务过程中。它是一个完全的企业应用集成实现策略，因为它使企业内的一个个分离系统变成 了一个支持业务过程的连续系统，从而满足企业的整个业务过程需求。</p><h1 id="3-数据集成"><a href="#3-数据集成" class="headerlink" title="3.数据集成"></a>3.数据集成</h1><p>要完成应用集成和业务过程集成，必须首先解决数据和数据库的集成问题。</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-基于中间件的开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于中间件的开发（六）轻量级架构和重量级架构</title>
      <link href="/2021/10/06/%E8%BD%AF%E8%80%83/15%E3%80%81%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91/%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91%EF%BC%88%E5%85%AD%EF%BC%89%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%9E%B6%E6%9E%84%E5%92%8C%E9%87%8D%E9%87%8F%E7%BA%A7%E6%9E%B6%E6%9E%84/"/>
      <url>/2021/10/06/%E8%BD%AF%E8%80%83/15%E3%80%81%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91/%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91%EF%BC%88%E5%85%AD%EF%BC%89%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%9E%B6%E6%9E%84%E5%92%8C%E9%87%8D%E9%87%8F%E7%BA%A7%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>MVC 模式是一种目前广泛流行的软件设计模式，随着 J2EE 的成熟，它正成为 J2EE 平 台上推荐的一种设计模型，将业务处理与显示分离，将应用分为模型、视图及控制层，增加 了应用的可扩展性。MVC 模式为搭建具有可伸缩性、灵活性、易维护性的 Web 系统提供 了良好的机制。</p><p>轻量 级 Web 架构不仅保持了 J2EE 的优势， 还简化了 Web 的开发。目前主流的轻量级架构是把 Struts、Spring 和 Hibernate 这三种在 业内比较推崇的开源技术基于 MVC 模式相结合，这样在项目开发中不管是从效率上，费用 上，还是易维护上都能达到很好的效果。</p><h1 id="一、Struts-框架"><a href="#一、Struts-框架" class="headerlink" title="一、Struts 框架"></a>一、Struts 框架</h1><p>Struts 是一个基于 SUN J2EE 平台的 MVC 框架，主要是采用 Servlet 和 JSP 技术来实 现的。在 Struts 框架中，模型由实现业务逻辑的 JavaBean 或 EJB 构件构成，控制器由 ActionServlet 和 Action 来实现，视图由一组 JSP 文件构成</p><p><img src="/images/ruankao/7-5.png"></p><p>Struts 把 Servlet、JSP、自定义标签和信息资源整合到一个统一的框架中，开发人员利 用其进行开发时不用自己再编码实现全套 MVC 模式，极大地节省了时间。</p><p>Struts 的工作流程为:<br>首先，JSPview 发起一个以.do 表示的请求;<br>ActionForm 封装用 户请求数据，同时提供验证数据的功能;<br>ActionServlet 根据 struts-config.xml 文件来得到处 理这个请求的 Action 对象，并将请求发送给这个 Action 对象;<br>Action 对象调用 model 去 处理这个请求，将结果返回给 ActionServlet;<br>ActionServlet 决定将结果返回给对应的 view;<br>view 得到结果，并将它显示给用户。</p><h1 id="二、Spring-框架"><a href="#二、Spring-框架" class="headerlink" title="二、Spring 框架"></a>二、Spring 框架</h1><p>Spring Framework是轻量级的 J2EE 应用程序框架，旨在简化 J2EE 的开发，降低 J2EE 项目实施的难度。</p><p>框架包括声 明性事务管理，通过 RMI 或 web services 远程访问业务逻辑，mail 支持工具，以及对于 数据和数据库之间持久层的各种配置的支持。Spring 允许自由选择和组装各部分功能，还 提供和其他软件集成的接口，如与 Hibernate、Struts 的集成。</p><p>Spring 核心本身是个容器,管理物件的生命周期、物件的组态、相依注入等，并可以控 制物件在创建时是以原型(Pro-totype)或单例子(Singleton)的方式来创立。</p><p>Spring 的核心概念是控制反转(Inversionof Control，IoC)，更具体而易懂的名词是依赖 注入(Depen-dency Injection)，使用 Spring，不必自己在程序码中维护物件的依赖关系，只 需在构件中加以设定，Spring 核心容器会自动根据构件将依赖注入指定的物件。</p><p>Spring 的 目标是实现一个全方位的整合框架，在 Spring 框架下实现多个子框架的组合，这些子框架 之间可以彼此独立，也可以使用其他的框架方案加以替代，Spring 成为企业级应用程序一 站式的解决方案。</p><p><img src="/images/ruankao/7-6.png"></p><p>Spring 的核心要点是支持不绑定到特定 J2EE 服务的可重用业务和数据访问对象。 Spring 的 IoC 控件主要服务于利用类、对象和服务去组成一个企业级应用，通过规范的方 式，将各种不同的控件整合成一个完整的应用。</p><h1 id="三、Hibernate-框架"><a href="#三、Hibernate-框架" class="headerlink" title="三、Hibernate 框架"></a>三、Hibernate 框架</h1><p>Hibernate 是一种对象和关系之间映射的框架，是 Java 应用和关系数据库之间的桥梁。可以将数据库资源映射为一个或者多个 POJO。</p><p><img src="/images/ruankao/7-7.png"></p><p><img src="/images/ruankao/7-8.png"></p><h1 id="四、基于-Struts、Spring-和-Hibernate-的轻量级架构"><a href="#四、基于-Struts、Spring-和-Hibernate-的轻量级架构" class="headerlink" title="四、基于 Struts、Spring 和 Hibernate 的轻量级架构"></a>四、基于 Struts、Spring 和 Hibernate 的轻量级架构</h1><p><img src="/images/ruankao/7-9.png"></p><h2 id="1-表示层。"><a href="#1-表示层。" class="headerlink" title="(1)表示层。"></a>(1)表示层。</h2><p>由 Struts 实现，主要完成如下任务:<br>管理用户请求和响应;<br>提供一个控 制器代理以调用业务逻辑和各层的处理;<br>处理从其他层抛给 StrutsAction 的异常;<br>为显示提 供数据模型;<br>借助 Struts Validator 框架帮助完成 Web 层的验证工作。</p><h2 id="2-持久层。"><a href="#2-持久层。" class="headerlink" title="(2)持久层。"></a>(2)持久层。</h2><p>由 Hibernate 实现。它通过一个面向对象的查询语言(Hibernate Query Language，HQL)或正则表达式的 API 来检索对象的相关信息。HQL 类似于 SQL，只是把 SQL 里的表和列用对象和它的字段代替。Hibernate 还负责存储、更新、删除数据库记录。同时 Hibernate 支持大部分主流数据库，且支持父表/子表关系、事务处理、继承和多态。</p><h2 id="3-业务层。"><a href="#3-业务层。" class="headerlink" title="(3)业务层。"></a>(3)业务层。</h2><p>由 Spring 来实现。使用 Spring 的优点是:<br>利用延时注入思想组装代码， 提高了系统扩展性和灵活性，实现插件式编程。<br>利用 AOP 思想，集中处理业务逻辑，减少 重复代码，构建了较理想的解决方案。<br>利用其对 Hibernate 的会话工厂(Session Factory)、 事务管理的封装，可以更简洁地应用 Hibernate。</p><h1 id="五、轻量级架构和重量级架构的探讨"><a href="#五、轻量级架构和重量级架构的探讨" class="headerlink" title="五、轻量级架构和重量级架构的探讨"></a>五、轻量级架构和重量级架构的探讨</h1><p>重量级的开发倒并不是指 EJB 或者是 JNDI，很大意义上，重量级的开发都是需要依赖 一个非常庞大的容器系统进行开发，在 EJB 的开发中，所有开发的内容基本都需要放置在 一个容器系统中进行运行这些容器，因为基本针对大型企业应用，所以体积庞大，占用资源过 多，在开发的过程中效率很低。因为使用大型容器作为开发环境的话，很大一部分时间都用 在了配置、运行这样的过程上，有时候改动一个小小的部分，需要等很长的时间才能看到结 果。</p><p>轻量级框架的优势很大程度上是因为加速了开发的速度，不用部署一个很庞大的容器系 统就可以实现以前需要容器才能实现的功能，可以使用 Spring 代替 EJB 中的无状态的会话 Bean，可以使用 Hibernate 代替 EJB 中的实体 Bean，而且可以直接写一个应用程序运行已 经完成的系统，马上可以看到结果，做单元测试非常简单，不需要做太多的工作就可以构建 系统，这些特性对于开发人员来说非常有吸引力。</p><p>重 量级框架在大规模运行的时候会表现出非常优异的性能，劣势主要是开发效率较低，轻量级 框架正好相反，开发的时候非常迅速，但是在大规模运行的时候，性能与重量级框架相比还 是有差异的。</p><p>不管是轻量级还是重量级框 架，基本解决的是两个问题，一个是事务控制，另一个是持久化控制。</p><p>持久化的开发可以和任何框架没有关系，直接使用 JPA 的标准注解即可，所以开发持久化部分的时候可以使用 JPA 进行注解，开发时期用 Hibernate 作为 JPA 的实现进行开发测试，需要上线运行的时候就可以直接部署到 EJB 的实体 Bean 上，在 EJB 3.0 之后，已经很好进行移植部署了。关于事务控制，现在所有的实现方式都比 较简单，针对方法进行注解事务类型即可，开发的时候可以用一个转换器将这些注解转化为 Spring 的映射，快速地进行开发，在上线运行的时候，直接使用 EJB 的会话 Bean 进行部 署就可以解决，这些方式实现起来并不困难，可以很好地解决“重量级”和“轻量级”之间 的矛盾。</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-基于中间件的开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息系统基础知识（二）信息系统工程</title>
      <link href="/2021/10/06/%E8%BD%AF%E8%80%83/14%E3%80%81%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B/"/>
      <url>/2021/10/06/%E8%BD%AF%E8%80%83/14%E3%80%81%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>系统有下述特性:<br>(1)集合性。<br>(2)相关性。<br>(3)目的性。<br>(4)层次性。<br>(5)环境适应性。</p><h1 id="一、信息系统工程的概念"><a href="#一、信息系统工程的概念" class="headerlink" title="一、信息系统工程的概念"></a>一、信息系统工程的概念</h1><h2 id="系统的分类"><a href="#系统的分类" class="headerlink" title="系统的分类"></a>系统的分类</h2><p>按照系统功能划分:工业控制系统、信息管理系统、军事系统和经济系统等。<br>按照系统与外界的关系划分:封闭系统和开放系统。<br>按照系统的内部结构划分:开环系统和闭环系统等。<br>按照抽象程度将系统分为:概念系统(描述系统的主要特征和大致轮廓)、逻辑系统(脱离实现细节的合理系统)和物理系统 (实际存在的系统)。</p><p>信息系统信息系统一般泛指收集、存储、处理和传播各种信息的具备完整功能的集 合体。</p><p>系统工程是以研究大规模复杂系统为对象的一门交叉学科。它把自然科学和社会科学的 某些思想、理论、方法、策略和手段等根据总体协调的需要，有机地联系起来，应用定量和定性分析相结合的方法和计算机等技术工具，对系统的构成要素、组织结构、信息交换和反 馈控制等功能进行分析、设计、制造和服务，从而达到最优设计、最优控制和最优管理的目的。</p><p>信息系统一般泛指收集、存储、处理和传播各种信息的具备完整功能的集 合体。人们常说的信息系统大多数支持各部门和机构的管理和决策的信息系统，当前信息系 统重要的特征是计算机和互联网技术的应用。</p><p>随着网络的普及，计算机信息系统已经从管理信 息系统发展成为更强调支持企业高层领导决策的决策支持系统，即 DSS 阶段。</p><h1 id="二、信息系统工程的内容"><a href="#二、信息系统工程的内容" class="headerlink" title="二、信息系统工程的内容"></a>二、信息系统工程的内容</h1><h2 id="1-信息系统工程的体系构成"><a href="#1-信息系统工程的体系构成" class="headerlink" title="1.信息系统工程的体系构成"></a>1.信息系统工程的体系构成</h2><h3 id="（1）信息网络系统"><a href="#（1）信息网络系统" class="headerlink" title="（1）信息网络系统"></a>（1）信息网络系统</h3><p>信息网络系统是指以信息技术为主要手段建立的信息处理、传输、交换和分发的计算机网络系统。</p><h3 id="（2）信息资源系统"><a href="#（2）信息资源系统" class="headerlink" title="（2）信息资源系统"></a>（2）信息资源系统</h3><p>信息资源系统是指以信息技术为主要技术手段建立的信息资源采集、存储、处理的资源系统。</p><h3 id="（3）信息应用系统"><a href="#（3）信息应用系统" class="headerlink" title="（3）信息应用系统"></a>（3）信息应用系统</h3><p>信息应用系统是指以信息技术为主要手段建立的各类业务管理的应用系统。</p><h2 id="2-信息系统工程的技术构成"><a href="#2-信息系统工程的技术构成" class="headerlink" title="2.信息系统工程的技术构成"></a>2.信息系统工程的技术构成</h2><p>信息系统工程首要的任务是实施软件工程和信息工程。信息系统工程还应包括组织中的业务流程等内容。</p><p>软件工程是开发、运行、维护和修复软件的系统方法。</p><p>“软件”的定义为:计算机程序、方法、规则、相关的文档资料以及在计算机上运行时所必需的数据的集合。</p><p><img src="/images/ruankao/7-10.png"></p><p>信息工程的主要焦点是用计算机来存储和维护数据，而信息则是从这些数据提炼出来，来满足人们的某种需要的数据。</p><p>信息工程方法的主要特点：<br>一是以数据为中心，进一步的工作是建立主题数据库;<br>二是将工程的实施划分为对业务系统的实施和对技术系统的实施。</p><h2 id="3-组织流程管理"><a href="#3-组织流程管理" class="headerlink" title="3.组织流程管理"></a>3.组织流程管理</h2><p>有效的组织保障包括:<br>(1)建立流程管理机构，这一机构可归入管理流程之中。<br>(2)配备强有力的领导来负责内部的流程管理工作。<br>(3)制定各流程之间的动态关系规则。通过实施流程管理模式，传统组织中的组织图将不复存在，取代它的是流程管理图。</p><h2 id="4-信息系统工程的管理信息"><a href="#4-信息系统工程的管理信息" class="headerlink" title="4.信息系统工程的管理信息"></a>4.信息系统工程的管理信息</h2><p>在具体实施过程中，项目管理一般包含了以下几个方面的内容:<br>(1)任务划分。任务划分是把整个开发工作定义成一组任务的集合，这组任务又可以进一步划分成若干个子任务，进而形成具有层次结构的任务群。<br>(2)计划安排。依据划分完毕的任务即可制定出整个开发及项目管理计划，并产生完成任务的计划表。<br>(3)经费管理。经费管理在整个开发项目管理中处于重要的地位。项目经理可以运用经济杠杆来控制整个开发工作。<br>(4)审计控制。按照所采用的开发方法，应针对每一类开发人员制定出工作过程中的责任、义务、完成任务的质量标准等，按照计划对每项任务进行审计。<br>(5)风险管理。如何有效地管理和控制风险是保证系统实施成功的重要环节之一。特别是信息系统工程项目，风险管理更是重中之重。<br>(6)质量保证。质量管理应贯穿于整个项目始终。在项目规划阶段，就应该建立系统质量的度量模型和相应的机制，对项目质量提出总体的要求;在系统分析和设计阶段应对质量管理不断细化，按自顶向下的方式将总体要求划分成若干易于考核和度量的质量单元。</p><h1 id="三、信息系统工程的总体规划"><a href="#三、信息系统工程的总体规划" class="headerlink" title="三、信息系统工程的总体规划"></a>三、信息系统工程的总体规划</h1><h2 id="已经建成或正在建设的系统仍然存在一系列问题，主要如下"><a href="#已经建成或正在建设的系统仍然存在一系列问题，主要如下" class="headerlink" title="已经建成或正在建设的系统仍然存在一系列问题，主要如下:"></a>已经建成或正在建设的系统仍然存在一系列问题，主要如下:</h2><p>系统建设与组织发展的目标和战略不匹配。<br>已建成的系统解决问题的有效性低，即系统建成后对管理并无显著改善。<br>不能适应环境变化和组织变革的需要。<br>组织结构陈旧，管理落后。<br>系统使用人员的素质较低。<br>系统开发环境落后，技术方案不合理。<br>系统开发及运行维护的标准、规范混乱。<br>资源短缺，投入太少，而对系统的期望又过高。</p><h2 id="总体规划的主要任务："><a href="#总体规划的主要任务：" class="headerlink" title="总体规划的主要任务："></a>总体规划的主要任务：</h2><p>制定信息系统工程的发展战略。主要是使信息系统工程的战略与整个组织的战略和目标协调一致。<br>确定组织的主要信息需求，形成信息系统工程的总体结构方案，安排项目开发计划。<br>制定系统建设的资源分配计划，即制定为实现开发计划而需要的硬软件资源、数据通信设备、人员、技术、服务和资金等计划，提出整个系统的建设概算。</p><h2 id="总体规划的主要步骤："><a href="#总体规划的主要步骤：" class="headerlink" title="总体规划的主要步骤："></a>总体规划的主要步骤：</h2><h3 id="1-对当前系统进行初步的调查。"><a href="#1-对当前系统进行初步的调查。" class="headerlink" title="1 对当前系统进行初步的调查。"></a>1 对当前系统进行初步的调查。</h3><p>初步调查主要由两部分构成:<br>①一般调查。一般调查包括组织的概括，企业的目标，现行系统运行情况，简单历史，企业的 产品，产量，利税，体制及改革情况，人员基本情况，面临的问题，企业的中长期计划及主 要困难等，使系统分析师对企业有一个初步轮廓。<br>②信息需求初步调查。信息需求初步调查是整个初步调查的主要内容。通过调查组织系统的工作职责及活动来了解各职能机构所要处理的数据，估计各机构发生的数据量及频度。信息需求初步调查还应调查环境信息，包括内部环境和外部环境的信息。</p><h3 id="2-分析和确定系统目标。"><a href="#2-分析和确定系统目标。" class="headerlink" title="2 分析和确定系统目标。"></a>2 分析和确定系统目标。</h3><p>这实际上可以由总经理和信息系统工程开发的领导小组确定， 应包括服务的质量和范围、政策、组织及人员等。它不仅包括信息系统工程的目标，而且应 有整个企业的目标。</p><h3 id="3-分析子系统的组成及基本功能。"><a href="#3-分析子系统的组成及基本功能。" class="headerlink" title="3 分析子系统的组成及基本功能。"></a>3 分析子系统的组成及基本功能。</h3><p>从上到下对系统进行划分，并且详细说明各个子系 统应该实现的功能。</p><h3 id="4-拟定系统的实施方案。"><a href="#4-拟定系统的实施方案。" class="headerlink" title="4 拟定系统的实施方案。"></a>4 拟定系统的实施方案。</h3><p>可以对子系统的优先级进行设定，以便确定子系统的开发顺序。</p><h3 id="5-进行系统的可行性研究。"><a href="#5-进行系统的可行性研究。" class="headerlink" title="5 进行系统的可行性研究。"></a>5 进行系统的可行性研究。</h3><h3 id="6-编写可行性报告。"><a href="#6-编写可行性报告。" class="headerlink" title="6 编写可行性报告。"></a>6 编写可行性报告。</h3><h2 id="信息系统工程总体规划的目标信息"><a href="#信息系统工程总体规划的目标信息" class="headerlink" title="信息系统工程总体规划的目标信息"></a>信息系统工程总体规划的目标信息</h2><p>两个原则:<br>一是从组织的战略出发，而不是从系统的需求出发，这样就可以避免脱离组织宗旨和战略目标，走入为建设而建设的困境;<br>二是从业务的变革出发，而不是从技术的变革出发，这样有利于充分利用组织的现有资源来满足关键需求，从而避免信息系统工程无法有效地支持组织决策。</p><p>信息系统工程规划的主要目的是根据企业总体目标规划好统一的、既有集中式又有分布 式、分期逐步实现的数据平台和应用平台的建设。</p><h2 id="总体规划目标的分析过程"><a href="#总体规划目标的分析过程" class="headerlink" title="总体规划目标的分析过程"></a>总体规划目标的分析过程</h2><p>总体规划目标的分析过程包括，<code>确定组织的总体目标</code>和<code>确定信息系统工程规划的总体目标</code>两个步骤。</p><h3 id="1-确定组织的总体目标。"><a href="#1-确定组织的总体目标。" class="headerlink" title="1 确定组织的总体目标。"></a>1 确定组织的总体目标。</h3><p>它的分析的步骤是:<br>根据系统调查的结果，进行分析，归纳出现行系统中的关键问题，做出问题表。<br>根据问题表，构造目标的层次结构，即目标树。在目标树中，最上层是总目标，以下各层是 分目标或子目标，最下层是为实现目标而采取的具体措施，它是用来衡量目标是否切合实际 的标准。<br>对目标树中的各项分目标进行分析。分析各项分目标之间的关系，确定解决目标冲突的方法， 指出各项措施的考核指标。<br>将目标树按各层分目标在系统中所起的作用重新绘制。</p><h3 id="2-确定信息系统工程规划的总体目标。"><a href="#2-确定信息系统工程规划的总体目标。" class="headerlink" title="2 确定信息系统工程规划的总体目标。"></a>2 确定信息系统工程规划的总体目标。</h3><p>信息系统工程应该在下面几个方面发挥作用。<br>1、信息系统工程的辅助决策功能。<br>2、信息系统工程的辅助管理功能。<br>3、企业资源管理。</p><p>信息系统工程的总体规划包括，总体规划的层次、总体规划的任务、信息系统工程的功能范围、确定功能范围的步骤、系统总体结构分解、投资概算和总体规划的成果等内容。</p><p>总体规划的层次分为:信息战略规划、信息资源规划、信息系统工程建设规划和企业资源计划(ERP)。</p><h2 id="总体规划的任务"><a href="#总体规划的任务" class="headerlink" title="总体规划的任务"></a>总体规划的任务</h2><p>明确组织远景和使命。<br>确立组织发展战略和目标。<br>明晰组织业务及管理变革策略。<br>识别组织关键成功因素、分析关键性能指标、抽取信息需求。<br>建立总体信息工程框架。<br>提出可行性报告和总体规划方案。</p><h2 id="确定系统的功能范围的步骤如下"><a href="#确定系统的功能范围的步骤如下" class="headerlink" title="确定系统的功能范围的步骤如下:"></a>确定系统的功能范围的步骤如下:</h2><p>1 绘制出系统的总数据流程图。<br>2 根据系统方案的规定和用户的要求，结合现行系统的环境，确定系统的边界范围，并在总信息流程图上圈出。<br>3 有关人员协商讨论。<br>4 确定系统范围，并做出分析说明。</p><h2 id="信息系统工程总体规划应当包括投资概算，它包括以下-4-个方面内容。"><a href="#信息系统工程总体规划应当包括投资概算，它包括以下-4-个方面内容。" class="headerlink" title="信息系统工程总体规划应当包括投资概算，它包括以下 4 个方面内容。"></a>信息系统工程总体规划应当包括投资概算，它包括以下 4 个方面内容。</h2><p>1 计算机系统软、硬件设备投资。<br>2 系统开发费。<br>3 系统安装和维护费用。<br>4 人员培训费。</p><h1 id="四、总体规划的方法论"><a href="#四、总体规划的方法论" class="headerlink" title="四、总体规划的方法论"></a>四、总体规划的方法论</h1><p>制定信息系统工程总体规划需要有效的方法论支持，其方法多种多样，在此主要介绍较为著名的三种:业务系统规划法、关键成功因素法、战略目标集合转化法。</p><h2 id="1-业务系统规划法-Business-Systems-Planning，BSP"><a href="#1-业务系统规划法-Business-Systems-Planning，BSP" class="headerlink" title="1.业务系统规划法(Business Systems Planning，BSP)"></a>1.业务系统规划法(Business Systems Planning，BSP)</h2><h3 id="BSP的概念"><a href="#BSP的概念" class="headerlink" title="BSP的概念"></a>BSP的概念</h3><p>1 信息系统的战略应当表达出企业的各个管理层次的需求。<br>战略计划层:是决定组织目标、达到这些目标所需用的资源，以及获取、分配这些资源的策略的过程;<br>管理控制层:通过这一过程，管理者确认资源的获取及组织的目标是否有效地使用了这些资源;<br>操作控制层:保证有效率地完成具体的任务。</p><p>2 信息系统应该向整个企业提供一致的信息。<br>3 信息系统应该适应组织机构和管理体制的改变。<br>4 信息系统的战略规划，应当从总体信息系统结构中的子系统开始实现。</p><h3 id="BSP-的目标"><a href="#BSP-的目标" class="headerlink" title="BSP 的目标"></a>BSP 的目标</h3><p>BSP 的目标主要是提供信息系统规划，用以支持企业短期的和长期的信息需要。</p><p>归纳如下:<br>为管理者提供一种形式化的、客观的方法，明确建立信息系统的优先顺序，而不考虑部门的 狭隘利益，并避免主观性。<br>为具有较长生命周期系统的建设和投资提供保障。由于系统是基于业务过程的，因而不因机 构变化而失效。<br>为了以最高效率支持企业目标，BSP 提供数据处理和资源管理。<br>增加负责人的信心，使其坚信高效的信息系统能够被实施。<br>通过提供信息系统对用户需求的快速响应，从而改善信息系统管理部门和用户之间的关系。</p><p>BSP 方法的真正价值在于提供了下面的机会:<br>一是创造一种环境和提出初步行动计划，使企 业能依此对未来的系统和优先次序的改变做出反应，不致造成设计的重大失误。<br>二是定义信息系统的职能，并不断完善。</p><p>BSP 方法实施步骤：<br>1 确立项目。<br>2 工作准备。<br>3 主要活动。<br>开始。<br>定义业务过程。<br>定义数据类。<br>分析现存系统支持能力。<br>确定管理部门对系统的要求。<br>提出判断和结论。<br>定义信息总体结构。<br>确定总体结构中的优先顺序。<br>评价信息资源管理工作。<br>制定建议书和开发计划。<br>工作成果报告。</p><h2 id="2-关键成功因素法-Critical-Success-Factors，CSF"><a href="#2-关键成功因素法-Critical-Success-Factors，CSF" class="headerlink" title="2.关键成功因素法(Critical Success Factors，CSF)"></a>2.关键成功因素法(Critical Success Factors，CSF)</h2><p>该方法能够帮助组织找到影响系统成功的关键因 素，进行分析以确定组织的信息需求，从而为管理部门控制信息技术及其处理过程提供实施 指南。</p><p>CSF 的确定关键成功因素的特征如下。<br>内部 CSF:针对机构的内部活动，如改善产品质量、提高工效等。<br>外部 CSF:与机构的对外活动有关，如，满足客户企业的进入标准、获得对方的信贷。<br>监控型 CSF:对现有业务流程等进行监控，如监测零件缺陷百分比。<br>建设型 CSF:适应组织未来变化的有关活动，如改善产品组合。</p><p>CSF 共分 4 层:行业的 CSF、组织的 CSF、部门的 CSF、管理者的 CSF，它们依次相互影响。</p><p>CSF 实施步骤：<br>第一步:了解组织的战略目标。<br>第二步:识别所有成功因素。<br>第三步:确定关键成功因素。<br>第四步:识别绩效指标和标准，以及测量绩效的数据。</p><p>CSF 的优缺点：</p><p>缺点是:<br>数据的汇总和数据分析过程比较随意，缺乏一种专门严格的方法将众多个人的关键成功因素汇总成一个明确的整个组织的成功因素;<br>由于个人和组织的成功因素往往并不一致，两者之间的界限容易被混淆，从而容易使组织的成功因素具有个人倾向性;<br>由于环境和管理经常迅速变化，信息系统也必须做出相应调整，而用 CSF 法开发的系统可能无法适应变化了的环境;<br>CSF 在应用于较低层的管理时，由于不容易找到相应目标的关键成功因子及其关键指标，效率可能会比较低。</p><h2 id="3-战略目标集合转化法-Strategy-Set-Transformation，SST"><a href="#3-战略目标集合转化法-Strategy-Set-Transformation，SST" class="headerlink" title="3.战略目标集合转化法(Strategy Set Transformation，SST)"></a>3.战略目标集合转化法(Strategy Set Transformation，SST)</h2><p>战略目标集合转化法(Strategy Set Transformation，SST)将组织的战略看成一个“信息 集合”，包括使命、目标、战略和其他战略变量，如管理水平、发展趋势以及重要的环境约 束等。战略性系统规划就是把组织的战略集合转化为信息系统的战略集合，而后者由信息系 统的系统目标、环境约束和战略规划组成。</p><h3 id="该方法的步骤如下。"><a href="#该方法的步骤如下。" class="headerlink" title="该方法的步骤如下。"></a>该方法的步骤如下。</h3><h4 id="第一步-识别和阐明组织的战略集合。"><a href="#第一步-识别和阐明组织的战略集合。" class="headerlink" title="第一步:识别和阐明组织的战略集合。"></a>第一步:识别和阐明组织的战略集合。</h4><p>(1)描绘出组织各类人员结构，如卖主、经理、雇员、供应商、顾客、贷款人、政府代理人、地区社团及竞争者等。<br>(2)识别每类人员的目标。<br>(3)对于每类人员识别其使命及战略。</p><h4 id="第二步-将组织的战略集合转化为信息系统战略集合。"><a href="#第二步-将组织的战略集合转化为信息系统战略集合。" class="headerlink" title="第二步:将组织的战略集合转化为信息系统战略集合。"></a>第二步:将组织的战略集合转化为信息系统战略集合。</h4>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-信息系统基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息系统基础知识（一）信息系统概述</title>
      <link href="/2021/10/06/%E8%BD%AF%E8%80%83/14%E3%80%81%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
      <url>/2021/10/06/%E8%BD%AF%E8%80%83/14%E3%80%81%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="信息系统的数据环境"><a href="#信息系统的数据环境" class="headerlink" title="信息系统的数据环境"></a>信息系统的数据环境</h1><p>马丁在《信息工程》和《战略数据规划方法学》中将信息系统的数据环境分为 4 种类型：</p><p>第一类数据环境:数据文件。<br>第二类数据环境:应用数据库。<br>第三类数据环境:主题数据库。<br>第四类数据环境:信息检索系统。</p><h1 id="公司的管理活动"><a href="#公司的管理活动" class="headerlink" title="公司的管理活动"></a>公司的管理活动</h1><p>一个公司的管理活动可以分成 4 级:战略级、战术级、操作级和事务级。</p><p>战略级的信息系统的所有者和使用者都是企业的最高管理层，对于现代公司制企业， 就是企业的董事会和经理班子;</p><p>战术级信息系统的使用者一般是企业的中层经理及其管理的 部门;</p><p>操作级信息系统的使用者一般是服务型企业的业务部门，例如，保险企业的保单处理 部门;</p><p>事务级信息系统的使用者一般是企业的管理业务人员，例如，企业的会计、劳资员等。</p><h1 id="信息系统的生命周期"><a href="#信息系统的生命周期" class="headerlink" title="信息系统的生命周期"></a>信息系统的生命周期</h1><p>信息系统的生命周期分为 4 个阶段，即产生阶段、开发阶段、运行阶段和 消亡阶段。</p><p>1.信息系统的产生阶段又分为 概念产生过程和需求分析过程。</p><p>2.信息系统的开发阶段 可分为 5 个阶段，即，总体规划、系统分析、系统设计、系统实施和系统验收阶段。</p><p>3.信息系统的运行阶段<br>四种类型：排错性维护、适应性维护、完善性维护和预防性维护。</p><p>4.信息系统的消亡阶段</p><h1 id="信息系统建设的原则"><a href="#信息系统建设的原则" class="headerlink" title="信息系统建设的原则"></a>信息系统建设的原则</h1><p>1.高层管理人员介入原则<br>2.用户参与开发原则<br>3.自顶向下规划原则<br>4.工程化原则<br>5.其他原则<br>创新性原则，用来体现信息系统的先进性。<br>整体性原则，用来体现信息系统的完整性。<br>发展性原则，用来体现信息系统的超前性。<br>经济性原则，用来体现信息系统的实用性。</p><h1 id="信息系统开发方法"><a href="#信息系统开发方法" class="headerlink" title="信息系统开发方法"></a>信息系统开发方法</h1><p>1.结构化方法<br>2.原型法<br>3.面向对象方法<br>4.面向服务的方法</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-信息系统基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息系统基础知识（四）企业信息化与电子商务</title>
      <link href="/2021/10/06/%E8%BD%AF%E8%80%83/14%E3%80%81%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E5%9B%9B%EF%BC%89%E4%BC%81%E4%B8%9A%E4%BF%A1%E6%81%AF%E5%8C%96%E4%B8%8E%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1/"/>
      <url>/2021/10/06/%E8%BD%AF%E8%80%83/14%E3%80%81%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E5%9B%9B%EF%BC%89%E4%BC%81%E4%B8%9A%E4%BF%A1%E6%81%AF%E5%8C%96%E4%B8%8E%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、企业信息化概述"><a href="#一、企业信息化概述" class="headerlink" title="一、企业信息化概述"></a>一、企业信息化概述</h1><h2 id="1-企业信息化的目的"><a href="#1-企业信息化的目的" class="headerlink" title="1.企业信息化的目的"></a>1.企业信息化的目的</h2><p>企业信息化的目的就是要建立一个整体上相当于<br>人的神经系统的数字神经系统。使得企业具有平稳和有效的运作能力， 对紧急情况和商机做出快速反应，为企业内外部用户提供有价值的信息，以提高企业的核心 竞争力。</p><h2 id="2-企业信息化的规划"><a href="#2-企业信息化的规划" class="headerlink" title="2.企业信息化的规划"></a>2.企业信息化的规划</h2><p>首先，企业战略的层面。在规划中必须对企业目前的业务策略和未来的发展方向作深入 分析。<br>其次，业务运作层面。针对企业所确定的业务战略，通过分析获得实现这些目标的关键 业务驱动力和实现这些目标的关键流程。<br>再次，管理运作层面。虽然这一层面从价值链的角度上来说，属于辅助流程，但它对企 业日常管理的科学性、高效性是非常重要的。</p><h2 id="3-企业信息化的方法"><a href="#3-企业信息化的方法" class="headerlink" title="3.企业信息化的方法"></a>3.企业信息化的方法</h2><p>几种常用的企业信息化方法。</p><h3 id="1-业务流程重构方法。"><a href="#1-业务流程重构方法。" class="headerlink" title="(1)业务流程重构方法。"></a>(1)业务流程重构方法。</h3><p>企业业务流程重构的中心思想 是，在信息技术和网络技术迅猛发展的时代，企业必须重新审视企业的生产经营过程，利用 信息技术和网络技术，对企业的组织结构和工作方法进行“彻底的、根本性的”重新设计， 以适应当今市场发展和信息社会的需求。</p><h3 id="2-核心业务应用方法。"><a href="#2-核心业务应用方法。" class="headerlink" title="(2)核心业务应用方法。"></a>(2)核心业务应用方法。</h3><h3 id="3-信息系统建设方法。"><a href="#3-信息系统建设方法。" class="headerlink" title="(3)信息系统建设方法。"></a>(3)信息系统建设方法。</h3><h3 id="4-主题数据库方法。"><a href="#4-主题数据库方法。" class="headerlink" title="(4)主题数据库方法。"></a>(4)主题数据库方法。</h3><p>主题数据库就是面向企业业务主题的数据库，也就是面向企业的核心业务的数据库。</p><h3 id="5-资源管理方法。"><a href="#5-资源管理方法。" class="headerlink" title="(5)资源管理方法。"></a>(5)资源管理方法。</h3><p>资源是企业生存发展的根本保证，一个企业如果离开了资源，那 它是无法生存的。<br>流行的企业信息化的资源管理方法有很多，最常见的有 ERP、 SCM 等。</p><h3 id="6-人力资本投资方法。"><a href="#6-人力资本投资方法。" class="headerlink" title="(6)人力资本投资方法。"></a>(6)人力资本投资方法。</h3><p>人力资本的概念是经济学理论发展的产物。人力资本与人力 资源的主要区别是人力资本理论把一部分企业的优秀员工看作一种资本，能够取得投资收益。 人力资本投资方法特别适用于那些依靠智力和知识而生存的企业，例如，各种咨询服务、软 件开发等企业。</p><h1 id="二、企业资源规划（ERP）"><a href="#二、企业资源规划（ERP）" class="headerlink" title="二、企业资源规划（ERP）"></a>二、企业资源规划（ERP）</h1><p>ERP 是一种融合了企业最佳实践和先进信息技术的新型管理工具。 它扩充了 MIS、MRPII(Manufacturing Resources Planning，制造资源计划)的管理范围， 将供应商和企业内部的采购、生产、销售及客户紧密联系起来，可对供应链上的所有环节进 行有效管理，实现对企业的动态控制和各种资源的集成和优化，提升基础管理水平，追求企 业资源的合理高效利用。</p><p>ERP 被认为是顾客驱动的、基于时间的、面向 整个供应链管理的制造资源计划。</p><p>“企业资源”是指支持企业业务运作和战略运作的事物，既包括人们常说的人、财、物，也包括 人们没有特别关注的信息资源;同时，不仅包括企业的内部资源，还包括企业的各种外部资源。</p><p>ERP 就是一个有效地组织、计划和实施企业的内外部资源的管理系统，它依靠 IT 的技术和手段以保证其信息的集成性、实时性和统一性。</p><h2 id="1-ERP-的结构"><a href="#1-ERP-的结构" class="headerlink" title="1.ERP 的结构"></a>1.ERP 的结构</h2><h3 id="1-ERP-的管理思想"><a href="#1-ERP-的管理思想" class="headerlink" title="(1)ERP 的管理思想"></a>(1)ERP 的管理思想</h3><p>基本思想是将企业的业务流程看作一个紧密连接的供应链， 将企业内部划分成几个相互协同作业的支持子系统，如财务、市场营销、生产制造、质量控 制、服务维护、工程技术等。</p><p>ERP 可以说是 MRPII的一个扩展。<br>第一，它将系统的管理核心从“在正确的时间制造和销售正确的产品” 转移到了“在最佳的时间和地点，获得企业的最大增值”;<br>第二，基于管理核心的转移，其 管理范围和领域也从制造业扩展到了其他行业和企业;<br>第三，在功能和业务集成性方面，都 有了很大加强，特别是商业智能的引入使得以往简单的事务处理系统变成了真正智能化的管 理控制系统。</p><h3 id="2-软件产品"><a href="#2-软件产品" class="headerlink" title="(2)软件产品"></a>(2)软件产品</h3><p>现在，ERP 产品则发展到比较高的阶段。大多 数 ERP 产品供应商都在模块化的基础上，把软件产品和软件服务进行集成，实现软件产品 的技术先进性和个性化设计，为用户提供一体化的解决方案。</p><h3 id="3-管理系统"><a href="#3-管理系统" class="headerlink" title="(3)管理系统"></a>(3)管理系统</h3><p>ERP 是一个集成的信息系统，ERP 承诺建立跨越企业各个部门、各种生产要素和环境的 单一应用原则下处理所有的事务，即意味着集成。这种集成应该包括人力资源、财务、销售、 制造、任务分派和企业供应链等的各项管理业务。</p><p>具体而言，ERP 管理系统主要由六大功能目标组成:<br>一是支持企业整体发展战略经营系统。<br>二是实现全球大市场营销战略与集成化市场营销<br>三是完善企业成本管理机制。<br>四是研究开发管理系统<br>五是建立敏捷的后勤管理系统<br>六是实施准时生产方式</p><h2 id="2-ERP-的主要功能"><a href="#2-ERP-的主要功能" class="headerlink" title="2.ERP 的主要功能"></a>2.ERP 的主要功能</h2><p>一是支持决策的功能<br>二是为处于不同行业的企业提供有针对性的 IT 解决方案<br>三是从企业内部的供应链发展为全行业和跨行业的供应链</p><h2 id="3-ERP-的主要功能模块"><a href="#3-ERP-的主要功能模块" class="headerlink" title="3.ERP 的主要功能模块"></a>3.ERP 的主要功能模块</h2><p>物流、资金流、信息流</p><p><img src="/images/ruankao/7-11.png"></p><h1 id="三、客户关系管理（CRM）"><a href="#三、客户关系管理（CRM）" class="headerlink" title="三、客户关系管理（CRM）"></a>三、客户关系管理（CRM）</h1><p>CRM 在坚持以客户为中心的理念的基础上，重构包括市场营销和客户服务等业务流程。 CRM 的目标不仅要使这些业务流程自动化，而且要确保前台应用系统能够改进客户满意度、 增加客户忠诚度，以达到使企业获利的最终目标。</p><h2 id="1-CRM-的概念"><a href="#1-CRM-的概念" class="headerlink" title="1.CRM 的概念"></a>1.CRM 的概念</h2><p>CRM 集成了信息系统和办公系统等的一整套应用系统，从而确保了客户满意度的提高，以及通过对业务流程的全面管理来降低企业成本。</p><h2 id="2-CRM-的背景"><a href="#2-CRM-的背景" class="headerlink" title="2.CRM 的背景"></a>2.CRM 的背景</h2><p>CRM 的出现体现了两个重要的管理趋势的转变。<br>首先是企业从以产品为中心的模式向以客户为中心的模式的转变。<br>其次，CRM 的出 现还表明了企业管理的视角从“内视型”向“外视型”的转变。</p><p>仅仅依靠 ERP 的“内视型”的管理模式已难以适应激烈的竞争，企业必须转换自己的视角，在向“外向型”转变的过程中整合自己的资源。</p><h2 id="3-CRM-的内容"><a href="#3-CRM-的内容" class="headerlink" title="3.CRM 的内容"></a>3.CRM 的内容</h2><p>(1)客户服务。<br>(2)市场营销。<br>(3)共享的客户资料库。<br>(4)分析能力。</p><h2 id="4-CRM-的解决方案和实施过程"><a href="#4-CRM-的解决方案和实施过程" class="headerlink" title="4.CRM 的解决方案和实施过程"></a>4.CRM 的解决方案和实施过程</h2><p>CRM 的根本要求就是与客户建立起一种互相学习的关系，即从与客户的接触中了解他 们在使用产品中遇到的问题，以及对产品的意见和建议，并帮助他们加以解决。</p><p>一般说来 CRM 由两部分构成，即触发中心和挖掘中心，前者指客户和 CRM 通过电话、 传真、Web、E-mail 等多种方式“触发”进行沟通;挖掘中心则是指对 CRM 记录交流沟通 的信息进行智能分析。</p><p>一个有效的 CRM 解决方案应该具备以下要素:<br>(1)畅通有效的客户交流渠道(触发中心)。<br>(2)对所获信息进行有效分析(挖掘中心)。<br>(3)CRM 必须能与 ERP 很好地集成。</p><h2 id="5-CRM-的价值"><a href="#5-CRM-的价值" class="headerlink" title="5.CRM 的价值"></a>5.CRM 的价值</h2><p>CRM 之所以受欢迎是因为好的客户关系管理对客户和企业都有益。CRM 用户从不断加 强的客户关系管理中明显获益。好的服务不但令人愉快，更能带来巨大价值。带有客户服务 的产品的总价值明显高于产品自身。<br>从另一方面看，企业实施 CRM 并非出于利他原则，而是认识到客户是其真正的财富。</p><p>较高的满意度，使得企业能够保留老客户，并不断增加新客户;<br>识别利润贡献度最高的客户并给以相应的优厚对待;<br>通过有效目标市场定位，来降低营销成本;<br>引导潜在消费至适当的销售渠道;<br>提供正确的产品来增加销售(交叉销售/纵向销售);<br>简化部门工作流程来缩短销售周期;<br>通过集中共同活动以减少多余运作;<br>减少由于多个不协调的客户交互点而产生的差错，节省费用;<br>利用客户喜欢的沟通渠道来增加对客户需求的了解;<br>参照与其他客户的联络记录和经验，与目前的客户进行沟通;<br>根据对以前绩效的分析评估未来的销售、营销和客户服务活动;</p><h1 id="四、产品数据管理（PDM）"><a href="#四、产品数据管理（PDM）" class="headerlink" title="四、产品数据管理（PDM）"></a>四、产品数据管理（PDM）</h1><h2 id="1-PDM-简介"><a href="#1-PDM-简介" class="headerlink" title="1.PDM 简介"></a>1.PDM 简介</h2><p>PDM 是一门用来管理所有与产品相关信息(包括零件信息、配置、文档、计算机辅助设计 文件、结构、权限信息等)和所有与产品相关过程(包括过程定义和管理)的技术。</p><p>PDM 是为企业设计和生产构筑一个并行产品开发环境(由供应、工程设计、制造、采购、 销售与市场、客户构成)的关键技术。一个成熟的 PDM 系统能够使所有参与创建、交流、 维护设计意图的人在整个信息生命周期中自由共享和传递与产品相关的所有异构数据。</p><p>PDM 系统是一种软件框架，利用这个框架可以帮助企业实现对与企业产品相关的数据、开 发过程，以及帮助使用者进行集成与管理，可以实现对设计、制造和生产过程中需要的大量 数据进行跟踪和支持。</p><p>PDM 能够跨越时间和操作环境，实现数据的无缝连接和移动，保证 正确的数据、在正确的时间、以正确的格式、出现在正确的位置，进而推动产品尽快地投入 市场并能有效地平衡生产能力。</p><p>PDM 系统的用户主要有三类:<br>一是信息的使用者，他们要求最简单的用户界面;<br>二是数据的创造者，如机械工程师和电子工程师等，他们希望 PDM 系统能够很好地融入到产品设计应用中;<br>三是系统管理员，他们面对的是最复杂的用户界面。</p><h2 id="2-企业对-PDM-的需求"><a href="#2-企业对-PDM-的需求" class="headerlink" title="2.企业对 PDM 的需求"></a>2.企业对 PDM 的需求</h2><p>一是在企业内部建立起完整的、统一的、共享的数据模型，保证各部门的产品信息一致。<br>二是缩短产品的上市时间。在需要数据的时候立即得到这些数据，加快任务的完成; 支持并行工程;允许授权小组的成员随时访问最新的版本的相关数据。<br>三是适应多品种小批量生产方式。通过产品结构和配置管理为用户提供了系列产品的有效管理方法，并可以快速地响应市场的需求，实现“面向订单”的生产方式。<br>四是提高设计效率和提高生产效率，降低产品成本。<br>五是提高设计与制造的准确性，提高产品质量。<br>六是保护数据完整性。PDM 系统提供权限控制和变更管理确保产品数据的准确和安全。<br>七是更好地控制项目。项目管理功能提供用户对项目的进展情况进行实施监控，确保项目顺利进行和如期完成。<br>八是实现全面的质量管理。PDM 系统可以建立适应 ISO9000 系列验证和全面质量管理<br>的环境，通过在产品全生命周期内的工作流程管理确保了产品的最终质量。<br>九是建立起企业 级的协同工作平台，为最终实现企业的电子商务打下坚实的基础。</p><h2 id="3-PDM-的发展过程"><a href="#3-PDM-的发展过程" class="headerlink" title="3.PDM 的发展过程"></a>3.PDM 的发展过程</h2><p>(1)配合 CAD(Computer Aided Design，计算机辅助设计)使用的早期简单的 PDM 系统。<br>(2)产品数据管理。<br>(3)产品协同商务(Collaborative Product Commerce，CPC)或 PDM 标准化。</p><h2 id="4-PDM-主要功能模块和内容"><a href="#4-PDM-主要功能模块和内容" class="headerlink" title="4.PDM 主要功能模块和内容"></a>4.PDM 主要功能模块和内容</h2><p>(1)数据基库<br>(2)产品配置管理<br>(3)工作流管理<br>(4)分类及检索功能<br>(5)项目管理</p><h1 id="五、企业门户"><a href="#五、企业门户" class="headerlink" title="五、企业门户"></a>五、企业门户</h1><h2 id="1-企业门户的功能"><a href="#1-企业门户的功能" class="headerlink" title="1.企业门户的功能"></a>1.企业门户的功能</h2><p>(1)能够将一个机构现有的互联网址和服务完全合并而且相互兼容。<br>(2)能够支持开放标准和应用编程接口，让平台得以轻易容纳新的应用程序。<br>(3)能够接入一个由支持企业门户网站架构的伙伴和专业服务公司所组成的网络。<br>(4)能够多渠道接入网站，如互联网至公司内联网、话音网络、无线网络等。<br>(5)能够以统一的服务作为企业门户网站各种服务的基础，让用户享有多种便利，如一次登入、个人化接口等。当用户进入门户网站的不同部分时，系统可以记住用户的身份以 提供合适的信息。</p><h2 id="2-企业门户的分类"><a href="#2-企业门户的分类" class="headerlink" title="2.企业门户的分类"></a>2.企业门户的分类</h2><p>信息门户、知识门户和应用门户。</p><h2 id="3-企业门户的要素"><a href="#3-企业门户的要素" class="headerlink" title="3.企业门户的要素"></a>3.企业门户的要素</h2><p>建立互联网服务时应考虑的基本要素:<br>(1)战略性思维<br>(2)为用户所需要的不同类型门户网站建立一个门户网站架构。<br>(3)寻找合适的技术供货商——既能够支持各主要标准，并能够将其基本门户网站架 构与其他供货商的应用程序整合起来。<br>(4)确定所要建立的门户网站类型<br>(5)首先小规模地试办项目，确保有一个可行的工作环境。</p><h1 id="六、企业应用集成（EAI）"><a href="#六、企业应用集成（EAI）" class="headerlink" title="六、企业应用集成（EAI）"></a>六、企业应用集成（EAI）</h1><p>EAI 技术将进程、软件、 标准和硬件联合起来，在两个或更多的企业信息系统之间实现无缝集成，使它们就像一个整 体一样。</p><h2 id="1-EAI-的简要历史"><a href="#1-EAI-的简要历史" class="headerlink" title="1.EAI 的简要历史"></a>1.EAI 的简要历史</h2><h2 id="2-EAI-的内容"><a href="#2-EAI-的内容" class="headerlink" title="2.EAI 的内容"></a>2.EAI 的内容</h2><h3 id="1-企业内的集成"><a href="#1-企业内的集成" class="headerlink" title="(1)企业内的集成"></a>(1)企业内的集成</h3><p>1 界面集成<br>2 平台集成<br>3 数据集成<br>4 应用集成<br>5 过程集成</p><h3 id="2-企业间应用集成"><a href="#2-企业间应用集成" class="headerlink" title="(2)企业间应用集成"></a>(2)企业间应用集成</h3><p>EAI 使得应用集成架构里的客户和业务伙伴，都可以通过集成供应链内的所有应用和数据库实现信息共享。</p><h2 id="3-集成技术的发展"><a href="#3-集成技术的发展" class="headerlink" title="3.集成技术的发展"></a>3.集成技术的发展</h2><p>面向信息的集成技术、面向过程的集成技术和面向服务的集成技术。</p><p>信息集成采用的主要数据处理技术有数据复制、数据聚合和接口集成等。其中，接口集成仍然是一种主流技术。</p><p>基于 SOA 和 Web 服务技术的应用集成是业务集成技术上的一次重要的变化，被认为是新一代的应用集成技术。</p><h1 id="七、供应链管理（Supply-Chain-Management，SCM）"><a href="#七、供应链管理（Supply-Chain-Management，SCM）" class="headerlink" title="七、供应链管理（Supply Chain Management，SCM）"></a>七、供应链管理（Supply Chain Management，SCM）</h1><h2 id="1-供应链管理的定义"><a href="#1-供应链管理的定义" class="headerlink" title="1.供应链管理的定义"></a>1.供应链管理的定义</h2><p>SCM 的核心是供应链。供应链是指一个整体的网络，用来传送产品和服务，从原材料 开始一直到最终客户(消费者)，它凭借一个设计好的信息流、物流和现金流来完成。</p><p>现代 意义的供应链是利用计算机网络技术全面规划供应链中的商流、物流、信息流、资金流等并 进行计划、组织、协调和控制。</p><p>供应链有两层含义，一层含义是任何一个企业内部都有一条或几条供应链，包括从生产 到发货的各个环节;另一层含义是一个企业必定处于市场更长的供应链之中，包括从供应商 的供应商到顾客的顾客的每一个环节。</p><p>供应链是企业赖以生存的商业循环系统，是企业电子 商务中最重要的课题。</p><p>供应链管理至少包括以下六大应用功能:<br>需求管理(预测和协作工具)、<br>供应链计划(多工厂计划)、<br>生产计划、<br>生产调度、<br>配送计划、<br>运输计划。</p><h2 id="2-供应链与物流"><a href="#2-供应链与物流" class="headerlink" title="2.供应链与物流"></a>2.供应链与物流</h2><p>供应链与物流的关系极为密切，而且不可分割。供应链管理是一种管理方法或思想，而 物流是在现实经营活动中的物质运动，供应链管理思想是从物流管理的实践中提取出来的， 管理的对象是物流;物流分为采购物流、生产物流、销售物流，而供应链管理将这些全部纳 入到一个管理体系之中，在供应商、分销商、零销商之间搭建起一个流畅的通道，建立起一 个信息共享的机制，从而优化整个供应链，达到降低成本、提高效率等目的。</p><h2 id="3-供应链管理是一种管理思想"><a href="#3-供应链管理是一种管理思想" class="headerlink" title="3.供应链管理是一种管理思想"></a>3.供应链管理是一种管理思想</h2><p>供应链管理一个重要的前提是信息共享，而各种版本 SCM 产品，其 核心功能其实是信息传递。</p><h2 id="4-供应链管理的运作模式"><a href="#4-供应链管理的运作模式" class="headerlink" title="4.供应链管理的运作模式"></a>4.供应链管理的运作模式</h2><p>供应链中的信息流覆盖了从供应商、制造商到分销商，再到零售商等供应链中的所有环节。其信息流分为需求信息流和供应信息流，这是两个不同流向的信息流。</p><h2 id="5-供应链管理的技术支持体系"><a href="#5-供应链管理的技术支持体系" class="headerlink" title="5.供应链管理的技术支持体系"></a>5.供应链管理的技术支持体系</h2><p>供应链信息系统的建立需要大量信息技术来支持，这是因为供应链管理涉及众多的领域: 产品(服务)设计、生产、市场营销(销售)、客户服务、物流供应等。它是以同步化、集成 化生产计划为指导，通过采用各种不同信息技术来提高这些领域的运作绩效。</p><p>信息技术对供应链的支撑可分为两个层面。<br>第一个层面是由标识代码技术、自动识别与数据采集技术、电子数据交换技术、互联网 技术等基础信息技术构成。<br>第二层面是基于信息技术而开发的支持企业生产。</p><h1 id="八、电子商务概述"><a href="#八、电子商务概述" class="headerlink" title="八、电子商务概述"></a>八、电子商务概述</h1><p>电子商务是一项涉及全球的全新业务和全新服务，是网络化的新型经济活动，它不仅仅 是基于互联网的新型交易或流通方式，还是基于互联网、广播电视网和电信网络等电子信息 网络的生产、流通和消费活动。</p><h2 id="1-什么是电子商务"><a href="#1-什么是电子商务" class="headerlink" title="1.什么是电子商务"></a>1.什么是电子商务</h2><p>电子商务(Electronic Commerce，EC)是指买卖双方利用现代开放的 Internet，按照一 定的标准所进行的各类商业活动。</p><p>电子商务分三个方面:即电子商情广告、电子选购和交易及电子交易凭证的交换、电子 支付与结算以及网上售后服务等。</p><p>参与电子商务的实体有四类:顾客(个人消费者或集团购买)、商户(包括销售商、制 造商、储运商)、银行(包括发卡行、收单行)及认证中心。</p><h2 id="2-电子商务的类型"><a href="#2-电子商务的类型" class="headerlink" title="2.电子商务的类型"></a>2.电子商务的类型</h2><p>(1)企业与消费者之间的电子商务(Business to Customer，B2C)<br>(2)企业与企业之间的电子商务(Business to Business，B2B)<br>(3)消费者与消费者之间的电子商务(Customer to Customer，C2C)<br>(4)O2O 即 Online To Offline(在线离线/线上到线下)</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-信息系统基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于中间件的开发（四）.NET</title>
      <link href="/2021/09/30/%E8%BD%AF%E8%80%83/15%E3%80%81%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91/%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91%EF%BC%88%E5%9B%9B%EF%BC%89.NET/"/>
      <url>/2021/09/30/%E8%BD%AF%E8%80%83/15%E3%80%81%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91/%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91%EF%BC%88%E5%9B%9B%EF%BC%89.NET/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-基于中间件的开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件架构设计（十一）软件架构视图</title>
      <link href="/2021/09/29/%E8%BD%AF%E8%80%83/9%E3%80%81%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%A7%86%E5%9B%BE/"/>
      <url>/2021/09/29/%E8%BD%AF%E8%80%83/9%E3%80%81%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="一、软件视图的分类"><a href="#一、软件视图的分类" class="headerlink" title="一、软件视图的分类"></a>一、软件视图的分类</h1><p>现代软件系统非常复杂，通常在某个具体的时间内只需将注意力集中在某几个结构上，结构是元素本身的集合，而视图则是捕获和表达结构(文档描述)，虽然它 们有区别，但在实际使用时则不严格区分，即从系统体系的角度说是结构，从文档角度说是 视图。</p><p>架构的优势也在于使用视图:每个视图强调系统的某一个方面，同时忽视系统的其他方 面，以便有助于处理或理解当前问题，描述完整的系统架构必须具备完整的视图集，“4+1” 方法就是一类完备视图集。</p><p>软件视图通常分为三种类型:<br>(1)模块视图类型:为系统的主要模块实现单元编档。<br>(2)构件和连接件视图类型:为系统的构件和连接件执行单元编档。<br>(3)分配视图类型:为软件的开发和执行环境之间的关系编档。</p><table><thead><tr><th>组别</th><th>架构风格</th><th>说明</th><th>应用于</th></tr></thead><tbody><tr><td>模块视图类型</td><td>分解</td><td>大模块分解为小模块，小到容易理解</td><td>资源分配、项目结构化和规划；信息隐蔽、封装；配置控制</td></tr><tr><td>↑</td><td>使用</td><td>一个单元的正确性依赖于另一个单元的正确性（如版本）</td><td>设计子集；设计扩展（增量开发）</td></tr><tr><td>↑</td><td>分层</td><td>上层使用下层的服务；实现隐藏细节的抽象</td><td>增量式开发；基于“虚拟机”上的可移植性</td></tr><tr><td>↑</td><td>类或泛化</td><td>“继承自”或“是一个实例”；共享访问方法</td><td>面向对象的设计（使用公共模板）</td></tr><tr><td>构件-连接器视图类型</td><td>客户机-服务器</td><td>构件是客户机和服务器，连接件是协议及共享信息</td><td>分布式操作：关注点分离（支持可修改性）；负载均衡</td></tr><tr><td>↑</td><td>进程或通信进程</td><td>通过通信、同步或排除操作形成进程或线程之间的关联</td><td>调度分析：性能分析</td></tr><tr><td>↑</td><td>并发</td><td>在相同的“逻辑线程”上运行</td><td>确定资源挣用；分析线程</td></tr><tr><td>↑</td><td>共享数据</td><td>运行时产生数据、使用数据（共享数据储存库）</td><td>性能；数据完整性；可修改性</td></tr><tr><td>分配视图类型</td><td>部署</td><td>软件功能分配给软件（进程）、硬件（处理器）和通信路径</td><td>性能、可能性、安全性说明。尤其在分布式或并行系统中</td></tr><tr><td>↑</td><td>实现</td><td>模块映射到开发活动中</td><td>配置控制、集成、测试活动</td></tr><tr><td>↑</td><td>工作分配</td><td>将责任分配到适当得开发小组，特别是公共部分不是每个人趋势线</td><td>项目管理、管理通用性，最好的专业技术安排</td></tr></tbody></table><h1 id="二、模块视图类型及其风格"><a href="#二、模块视图类型及其风格" class="headerlink" title="二、模块视图类型及其风格"></a>二、模块视图类型及其风格</h1><p>模块将遵循某种方式将软件系统分解成可管理的功能单元。架构模块视图是通过文档来枚举系统的主要实现单元或模块，及这些单元之间的关系。</p><p>完整的架构文档必须包含有模块视图，它为源代码提供蓝图。</p><p><img src="/images/ruankao/6-53.png"></p><h2 id="1-分解风格能展示向模块分配责任的方式。"><a href="#1-分解风格能展示向模块分配责任的方式。" class="headerlink" title="(1)分解风格能展示向模块分配责任的方式。"></a>(1)分解风格能展示向模块分配责任的方式。</h2><p><img src="/images/ruankao/6-54.png"></p><h2 id="2-使用风格能展示模块相互依赖的方式。"><a href="#2-使用风格能展示模块相互依赖的方式。" class="headerlink" title="(2)使用风格能展示模块相互依赖的方式。"></a>(2)使用风格能展示模块相互依赖的方式。</h2><p><img src="/images/ruankao/6-55.png"></p><h2 id="3-分层风格能将系统分割成一组虚拟机，通过“允许使用”关系相互关联，分层风-格能帮助实现可移植性和可修改性。"><a href="#3-分层风格能将系统分割成一组虚拟机，通过“允许使用”关系相互关联，分层风-格能帮助实现可移植性和可修改性。" class="headerlink" title="(3)分层风格能将系统分割成一组虚拟机，通过“允许使用”关系相互关联，分层风 格能帮助实现可移植性和可修改性。"></a>(3)分层风格能将系统分割成一组虚拟机，通过“允许使用”关系相互关联，分层风 格能帮助实现可移植性和可修改性。</h2><p><img src="/images/ruankao/6-56.png"></p><h2 id="4-泛化风格能展示一个模块如何成为另一个模块的泛化或特化，从而使模块之间产-生关联。"><a href="#4-泛化风格能展示一个模块如何成为另一个模块的泛化或特化，从而使模块之间产-生关联。" class="headerlink" title="(4)泛化风格能展示一个模块如何成为另一个模块的泛化或特化，从而使模块之间产 生关联。"></a>(4)泛化风格能展示一个模块如何成为另一个模块的泛化或特化，从而使模块之间产 生关联。</h2><p>它广泛应用于面向对象的系统，能展示继承性，并能用来使用模块之间的共性。<br><img src="/images/ruankao/6-57.png"></p><h1 id="三、C-amp-C视图类型及其风格"><a href="#三、C-amp-C视图类型及其风格" class="headerlink" title="三、C&amp;C视图类型及其风格"></a>三、C&amp;C视图类型及其风格</h1><p>C&amp;C 视图能定义由具有某种运行时存在的元素模型，这些元素包括进程、对象、客户 机、服务器及数据存储器等。此外，它还包含作为元素的交互路径，如通信链路和协议、信 息流及共享存储器访问。通常，可利用复杂的基础结构(如中间件框架、分布式通信信道和 进程调度)来执行这些交互操作。<br><img src="/images/ruankao/6-58-1.png"><br><img src="/images/ruankao/6-58-2.png"></p><h2 id="1-管道和过滤器风格中的交互模式表现出数据流连续变换的特征。"><a href="#1-管道和过滤器风格中的交互模式表现出数据流连续变换的特征。" class="headerlink" title="(1)管道和过滤器风格中的交互模式表现出数据流连续变换的特征。"></a>(1)管道和过滤器风格中的交互模式表现出数据流连续变换的特征。</h2><p>数据抵达过滤器 并经过转换后由管理传送给下一个过滤器。</p><p><img src="/images/ruankao/6-59.png"></p><h2 id="2-共享数据风格通过保留持久数据来支配交互模式，持久数据由多个数据存取器和-至少一个储存库保留。"><a href="#2-共享数据风格通过保留持久数据来支配交互模式，持久数据由多个数据存取器和-至少一个储存库保留。" class="headerlink" title="(2)共享数据风格通过保留持久数据来支配交互模式，持久数据由多个数据存取器和 至少一个储存库保留。"></a>(2)共享数据风格通过保留持久数据来支配交互模式，持久数据由多个数据存取器和 至少一个储存库保留。</h2><p><img src="/images/ruankao/6-60.png"></p><h2 id="3-发布-订阅风格用于向一组未知接受者发送事件和消息。"><a href="#3-发布-订阅风格用于向一组未知接受者发送事件和消息。" class="headerlink" title="(3)发布-订阅风格用于向一组未知接受者发送事件和消息。"></a>(3)发布-订阅风格用于向一组未知接受者发送事件和消息。</h2><p>可在不修改生产者的情况 下添加新的接受者(订阅者)。在发布-订阅风格中，构件通过事件发布进行交互。构件可订 阅一组事件。<br><img src="/images/ruankao/6-61.png"></p><h2 id="4-客户机-服务器风格能展示构件通过请求其他构件的服务进行交互的过程，将功能-划分成客户机和服务器后即可基于运行时准则把它们单独分配给各个级。"><a href="#4-客户机-服务器风格能展示构件通过请求其他构件的服务进行交互的过程，将功能-划分成客户机和服务器后即可基于运行时准则把它们单独分配给各个级。" class="headerlink" title="(4)客户机-服务器风格能展示构件通过请求其他构件的服务进行交互的过程，将功能 划分成客户机和服务器后即可基于运行时准则把它们单独分配给各个级。"></a>(4)客户机-服务器风格能展示构件通过请求其他构件的服务进行交互的过程，将功能 划分成客户机和服务器后即可基于运行时准则把它们单独分配给各个级。</h2><h2 id="5-对等连接系统能通过构件之间的直接交换支持服务交换。它是一种调用-返回风格。"><a href="#5-对等连接系统能通过构件之间的直接交换支持服务交换。它是一种调用-返回风格。" class="headerlink" title="(5)对等连接系统能通过构件之间的直接交换支持服务交换。它是一种调用/返回风格。"></a>(5)对等连接系统能通过构件之间的直接交换支持服务交换。它是一种调用/返回风格。</h2><p><img src="/images/ruankao/6-63.png"></p><h2 id="6-通信-进程风格的特征表现在通过各种连接件机制并发执行构件的交互，如通过同-步、消息传递、数据交换、启动和停止等进行交互。"><a href="#6-通信-进程风格的特征表现在通过各种连接件机制并发执行构件的交互，如通过同-步、消息传递、数据交换、启动和停止等进行交互。" class="headerlink" title="(6)通信-进程风格的特征表现在通过各种连接件机制并发执行构件的交互，如通过同 步、消息传递、数据交换、启动和停止等进行交互。"></a>(6)通信-进程风格的特征表现在通过各种连接件机制并发执行构件的交互，如通过同 步、消息传递、数据交换、启动和停止等进行交互。</h2><p><img src="/images/ruankao/6-64.png"></p><h1 id="四、分配视图类型及其风格"><a href="#四、分配视图类型及其风格" class="headerlink" title="四、分配视图类型及其风格"></a>四、分配视图类型及其风格</h1><p>硬件、文件系统和团队结构都会与软件架构进行交互，将软件架构映射到其环境的一般<br>形式称为“分配视图类型”。</p><p><img src="/images/ruankao/6-65.png"></p><p>分配视图类型的三种常见风格为:<br>部置风格:能描述构件和连接件对硬件的映射，硬件是软件执行的场所。<br>实现风格:能描述模块对包含它们的文件系统的映射。<br>工作任务风格:能描述模块对承担模块开发任务的人员、团队或小组的映射。</p><h2 id="1-部置风格体现为-C-amp-C-风格-如通信-进程风格-的元素被分配到执行平台。"><a href="#1-部置风格体现为-C-amp-C-风格-如通信-进程风格-的元素被分配到执行平台。" class="headerlink" title="(1)部置风格体现为 C&amp;C 风格(如通信-进程风格)的元素被分配到执行平台。"></a>(1)部置风格体现为 C&amp;C 风格(如通信-进程风格)的元素被分配到执行平台。</h2><p><img src="/images/ruankao/6-66.png"></p><h2 id="2-实现风格能将模块视图类型中的模块映射到开发基础结构。"><a href="#2-实现风格能将模块视图类型中的模块映射到开发基础结构。" class="headerlink" title="(2)实现风格能将模块视图类型中的模块映射到开发基础结构。"></a>(2)实现风格能将模块视图类型中的模块映射到开发基础结构。</h2><p>实现一个模块总会产 生许多独立文件，必须对这些文件进行组织，以免失去对系统的控制及系统的完整性。通常 利用配置管理技术进行文件管理。</p><p><img src="/images/ruankao/6-67.png"></p><h2 id="3-软件项目的时间和预算估计取决于工作分解结构-WBS-，而工作分解结构则取决-于软件架构。"><a href="#3-软件项目的时间和预算估计取决于工作分解结构-WBS-，而工作分解结构则取决-于软件架构。" class="headerlink" title="(3)软件项目的时间和预算估计取决于工作分解结构(WBS)，而工作分解结构则取决 于软件架构。"></a>(3)软件项目的时间和预算估计取决于工作分解结构(WBS)，而工作分解结构则取决 于软件架构。</h2><p>工作任务风格将软件架构映射到由人组成的团队之中，实现这一项目管理的目 的。</p><p><img src="/images/ruankao/6-68.png"></p><p>工作任务风格与模块分解风格关系密切，它能将模块分解风格用作其分配映射的基础。 这种风格能通过添加与开发工具、测试工具和配置管理系统等对应的模块分解进行扩展。工 作任务风格还通常与其他风格联合使用，例如，团队工作任务可以是模块分解风格中的模块， 可以是分层图中的层，也可以是多进程系统中的任务或进程。</p><h1 id="五、各视图类型间的映射关系"><a href="#五、各视图类型间的映射关系" class="headerlink" title="五、各视图类型间的映射关系"></a>五、各视图类型间的映射关系</h1><p>为了完整地描述一个架构，必须使用多个视图，这些视图必须遵守一定的映射关系。</p><p>(1)模块视图类型中的视图通常会映射到构件和连接件视图类型中的视图。模块实现 单元将映射到运行时构件。</p><p>(2)系统的构件和连接件视图和模块视图之间的关系可能会非常复杂。同样的代码模 块可由 C&amp;C 视图的许多元素执行。反之，C&amp;C 视图的单一构件可执行由许多模块定义的代 码。同样，C&amp;C 构件可能会拥有许多与环境进行交互的点，每个交互点由同一模块接口定 义。</p><p>(3)分配视图类型是为有效地实现软件架构的辅助性视图，它将其他视图类型中的软 件元素映射到软件环境中，即反映其他视图与软件环境之间的关系。</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-软件架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件架构设计（七）软件架构文档化</title>
      <link href="/2021/09/27/%E8%BD%AF%E8%80%83/9%E3%80%81%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%83%EF%BC%89%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%96%87%E6%A1%A3%E5%8C%96/"/>
      <url>/2021/09/27/%E8%BD%AF%E8%80%83/9%E3%80%81%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%83%EF%BC%89%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%96%87%E6%A1%A3%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>记录软件架构的活动就是架构编档过程，也就是架构的文档化。它包含两个方面:一是 过程，编档过程能促使架构设计师进一步思考，使得架构更加完善;二是结果，描述架构的 文档将作为架构开发的成果，供项目关系人使用。</p><h1 id="1-架构文档的使用者"><a href="#1-架构文档的使用者" class="headerlink" title="1.架构文档的使用者"></a>1.架构文档的使用者</h1><p>架构文档的使用者是架构的项目关系人。编写技术文档(尤其是软件架构文档)最基本 的原则之一是要从读者的角度来编写，易于编写但很难阅读的文档是不受欢迎的。</p><p>架构的主要用途是充当项目关系人之间进行交流的工具，文档则促进了这种交流—— 架 构项目关系人希望从架构文档中获得自己所关心的架构信息。</p><h1 id="2-编档规则"><a href="#2-编档规则" class="headerlink" title="2.编档规则"></a>2.编档规则</h1><p>合理的编档规则编写架构文档和编写其他文档一样，必须遵守一些基本规则，这里 将任何软件编档(包括软件架构编档)的规则归纳为 7 条:</p><p>(1)从读者的角度编写文档。<br>(2)避免出现不必要的重复。<br>(3)避免歧义。<br>(4)使用标准结构。<br>(5)记录基本原理。<br>(6)使文档保持更新，但更新频率不要过高。<br>(7)针对目标的适宜性对文档进行评审。</p><h1 id="3-视图编档"><a href="#3-视图编档" class="headerlink" title="3.视图编档"></a>3.视图编档</h1><p>视图的 概念为架构设计师提供了进行软件架构编档的基本原则。架构文档化就是将相关视图编成文 档，并补充多个视图的关联关系。</p><p><img src="/images/ruankao/6-48.png"></p><p>(1)视图概述:对系统进行概括性的描述，包含视图的主要元素和元素间的关系。<br>主要表示可用多个形式:图形、表 格、文本，通常用图形形式，使用 UML 语言来描述。</p><p>(2)元素目录:对主要表示中所描述的元素及其关系进行详细描述，包括:元素及其 属 性、关系及其属性、元素接口、元素行为。<br>对元素及其协同工作的行为进行编档，如用 UML 的顺序图和状态图描述行为;<br>对接口进行编档如题<br><img src="/images/ruankao/6-49.png"></p><p>(3)上下文图:用图形展示系统如何与其环境相关。</p><p>(4)可变性指南:描述架构的可变化点，如在软件产品线中，产品线架构通过变化， 适用于多个系统，因此，文档中应包含这些变化点，如各系统要做出选择的选项、做出选择 的时间。</p><p>(5)架构背景:为架构的合理性提供足够的、令人信服的论据。包括:基本原理、分 析结果及设计中所反映的假定。</p><p>(6)术语表:对文档中每个术语进行简要说明。</p><p>(7)其他信息:描述不属于架构方面的必要信息，如管理信息(创作者、配置控制数 据及变更历史)。</p><h1 id="4-跨视图文档"><a href="#4-跨视图文档" class="headerlink" title="4.跨视图文档"></a>4.跨视图文档</h1><p>软件架构由多个视图文档来反映，按前面所述的要求完成每个视图的文档后，需要对这 些文档进行一个整体的“打包”工作，这就是跨视图文档。它包括如下内容:<br>(1)文档有哪些内容，它们是如何组织的:视图目录(含哪些视图);视图模板(即前 面描述的视图文档，企业可以通过规范化来定义统一的、公共的视图模板)。<br>(2)架构概述:它描述系统的目的、视图之间的关联、元素表及索引、项目词汇。<br>(3)为什么架构是这样的(基本原理):跨视图基本原理解释了整体架构实际上是其需 求的一个解决方案。即解释了做出决策的原因、方案的限制、改变决策时的影响及意义。</p><h1 id="5-使用-UML"><a href="#5-使用-UML" class="headerlink" title="5.使用 UML"></a>5.使用 UML</h1><p>UML 已经成为对软件架构进行文档化的事实上的标准表示法。在视图文档的组织结构 中，UML 主要用于表示元素或元素组的行为。</p><h1 id="6-软件架构重构"><a href="#6-软件架构重构" class="headerlink" title="6.软件架构重构"></a>6.软件架构重构</h1><p>前面已论述了架构编档，即在架构设计时完成编档工作。但是还有另外一种情况:系统<br>已经存在，但不知其架构，即架构没有通过文档很好地保留下来(文档的缺失/失效)。如何 维护这样的系统并管理其演变?其关键就是要找到软件架构，软件架构重构就是研究解决这 一问题的方法，它是反向工程之一。</p><p>软件架构重构由以下活动组成，这些活动以迭代方式进行。</p><p><img src="/images/ruankao/6-50.png"></p><p>(1)信息提取(View Extraction)。可以使用各种工具进行信息提取，如解析器、语法 分析器等;可以利用 build 和 makefile 文件中关于模块的依赖关系;可以从源代码、编译 时制品和设计制品中提取静态信息;可以使用分析工具提取动态信息。</p><p>(2)数据库构造(Database Construction):将提取的信息转化为标准的形式，并置于 数据库中。</p><p>(3)视图融合(View Fusion):将数据库中的信息组合在一起，生成该架构的一个内聚 的视图。</p><p>(4)重构(Reconstruction):构建数据抽象和各种表示以生成架构表示，主要由两个活动组成:可视化和交互、模式定义和识别。最后生成需要的架构文档(Documentation)。</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-软件架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件架构设计（九）架构及其复用</title>
      <link href="/2021/09/27/%E8%BD%AF%E8%80%83/9%E3%80%81%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B9%9D%EF%BC%89%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%85%B6%E5%A4%8D%E7%94%A8/"/>
      <url>/2021/09/27/%E8%BD%AF%E8%80%83/9%E3%80%81%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B9%9D%EF%BC%89%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%85%B6%E5%A4%8D%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>常见的构件(component，组件)的定义如下：</p><p>定义 1:构件是指软件系统中可以明确辨识的构成成分。而可复用构件(reusable component)是指具有相对独立的功能和可复用价值的构件。<br>定义 2:构件是一个组装单元，它具有约定式规范的接口及明确的依赖环境。<br>定义 3:构件是软件系统中具有相对独立功能、可以明确辨识、接口由契约指定、和语 境有明显依赖关系、可独立部署的可组装软件实体。</p><h1 id="一、商用构件标准规范"><a href="#一、商用构件标准规范" class="headerlink" title="一、商用构件标准规范"></a>一、商用构件标准规范</h1><h2 id="1-CORBA"><a href="#1-CORBA" class="headerlink" title="1.CORBA"></a>1.CORBA</h2><p>CORBA(Common ObjectRequest Broker Architecture，公共对象请求代理架构)主要分为 3 个层次:对象请求代理、公共对象服务和公共设施。</p><p>CORBA CCM(CORBA ComponentModel，CORBA 构件模型)是 OMG 组织制定的一个用 于开发和配置分布式应用的服务器端构件模型规范，它主要包括如下 3 项内容。<br>(1)抽象构件模型:用以描述服务器端构件结构及构件间互操作的结构。<br>(2)构件容器结构:用以提供通用的构件运行和管理环境，并支持对安全、事务、持 久状态等系统服务的集成。<br>(3)构件的配置和打包规范:CCM 使用打包技术来管理构件的二进制、多语言版本的 可执行代码和配置信息，并制定了构件包的具体内容和文档内容标准。</p><h2 id="2-J2EE"><a href="#2-J2EE" class="headerlink" title="2.J2EE"></a>2.J2EE</h2><p>在分布式互操作协议上，J2EE 同时支持 RMI(Remote Method Invocation，远程方法调用) 和 IIOP(Internet Inter-ORB Protocol，互联网内部对象请求代理协议)，而在服务器端分布式 应用的构造形式，则包括了 Java Servlet、JSP、EJB 等多种形式，以支持不同的业务需求， 而且 Java 应用程序具有跨平台的特性，使得 J2EE 技术在发布计算领域得到了快速发展。</p><h2 id="3-DNA-2000"><a href="#3-DNA-2000" class="headerlink" title="3.DNA 2000"></a>3.DNA 2000</h2><p>Microsoft DNA 2000 是 Microsoft 在推出 Windows 2000 系列操作系统平台的基础上， 在扩展了分布计算模型，以及改造 Back Office 系列服务器端分布计算产品后发布的新的分 布计算架构和规范。在服务器端，DNA 2000 提供了 ASP、COM、Cluster 等的应用支持。</p><h1 id="二、应用系统簇与构件系统"><a href="#二、应用系统簇与构件系统" class="headerlink" title="二、应用系统簇与构件系统"></a>二、应用系统簇与构件系统</h1><p>除专门开发构件的企业外，开发应用系统的企业也会发展自己的构件应用体系:通常是 随着企业的不断成熟，逐步从已开发的应用系统中整理出来一些构件，反过来，将这些构件 复用到优化与整合已有应用系统中或复用于开发新的应用系统。</p><p>应用系统和构件系统都是系统产品(而不是工作产品)。它们都可以采用模型和结构的 类型定义出来。一般情况下，构件系统只在开发单位内部使用，而应用系统提供给外部客户， 与应用系统相比，构件系统具有通用性，可复用性，这就要求构件系统的开发过程应当实施 更为严格的工程规范。</p><p>应用系统可以向构件系统输入构件(构件的需求源于应用系统或应用系统中的模块)，反 过来，构件系统向应用系统输出构件。这就是构件系统如何获得构件和如何提供构件的方式。</p><h1 id="三、基于复用开发的组织结构"><a href="#三、基于复用开发的组织结构" class="headerlink" title="三、基于复用开发的组织结构"></a>三、基于复用开发的组织结构</h1><p>基于复用的开发组织与传统的开发组织结构不同，它需要有一部分用于开发可复用资产 的资源，这部分资源应同具体应用系统的开发资源分开，以确保不被占用。</p><p>一种较平衡的组织结构如图所示，它有三类职能部门:一是构件系统开发部门， 它开发可复用资产;二是应用系统项目开发部(多个)，它复用资产;三是支持部门，这个 部门是可选的，它进一步隔离上述两主体部门，虽然牺牲了一些效率，但保证了构件的规范 性。它的主要职责是对构件开发部门所提供的可复用资产进行确认、对构件库进行分类编目、 向开发应用系统的工程师们发通告和分发可复用资产、提供必要的文档、从复用者处收集反 馈信息和缺陷报告。<br><img src="/images/ruankao/6-51.png"><br>一方面，构件开发者应当尽量接近应用开发者，以使其开发出的构件能尽量符合实际需 要;另一方面，构件开发者与应用开发者分属两个并列的部门，使构件开发者能摆脱应用项 目的日常压力，保证可复用资产的开发和持续改进。复用经理应当在构件开发和应用 项目开发利益之间进行权衡，保证长期目标不受近期项目压力的影响。</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-软件架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件架构设计（八）软件架构评估</title>
      <link href="/2021/09/27/%E8%BD%AF%E8%80%83/9%E3%80%81%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%85%AB%EF%BC%89%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AF%84%E4%BC%B0/"/>
      <url>/2021/09/27/%E8%BD%AF%E8%80%83/9%E3%80%81%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%85%AB%EF%BC%89%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AF%84%E4%BC%B0/</url>
      
        <content type="html"><![CDATA[<p>软件架构评估是在对架构分析、评估的基础上，对架构策略的选取进行决策。它也可以灵活地运用于对软件架构进行评审等工作中。</p><h1 id="一、软件架构评估的方法"><a href="#一、软件架构评估的方法" class="headerlink" title="一、软件架构评估的方法"></a>一、软件架构评估的方法</h1><p>业界已开发出多种软件架构评估的方法，按基于的技术手段来看，可以分为三类:基于调查问卷或检查表的方式、基于场景的方式和基于度量的方式。</p><h2 id="1-基于调查问卷或检查表的方式"><a href="#1-基于调查问卷或检查表的方式" class="headerlink" title="(1)基于调查问卷或检查表的方式"></a>(1)基于调查问卷或检查表的方式</h2><p>该方式的关键是要设计好问卷或检查表，它充分 利用系统相关人员的经验和知识，获得对架构的评估。其缺点是在很大程度上依赖于评估人 员的主观推断。</p><h2 id="2-基于场景的方式"><a href="#2-基于场景的方式" class="headerlink" title="(2)基于场景的方式"></a>(2)基于场景的方式</h2><p>基于场景的方式由 SEI 首先提出并应用在架构权衡分析法 (Architecture Tradeoff Analysis Method，ATAM)和软件架构分析方法(Software Architecture Analysis Method，SAAM)中。它是通过分析软件架构对场景(也就是对系统的使用或修改 活动)的支持程度，从而判断该架构对这一场景所代表的质量需求的满足程度。</p><h2 id="3-基于度量的方式"><a href="#3-基于度量的方式" class="headerlink" title="(3)基于度量的方式"></a>(3)基于度量的方式</h2><p>它是建立在软件架构度量的基础上的，涉及三个基本活动，首 先需要建立质量属性和度量之间的映射原则，即确定怎样从度量结果推出系统具有什么样的 质量属性;然后从软件架构文档中获取度量信息;最后根据映射原则分析推导出系统的质量 属性。它能提供更为客观和量化的质量评估，但它对评估人员及其使用的技术有较高 的要求。ATAM 中也使用了度量的思想(度量效用)。</p><h1 id="二、架构的权衡分析法"><a href="#二、架构的权衡分析法" class="headerlink" title="二、架构的权衡分析法"></a>二、架构的权衡分析法</h1><p>从技术角度对软件架构进行评估，旨在通过分析来预见软件的质量;通过分析来创建、 选择、评估与比较不同的架构。</p><p>ATAM 方法不但能够揭示架构如何满足特定的质量需求(例如，性能和可修改性)，而且还 提供了分析这些质量需求之间交互作用的方法。使用 ATAM 方法评价一个软件架构的目的 是理解架构设计满足系统质量需求的结果。</p><p>ATAM 产生如下结果。<br>(1)一个简洁的架构表述:ATAM 的一个要求是在一小时内表述架构，这样就得到了 一个简洁、可理解的、面向普通项目关系人的架构表述。它是从架构文档中提炼形成的。<br>(2)表述清楚的业务目标。<br>(3)用场景集合捕获质量需求。<br>(4)架构决策到质量需求的映射。<br>(5)所确定的敏感点和权衡点集合。<br>(6)有风险决策和无风险决策。<br>(7)风险主题的集合。<br>(8)产生一些附属结果。<br>(9)还产生一些无形结果，如能够使项目关系人产生“团队感”，提供了一个交流平台和沟通渠道，使大家更好地理解架构(优势及弱点)。</p><p>ATAM 的 9 个步骤如下。<br>(1)ATAM 方法的表述:评估负责人向参加会议的项目代表介绍 ATAM(简要描述 ATAM步骤和评估的结果)。<br>(2)商业动机的表述。<br>(3)架构的表述。<br>(4)对架构方法进行分类。<br>(5)生成质量属性效用树。<br>根——质量属性——属性求精(细分)——场景(叶)。修剪这棵树，保留重要场景(不超过 50 个)，再对场景按重要性给定 优先级(用 H/M/L 的形式)，再按场景实现的难易度来确定优先级(用 H/M/L 的形式)， 这样对所选定的每个场景就有一个优先级对(重要度，难易度)，如(H，L)表示该场景重要且易实现。<br>(6)分析架构方法。<br>评估小组按优先级对上述效用树的场景进行分析(小组成员提问，设计师回答、解释)，探查实现场景的架构方法。<br>(7)集体讨论并确定场景的优先级。<br>(8)分析架构方法。<br>(9)结果的表述。</p><p>结果的表述包括：<br>已编写了文档的架构方法;<br>经过讨论得到的场景集合及其优先级;<br>效用树;<br>所发现的有风险决策;<br>已编成文档的无风险决策;<br>所发现的敏感点和权衡点。</p><h1 id="三、成本效益分析法"><a href="#三、成本效益分析法" class="headerlink" title="三、成本效益分析法"></a>三、成本效益分析法</h1><p>成本效益分析法(the Cost Benefit Analysis Method，CBAM)是在 ATAM 上构建，用来对架构设计决策的成本和收益进行建模，是优 化此类决策的一种手段。CBAM 的思想就是架构策略影响系统的质量属性，反过来这些质量 属性又会为系统的项目关系人带来一些收益(称为“效用”)，CBAM 协助项目关系人根据其 投资回报(ROI)选择架构策略。CBAM 在 ATAM 结束时开始，它实际上使用了 ATAM 评 估的结果。</p><p>CBAM 的步骤如下。</p><h2 id="1-整理场景。"><a href="#1-整理场景。" class="headerlink" title="(1)整理场景。"></a>(1)整理场景。</h2><p>整理 ATAM 中获取的场景，根据商业目标确定这些场景的优先级，并 选取优先级最高的 1/3 的场景进行分析。</p><h2 id="2-对场景进行求精。"><a href="#2-对场景进行求精。" class="headerlink" title="(2)对场景进行求精。"></a>(2)对场景进行求精。</h2><p>为每个场景获取最坏情况、当前情况、期望情况和最好情况的 质量属性响应级别。</p><h2 id="3-确定场景的优先级。"><a href="#3-确定场景的优先级。" class="headerlink" title="(3)确定场景的优先级。"></a>(3)确定场景的优先级。</h2><p>项目关系人对场景进行投票，其投票是基于每个场景“所期 望的”响应值，根据投票结果和票的权值，生成一个分值(场景的权值)。</p><h2 id="4-分配效用。"><a href="#4-分配效用。" class="headerlink" title="(4)分配效用。"></a>(4)分配效用。</h2><p>对场景的响应级别(最坏情况、当前情况、期望情况和最好情况)确 定效用表。</p><h2 id="5-策略—场景—响应级别"><a href="#5-策略—场景—响应级别" class="headerlink" title="(5)策略—场景—响应级别"></a>(5)策略—场景—响应级别</h2><p>架构策略涉及哪些质量属性及响应级别，形成相关的策略—场景—响应级别的对 应关系。</p><h2 id="6-确定“期望的”效用表"><a href="#6-确定“期望的”效用表" class="headerlink" title="(6)确定“期望的”效用表"></a>(6)确定“期望的”效用表</h2><p>使用内插法确定“期望的”质量属性响应级别的效用。即根据第 4 步的效用表以 及第 5 步的对应关系，确定架构策略及其对应场景的效用表。</p><h2 id="7-计算各架构策略的总收益。"><a href="#7-计算各架构策略的总收益。" class="headerlink" title="(7)计算各架构策略的总收益。"></a>(7)计算各架构策略的总收益。</h2><p>根据第 3 步的场景的权值及第 6 步的架构策略效用 表，计算出架构策略的总收益得分。</p><h2 id="8-确定选取策略的优先级"><a href="#8-确定选取策略的优先级" class="headerlink" title="(8)确定选取策略的优先级"></a>(8)确定选取策略的优先级</h2><p>根据受成本限制影响的 ROI(Return On Investment，投资报酬率)选择架构策略。 根据开发经验估算架构策略的成本，结合第 7 步的收益，计算出架构策略的 ROI，按 ROI 排 序，从而确定选取策略的优先级。</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-软件架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件架构设计（十）产品线及系统演化</title>
      <link href="/2021/09/27/%E8%BD%AF%E8%80%83/9%E3%80%81%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%8D%81%EF%BC%89%E4%BA%A7%E5%93%81%E7%BA%BF%E5%8F%8A%E7%B3%BB%E7%BB%9F%E6%BC%94%E5%8C%96/"/>
      <url>/2021/09/27/%E8%BD%AF%E8%80%83/9%E3%80%81%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%8D%81%EF%BC%89%E4%BA%A7%E5%93%81%E7%BA%BF%E5%8F%8A%E7%B3%BB%E7%BB%9F%E6%BC%94%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>软件企业追求长远的发展，通常采用产品线模型及系统演化策略，它实质上是用架构技 术构建产品线，并在此基础上借助复用技术持续演化，不断地推出新产品，满足市场追求产 品升级换代的需求。</p><h1 id="一、复用与产品线"><a href="#一、复用与产品线" class="headerlink" title="一、复用与产品线"></a>一、复用与产品线</h1><p>软件产品线是指一组软件密集型系统，它们共享一个公共的、可管理的特性集，满足某 个特定市场或任务的具体需要，是以规定的方式用公共的核心资产集成开发出来的。即围绕 核心资产库进行管理、复用、集成新的系统。</p><p>核心资产库包括软件架构及其可剪裁的元素， 更广泛地，它还包括设计方案及其文档、用户手册、项目管理的历史记录(如预算和进度)、 软件测试计划和测试用例。</p><p>可复用的资 产非常广，包括以下几点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">需求</span><br><span class="line">架构设计</span><br><span class="line">元素:元素复用不只是简单的代码复用，它旨在捕获并复用设计中的可取之处，避免(不要 重复)设计失败的地方。</span><br><span class="line">建模与分析</span><br><span class="line">测试：如测试用例、测试数据、测试工具，甚至 测试计划、过程、沟通渠道都可以得到复用。</span><br><span class="line">项目规划：利用经验对项目的成本、预算、进度及开发小组的安排等进行预测，即不必每次 都建立工作分解结构。</span><br><span class="line">过程、方法和工具</span><br><span class="line">人员</span><br><span class="line">样本系统:将已部署(投产)的产品作为高质量的演示原型和工程设计原型。</span><br><span class="line">缺陷消除:产品线开发中积累的缺陷消除活动，可使新系统受益</span><br></pre></td></tr></table></figure><h1 id="二、基于产品线的架构"><a href="#二、基于产品线的架构" class="headerlink" title="二、基于产品线的架构"></a>二、基于产品线的架构</h1><p>软件产品线架构是针对一系列产品而设计的通用架构，并在此基础上，进一步将系列产 品共用的模块事先实现，供直接重用;将架构用框架的形式予以实现，供定制使用。这就是 通常所说的“平台”。</p><p>产品线架构较之单个产品架构，有如下三点特别之处:<br>(1)产品线架构必须考虑一系列明确许可的变化;<br>(2)产品线架构一定要文档化;<br>(3)产品线架构必须提供“产品创建者指南”(开发指南)，描述架构的实例化过程。</p><p>产品线的软件架构应将不变的方面提出来，同时， 识别允许的变化，并提供实现它们的机制。通常应考虑三个方面。<br>(1)确定变化点<br>(2)支持变化点<br>(3)对产品线架构的适宜性进行评估。</p><h1 id="三、产品线的开发模型"><a href="#三、产品线的开发模型" class="headerlink" title="三、产品线的开发模型"></a>三、产品线的开发模型</h1><p>开发(确定)产品线的方法有两种模型:<br>(1)“前瞻性”产品线:利用在应用领域的经验、对市场和技术发展趋势的了解及商业 判断力等进行产品线设计，它反映了企业的战略决策。通常是自上而下地采用产品线方法。<br>(2)“反应性”模型:企业根据以前的产品构建产品家族，并随着新产品的开发，扩展<br>架构和设计方案，它的核心资产库是根据“已经证明”为共有、而非“预先计划”为共有的 元素构建的。通常是自下而上地采用产品线方法。</p><h1 id="四、特定领域软件架构"><a href="#四、特定领域软件架构" class="headerlink" title="四、特定领域软件架构"></a>四、特定领域软件架构</h1><p>架构的本质在于其抽象性。它包括两个方面的抽象:业务抽象和技术抽象。其中业务抽 象面向特定的应用领域。</p><p>特定领域软件架构(Domain Specific Software Architecture，DSSA)可以看做开发产品线 的一个方法(或理论)，它的目标就是支持在一个特定领域中有多个应用的生成。</p><p>DSSA 的 必备特征有:<br>(1)一个严格定义的问题域或解决域;<br>(2)具有普遍性，使其可以用于领域中某个特定应用的开发;<br>(3)对整个领域的合适程度的抽象;<br>(4)具备该领域固定的、典型的在开发过程中的可复用元素。</p><p>从功能覆盖的范围角度理解 DSSA 中领域的含义有两种方法:<br>(1)垂直域。定义了一个特定的系统族，导出在该领域中可作为系统的可行解决方案的一个通用软件架构。<br>(2)水平域。定义了在多个系统和多个系统族中功能区域的共有部分，在子系统级上涵盖多个系统(族)的特定部分功能。</p><p>DSSA 的活动阶段如下。<br>(1)领域分析:主要目标是获得领域模型。即通过分析领域中系统的需求(领域需求)，确定哪些需求是被领域中的系统广泛共享的，从而建立领域模型。<br>(2)领域设计:这个阶段的目标是获得 DSSA，它是一个能够适应领域多个系统的需求的一个高层次的设计。由于领域模型中的领域需求具有一定的变化性，DSSA 也要相应地 具有变化性，它可以通过表示多选一的、可选的解决方案等来做到这一点。<br>(3)领域实现:主要目标是依据领域模型和 DSSA 开发与组织可复用信息。这些复用 信息可以是从现有系统中提取得到的，也可能通过新的开发得到。这个阶段可以看作复用基 础设施的实现阶段。</p><p>领域模型的主要作用如下:<br>(1)领域模型为需求定义了领域知识和领域词汇，这较之单一的项目需求更有较好的 大局观;<br>(2)软件界面的设计往往和领域模型关系密切;<br>(3)领域模型的合理性将严重影响软件系统的可扩展性;<br>(4)在分层架构的指导下，领域模型精化后即成为业务层的骨架;<br>(5)领域模型也是其数据模型的基础;<br>(6)领域模型是团队交流的基础，因为它规定了重要的领域词汇表，并且这些词汇的定义是严格的、大家共同认可的。</p><h1 id="五、架构及系统演化"><a href="#五、架构及系统演化" class="headerlink" title="五、架构及系统演化"></a>五、架构及系统演化</h1><p>架构虽然为系统的变化提供了一定的自由度，但是系统的较大变化必然导致架构的改变。 架构(系统)演化是指向既定的方向、可控地改变。架构(系统)演化可以形成产品线，反 过来，架构(系统)可以在规划的产品线中进行演化。</p><p>架构(系统)演化过程包含 7 个步骤：<br>(1)需求变动归类。首先，必须对用户需求的变化进行归类，使变化的需求与已有构 件对应。对找不到对应构件的变动，也要做好标记，在后续工作中，将创建新的构件，以对 应这部分变化的需求。<br>(2)制订架构演化计划。在改变原有结构之前，开发组织必须制订一个周密的架构演 化计划，作为后续演化开发工作的指南。<br>(3)修改、增加或删除构件。在演化计划的基础上，开发人员可根据在第(1)步得到 的需求变动的归类情况，决定是否修改或删除存在的构件、增加新构件。最后，对修改和增 加的构件进行功能性测试。<br>(4)更新构件的相互作用。随着构件的增加、删除和修改，构件之间的控制流必须得 到更新。<br>(5)构件组装与测试。通过组装支持工具把这些构件的实现体组装起来，完成整个软 件系统的连接与合成，形成新的架构。然后，对组装后的系统整体功能和性能进行测试。<br>(6)技术评审。对以上步骤进行确认，进行技术评审。评审组装后的架构是否反映需 求变动，符合用户需求。如果不符合，则需要在第(2)到第(6)步之间进行迭代。<br>(7)产生演化后的架构。在原来系统上所作的所有修改必须集成到原来的架构中，完 成一次演化过程。</p><p><img src="/images/ruankao/6-52.png"></p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-软件架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件架构设计（三）软件架构风格</title>
      <link href="/2021/09/26/%E8%BD%AF%E8%80%83/9%E3%80%81%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%89%EF%BC%89%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC/"/>
      <url>/2021/09/26/%E8%BD%AF%E8%80%83/9%E3%80%81%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%89%EF%BC%89%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<p>软件架构设计的一个核心问题是能否使用重复的软件架构模式，即能否达到架构级别的 软件重用。</p><p>架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将各个模块和子系统有效地组织成一个完整的系统。</p><p>只要系统是使用常用的、规范的方法来组织，就可使别的设计者很容易地理解系统的架构。</p><h1 id="一、软件架构风格分类"><a href="#一、软件架构风格分类" class="headerlink" title="一、软件架构风格分类"></a>一、软件架构风格分类</h1><p>架构风格的最关键的四要素内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">提供一个词汇表</span><br><span class="line">定义一套配置规则</span><br><span class="line">定义一套语义解释原则</span><br><span class="line">定义对基于这种风格的系统所进行的分析</span><br></pre></td></tr></table></figure><h1 id="二、数据流风格"><a href="#二、数据流风格" class="headerlink" title="二、数据流风格"></a>二、数据流风格</h1><p>批处理序列;管道/过滤器。</p><p>这样的架构下，所有的数据按照流的形式在执行过程中前进，不存在结构的反复和重构。</p><p>在流动过程中，数据经过序列间的数据处理组件进行处理，然后将处理结果向后传送，最后进行输出。</p><h2 id="1-批处理序列"><a href="#1-批处理序列" class="headerlink" title="1. 批处理序列"></a>1. 批处理序列</h2><p>批处理风格的每一步处理都是独立的，并且每一步是顺序执行的。只有当前一步处理完，后一步处理才能开始。数据传送在步与步之间作为一个整体。(组件为一系列固定顺序的计 算单元，组件间只通过数据传递交互。每个处理步骤是一个独立的程序，每一步必 须在前一步结束后才能开始，数据必须是完整的，以整体的方式传递)</p><p>批处理的典型应用:<br>(1)经典数据处理;<br>(2)程序开发;<br>(3)Windows 下的 BAT 程序就是这种应用的典型实例。</p><h2 id="2-管道和过滤器"><a href="#2-管道和过滤器" class="headerlink" title="2. 管道和过滤器"></a>2. 管道和过滤器</h2><p>在管道/过滤器风格的软件架构中，每个构件都有一组输入和输出，构件读输入的数据流，经过内部处理，然后产生输出数据流。这个过程通常通过对输入流的变换及增量计算来 完成，所以在输入被完全消费之前，输出便产生了。</p><p>管道/过滤器架构的例子:<br>(1)以 UNIX shell 编写的程序；<br>(2)传统的编译器。</p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>(1)使得软构件具有良好的隐蔽性和高内聚、低耦合的特点;<br>(2)允许设计者将整个系统的输入/输出行为看成是多个过滤器的行为的简单合成;<br>(3)支持软件重用<br>(4)系统维护和增强系统性能简单<br>(5)允许对一些如吞吐量、死锁等属性的分析;<br>(6)支持并行执行</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>(1)通常导致进程成为批处理的结构<br>(2)不适合处理交互的应用<br>(3)因为在数据传输上没有通用的标准，每个过滤器都增加了解析和合成数据的工作， 这样就导致了系统性能下降，并增加了编写过滤器的复杂性。</p><h2 id="3-批处理序列风格与管道过滤器风格对比"><a href="#3-批处理序列风格与管道过滤器风格对比" class="headerlink" title="3.批处理序列风格与管道过滤器风格对比"></a>3.批处理序列风格与管道过滤器风格对比</h2><p>共同点:把任务分成一系列固定顺序的计算单元(组件)。组件间只通过数据传递交互。</p><p>区别:批处理是全部的、高潜伏性的，输入时可随机存取，无合作性、无交互性。而管道过滤器是递增的，数据结果延迟小，输入时处理局部化，有反馈、可交互。批处理强调数据传送在步与步之间作为一个整体，而管理过滤器无此要求。</p><h1 id="三、调用-返回风格"><a href="#三、调用-返回风格" class="headerlink" title="三、调用/返回风格"></a>三、调用/返回风格</h1><p>主程序/子程序;面向对象风格;层次结构。</p><p>利用调用-返回实际上是一种分而治之的策略，其主要思想是将一个复杂的大系统分解为一些子系统，以便降低复杂度，并且增加可修改性。</p><h2 id="1-主程序-子程序"><a href="#1-主程序-子程序" class="headerlink" title="1. 主程序/子程序"></a>1. 主程序/子程序</h2><p>主程序/子程序风格是结构化开发时期的经典架构风格。这种风格一般采用单线程控制，把问题划分为若干处理步骤，构件即为主程序和子程序。</p><h2 id="2-面向对象风格"><a href="#2-面向对象风格" class="headerlink" title="2. 面向对象风格"></a>2. 面向对象风格</h2><p>这种风格建立在数据抽象和面向对象的基础上，数据的表示方法和它们的相应操作封装在一个抽象数据类型或对象中。这种风格的构件是对象，或者说是抽象数据类型的实例。</p><p>这种风格的两个重要特征为:<br>(1)对象负责维护其表示的完整性;<br>(2)对象的表示对其他对象而言是隐蔽的。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>(1)因为对象对其他对象隐藏它的表示，所以可以改变一个对象的表示，而不影响其他的对象;<br>(2)设计者可将一些数据存取操作的问题分解成一些交互的代理程序的集合。</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>(1)为了使一个对象和另一个对象通过过程调用等进行交互，必须知道对象的标识。只要一个对象的标识改变了，就必须修改所有其他明确调用它的对象;<br>(2)必须修改所有显式调用它的其他对象，并消除由此带来的一些副作用。例如，如果 A 使用了对象 B，C 也使用了对象 B，那么，C 对 B 的使用所造成的对 A 的影响可能是料想不到的。</p><h3 id="3-层次结构风格"><a href="#3-层次结构风格" class="headerlink" title="3. 层次结构风格"></a>3. 层次结构风格</h3><p>层次系统组织成一个层次结构，每一层为上层服务，并作为下层客户。在一些层次系统中，除了一些精心挑选的输出函数外，内部的层只对相邻的层可见。</p><p>这种风格支持基于可增加抽象层的设计。允许将一个复杂问题分解成一个增量步 骤序列的实现。由于每一层最多只影响两层，同时只要给相邻层提供相同的接口，允许每层 用不同的方法实现，同样为软件重用提供了强大的支持。</p><p>层次系统最广泛的应用是分层通信协议。</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>(1)支持基于抽象程度递增的系统设计，使设计者可以把一个复杂系统按递增的步骤进行分解;<br>(2)支持功能增强，因为每一层至多和相邻的上下层交互，因此功能的改变最多影响相邻的上下层;<br>(3)支持重用。只要提供的服务接口定义不变，同一层的不同实现可以交换使用。这样，就可以定义一组标准的接口，而允许各种不同的实现方法。</p><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><p>(1)并不是每个系统都可以很容易地划分为分层的模式，甚至即使一个系统的逻辑结构是层次化的，出于对系统性能的考虑，系统设计师不得不把一些低级或高级的功能综合起来;<br>(2)很难找到一个合适的、正确的层次抽象方法。</p><h1 id="四、独立构件风格"><a href="#四、独立构件风格" class="headerlink" title="四、独立构件风格"></a>四、独立构件风格</h1><p>进程通信;事件系统。</p><p>独立构件风格主要强调系统中的每个构件都是相对独立的个体，它们之间不直接通信，以降低耦合度，提升灵活性。</p><h2 id="1-进程通信架构风格"><a href="#1-进程通信架构风格" class="headerlink" title="1. 进程通信架构风格"></a>1. 进程通信架构风格</h2><p>构件是独立的过程，连接件是消息传递。这 种风格的特点是构件通常是命名过程，消息传递的方式可以是点到点、异步和同步方式及远 过程调用等。</p><h2 id="2-事件系统风格"><a href="#2-事件系统风格" class="headerlink" title="2. 事件系统风格"></a>2. 事件系统风格</h2><p>基于事件的隐式调用风格的思想是构件不直接调用一个过程，而是触 发或广播一个或多个事件。系统中的其他构件中的过程在一个或多个事件中注册，当一个事 件被触发，系统自动调用在这个事件中注册的所有过程。</p><p>基于事件的隐式调用风格的主要特点是事件的触发者并不知道哪些构件会被这些事件影响。</p><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p>(1)为软件重用提供了强大的支持。当需要将一个构件加入现存系统中时，只需将它注册到系统的事件中。<br>(2)为改进系统带来了方便。当用一个构件代替另一个构件时，不会影响到其他构件的接口。</p><h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><p>(1)构件放弃了对系统计算的控制。一个构件触发一个事件时，不能确定其他构件是否会响应它。而且即使它知道事件注册了哪些构件的过程，它也不能保证这些过程被调用的顺序。<br>(2)数据交换的问题。有时数据可被一个事件传递，但另一些情况下，基于事件的系统必须依靠一个共享的仓库进行交互。在这些情况下，全局性能和资源管理便成了问题。<br>(3)既然过程的语义必须依赖于被触发事件的上下文约束，关于正确性的推理存在问题。</p><h1 id="五、虚拟机风格"><a href="#五、虚拟机风格" class="headerlink" title="五、虚拟机风格"></a>五、虚拟机风格</h1><p>解释器;基于规则的系统。</p><p>虚拟机风格的基本思想是人为构建一个运行环境，在这个环境之上，可以解析与运行自定义的一些语言，这样来增加架构的灵活性。</p><h2 id="1-解释器"><a href="#1-解释器" class="headerlink" title="1.解释器"></a>1.解释器</h2><p>一个解释器通常包括完成解释工作的解释引擎，一个包含将被解释的代码的存储区，一 个记录解释引擎当前工作状态的数据结构，以及一个记录源代码被解释执行进度的数据结构。</p><p>解释器通常被用来建立一种虚拟机以弥合程序语义与硬件语义之间的差异。其缺点是执行效率较低。</p><h2 id="2-规则为中心"><a href="#2-规则为中心" class="headerlink" title="2. 规则为中心"></a>2. 规则为中心</h2><p>基于规则的系统包括规则集、规则解释器、规则/数据选择器及工作内存。</p><h1 id="六、仓库风格"><a href="#六、仓库风格" class="headerlink" title="六、仓库风格"></a>六、仓库风格</h1><p>数据库系统;超文本系统;黑板系统。</p><h2 id="1-数据库系统"><a href="#1-数据库系统" class="headerlink" title="1.数据库系统"></a>1.数据库系统</h2><p>数据库架构是库风格最常见的形式。构件主要有两大类，一个是中央共享数据源，保存当前系统的数据状态;另一个是多个独立处理元素，处理元素对数据元素进行操作。</p><h2 id="2-超文本系统"><a href="#2-超文本系统" class="headerlink" title="2.超文本系统"></a>2.超文本系统</h2><p>超文本系统的典型代表，就是早期的静态网页。</p><h2 id="3-黑板系统"><a href="#3-黑板系统" class="headerlink" title="3.黑板系统"></a>3.黑板系统</h2><p>黑板系统是一种问题求解模型，是组织推理的步骤、控制状态数据和问题求解之领域知识的概念框架，它将问题的解空间组织成一个或多个应用相关的分级结构。分级结构的每一层信息由一个唯一的词汇来描述，它代表了问题的部分解。<br><img src="/images/ruankao/6-38.png"></p><p>黑板系统主要由三部分组成:<br>(1)知识源。知识源中包含独立的、与应用程序相关的知识，知识源之间不直接进行 通信，它们之间的交互只通过黑板来完成。<br>(2)黑板数据结构。黑板数据是按照与应用程序相关的层次来组织的解决问题的数据， 知识源通过不断地改变黑板数据来解决问题。<br>(3)控制。控制完全由黑板的状态驱动，黑板状态的改变决定使用的特定知识。</p><hr><p><img src="/images/ruankao/6-39.png"></p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-软件架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件架构设计（五）面向服务的架构</title>
      <link href="/2021/09/26/%E8%BD%AF%E8%80%83/9%E3%80%81%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%94%EF%BC%89%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84/"/>
      <url>/2021/09/26/%E8%BD%AF%E8%80%83/9%E3%80%81%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%94%EF%BC%89%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>迄今为止，对于面向服务的架构(Service-Oriented Architecture，SOA)还没有一个公认 的定义。许多组织从不同的角度和不同的侧面对 SOA 进行了描述，较为典型的有以下三个:</p><p>(1)W3C 的定义:SOA 是一种应用程序架构，在这种架构中，所有功能都定义为独 立的服务，这些服务带有定义明确的可调用接口，能够以定义好的顺序调用这些服务来形成 业务流程。</p><p>(2)Service-architecture.com 的定义:服务是精确定义、封装完善、独立于其他服务 所处环境和状态的函数。SOA 本质上是服务的集合，服务之间彼此通信，这种通信可能是 简单的数据传送，也可能是两个或更多的服务协调进行某些活动。服务之间需要某些方法进 行连接。</p><p>(3)Gartner 的定义:SOA 是一种 C/S 架构的软件设计方法，应用由服务和服务使用 者组成，SOA 与大多数通用的 C/S 架构模型不同之处，在于它着重强调构件的松散耦合， 并使用独立的标准接口。</p><h1 id="一、SOA概述"><a href="#一、SOA概述" class="headerlink" title="一、SOA概述"></a>一、SOA概述</h1><p>SOA 是一种在计算环境中设计、开发、部署和管理离散逻辑单元(服务)模型的方法。 SOA 并不是一个新鲜事物，而只是面向对象模型的一种替代。虽然基于 SOA 的系统并不排 除使用 OOD 来构建单个服务，但是其整体设计却是面向服务的。由于 SOA 考虑到了系统 内的对象，所以虽然 SOA 是基于对象的，但是作为一个整体，它却不是面向对象的。</p><p><img src="/images/ruankao/6-43.png"></p><p>在 SOA 模型中，所有的功能都定义成了独立的服务。服务之间通过交互和协调完成业 务的整体逻辑。所有的服务通过服务总线或流程管理器来连接。这种松散耦合的架构使得各 服务在交互过程中无需考虑双方的内部实现细节，以及部署在什么平台上。</p><h2 id="1-服务的基本结构"><a href="#1-服务的基本结构" class="headerlink" title="1. 服务的基本结构"></a>1. 服务的基本结构</h2><p><img src="/images/ruankao/6-44.png"></p><p>服务模型的表示层从逻辑层分离出来，中间增加了服务对外的接 口层。通过服务接口的标准化描述，使得服务可以提供给在任何异构平台和任何用户接口使 用。这允许并支持基于服务的系统成为松散耦合、面向构件和跨技术实现，服务请求者很可 能根本不知道服务在哪里运行、是由哪种语言编写的，以及消息的传输路径，而是只需要提 出服务请求，然后就会得到答案。</p><h2 id="2-SOA-设计原则"><a href="#2-SOA-设计原则" class="headerlink" title="2.SOA 设计原则"></a>2.SOA 设计原则</h2><p>在 SOA 架构中，继承了来自对象和构件设计的各种原则。</p><p>关于服务，一些常见的设计原则如下:</p><h3 id="1-明确定义的接口。"><a href="#1-明确定义的接口。" class="headerlink" title="(1)明确定义的接口。"></a>(1)明确定义的接口。</h3><p>服务请求者依赖于服务规约来调用服务，因此，服务定义必须 长时间稳定，一旦公布，不能随意更改;服务的定义应尽可能明确，减少请求者的不适当使 用;不要让请求者看到服务内部的私有数据。</p><h3 id="2-自包含和模块化。"><a href="#2-自包含和模块化。" class="headerlink" title="(2)自包含和模块化。"></a>(2)自包含和模块化。</h3><p>服务封装了那些在业务上稳定、重复出现的活动和构件，实现 服务的功能实体是完全独立自主的，独立进行部署、版本控制、自我管理和恢复。</p><h3 id="3-粗粒度。"><a href="#3-粗粒度。" class="headerlink" title="(3)粗粒度。"></a>(3)粗粒度。</h3><p>服务数量不应该太多，依靠消息交互而不是远程过程调用，通常消息量 比较大，但是服务之间的交互频度较低。</p><h3 id="4-松耦合。"><a href="#4-松耦合。" class="headerlink" title="(4)松耦合。"></a>(4)松耦合。</h3><p>服务请求者可见的是服务的接口，其位置、实现技术、当前状态和私有 数据等，对服务请求者而言是不可见的。</p><h3 id="5-互操作性、兼容和策略声明。"><a href="#5-互操作性、兼容和策略声明。" class="headerlink" title="(5)互操作性、兼容和策略声明。"></a>(5)互操作性、兼容和策略声明。</h3><p>为了确保服务规约的全面和明确，策略成为一个越 来越重要的方面。</p><h2 id="3-服务构件与传统构件"><a href="#3-服务构件与传统构件" class="headerlink" title="3. 服务构件与传统构件"></a>3. 服务构件与传统构件</h2><p>服务构件架构(Service Component Architecture，SCA)是基于 SOA 的思想描述服务之间组合和协作的规范，它描述用于使用 SOA 构建应用程序和系统的模型。它可简化使用 SOA 进行的应用程序开发和实现工作。SCA 提供了构建粗粒度构件的机制，这些粗粒度构 件由细粒度构件组装而成。SCA 将传统中间件编程从业务逻辑分离出来，从而使程序员免 受其复杂性的困扰。它允许开发人员集中精力编写业务逻辑，而不必将大量的时间花费在更 为底层的技术实现上。</p><p>SCA 服务构件与传统构件的主要区别在于，服务构件往往是粗粒度的，而传统构件以 细粒度居多;服务构件的接口是标准的，主要是服务描述语言接口，而传统构件常以具体 API 形式出现;服务构件的实现与语言是无关的，而传统构件常绑定某种特定的语言;服务构件 可以通过构件容器提供 QoS 的服务，而传统构件完全由程序代码直接控制。</p><h1 id="二、SOA-的关键技术"><a href="#二、SOA-的关键技术" class="headerlink" title="二、SOA 的关键技术"></a>二、SOA 的关键技术</h1><p>SOA 是一种全新的架构，为了支持其各种特性，相关的技 术规范不断推出。与 SOA 紧密相关的技术主要有 UDDI、WSDL、SOAP 和 REST 等，而这 些技术都是以 XML 为基础而发展起来的。</p><h2 id="1-UDDI"><a href="#1-UDDI" class="headerlink" title="1. UDDI"></a>1. UDDI</h2><p>UDDI(Universal DescriptionDiscovery and Integration，统一描述、发现和集成)提供了 一种服务发布、查找和定位的方法，是服务的信息注册规范，以便被需要该服务的用户发现 和使用它。UDDI 规范描述了服务的概念，同时也定义了一种编程接口。通过 UDDI 提供的 标准接口，企业可以发布自己的服务供其他企业查询和调用，也可以查询特定服务的描述信 息，并动态绑定到该服务上。</p><p>UDDI包括：<br>(1)数据模型。UDDI 数据模型是一个用于描述业务组织和服务的 XML Schema。<br>(2)API。UDDI API 是一组用于查找或发布 UDDI 数据的方法，UDDI API 基于 SOAP。<br>(3)注册服务。UDDI 注册服务是 SOA 中的一种基础设施，对应着服务注册中心的角<br>色。</p><h2 id="2-WSDL"><a href="#2-WSDL" class="headerlink" title="2.WSDL"></a>2.WSDL</h2><p>WSDL(Web ServiceDescription Language，Web 服务描述语言)是对服务进行描述的语言，它有一套基于 XML 的语法定义。WSDL 描述的重点是服务，它包含服务实现定义和服 务接口定义。</p><p><img src="/images/ruankao/6-45.png"><br>服务实现定义描述了给定服务提供者如何实现特定的服务接口。服务实现定义中包含服 务和端口描述。一个服务往往会包含多个服务访问入口，而每个访问入口都会使用一个端口 元素来描述，端口描述的是一个服务访问入口的部署细节，例如，通过哪个地址来访问，应 当使用怎样的消息调用模式来访问等。</p><h2 id="3-SOAP"><a href="#3-SOAP" class="headerlink" title="3.SOAP"></a>3.SOAP</h2><p>SOAP(Simple ObjectAccess Protocol，简单对象访问协议)定义了服务请求者和服务提 供者之间的消息传输规范。SOAP 用 XML 来格式化消息，用 HTTP 来承载消息。通过 SOAP， 应用程序可以在网络中进行数据交换和远程过程调用(Remote Procedure Call， RPC)</p><p>SOAP 主要包括以下四个部分:</p><p>(1)封装。SOAP 封装定义了一个整体框架，用来表示消息中包含什么内容，谁来处 理这些内容，以及这些内容是可选的还是必需的。<br>(2)编码规则。SOAP 编码规则定义了一种序列化的机制，用于交换系统所定义的数 据类型的实例。<br>(3)RPC 表示。SOAP RPC 表示定义了一个用来表示远程过程调用和应答的协议。<br>(4)绑定。SOAP 绑定定义了一个使用底层传输协议来完成在节点之间交换 SOAP 封 装的约定。</p><p>SOAP 消息包括以下三个部分:</p><p>(1)封装(信封)。封装的元素名是 Envelope，在表示消息的 XML 文档中，封装是顶 层元素，在 SOAP 消息中必须出现。<br>(2)SOAP 头。SOAP 头的元素名是 Header，提供了向 SOAP 消息中添加关于这条 SOAP 消息的某些要素的机制。<br>(3)SOAP 体。SOAP 体的元素名是 Body，是包含消息的最终接收者想要的信息的容 器。</p><h2 id="4-REST"><a href="#4-REST" class="headerlink" title="4.REST"></a>4.REST</h2><p>REST(RepresentationalState Transfer，表述性状态转移)是一种只使用 HTTP 和 XML 进 行基于 Web 通信的技术，可以降低开发的复杂性，提高系统的可伸缩性。它的简单性和缺 少严格配置文件的特性，使它与 SOAP 很好地隔离开来，REST 从根本上来说只支持几个操 作(POST、GET、PUT 和 DELETE)，这些操作适用于所有的消息。</p><p>REST 提出了如下一些设 计概念和准则:<br>(1)网络上的所有事物都被抽象为资源。<br>(2)每个资源对应一个唯一的资源标识。<br>(3)通过通用的连接件接口对资源进行操作。<br>(4)对资源的各种操作不会改变资源标识。<br>(5)所有的操作都是无状态的。</p><h1 id="三、SOA-的实现方法"><a href="#三、SOA-的实现方法" class="headerlink" title="三、SOA 的实现方法"></a>三、SOA 的实现方法</h1><p>SOA 只是一种概念和思想，需要借助于具体的技术和方法来实现它。从本质上来看， SOA 是用本地计算模型来实现一个分布式的计算应用，也有人称这种方法为“本地化设计，分布式工作”模型。CORBA、DCOM 和 EJB 等都属于这种解决方式。</p><p>从逻辑上和高层抽象来看，目前，实现 SOA 的方法也比较多，其中主流方式有 Web Service、企业服务总线和服务注册表。</p><h2 id="1-Web-Service"><a href="#1-Web-Service" class="headerlink" title="1.Web Service"></a>1.Web Service</h2><p>在 Web Service(Web 服务)的解决方案中，一共有三种工作角色，其中服务提供者和 服务请求者是必需的，服务注册中心是一个可选的角色。</p><p><img src="/images/ruankao/6-46.png"></p><p>在采用 Web Service 作为 SOA 的实现技术时，应用系统大致可以分为六个层次，分别 是底层传输层、服务通信协议层、服务描述层、 服务层、业务流程层和服务注册层。</p><h3 id="1-底层传输层。"><a href="#1-底层传输层。" class="headerlink" title="(1)底层传输层。"></a>(1)底层传输层。</h3><p>底层传输层主要负责消息的传输机制，HTTP、JMS(Java Messaging Service，Java 消息服务)和 SMTP 都可以作为服务的消息传输协议，其中 HTTP 使用最广。</p><h3 id="2-服务通信协议层。"><a href="#2-服务通信协议层。" class="headerlink" title="(2)服务通信协议层。"></a>(2)服务通信协议层。</h3><p>服务通信协议层的主要功能是描述并定义服务之间进行消息传 递所需的技术标准，常用的标准是 SOAP 和 REST 协议。</p><h3 id="3-服务描述层。"><a href="#3-服务描述层。" class="headerlink" title="(3)服务描述层。"></a>(3)服务描述层。</h3><p>服务描述层主要以一种统一的方式描述服务的接口与消息交换方式， 相关的标准是 WSDL。</p><h3 id="4-服务层。"><a href="#4-服务层。" class="headerlink" title="(4)服务层。"></a>(4)服务层。</h3><p>服务层的主要功能是将遗留系统进行包装，并通过发布的 WSDL 接口描 述被定位和调用。</p><h3 id="5-业务流程层。"><a href="#5-业务流程层。" class="headerlink" title="(5)业务流程层。"></a>(5)业务流程层。</h3><p>业务流程层的主要功能是支持服务发现，服务调用和点到点的服务 调用，并将业务流程从服务的底层调用抽象出来。</p><h3 id="6-服务注册层"><a href="#6-服务注册层" class="headerlink" title="(6)服务注册层"></a>(6)服务注册层</h3><p>服务注册层的主要功能是使服务提供者能够通过 WSDL 发布服务定义，并支持服 务请求者查找所需的服务信息。相关的标准是 UDDI。</p><h2 id="2-服务注册表"><a href="#2-服务注册表" class="headerlink" title="2. 服务注册表"></a>2. 服务注册表</h2><p>服务注册表(service registry)虽然也具有运行时的功能，但主要在 SOA 设计时使用。</p><p>服务注册表可以包括有关服务和相关构件的配置、依从性和 约束文件。</p><p>大多数商用服务注册产品支持服务注册、服务位置和服务绑定功能。</p><h2 id="3-企业服务总线ESB"><a href="#3-企业服务总线ESB" class="headerlink" title="3. 企业服务总线ESB"></a>3. 企业服务总线ESB</h2><p>ESB 是由中间件技术实现并支持 SOA 的一组基础架构，是传统中间件技术与 XML、 Web Service 等技术结合的产物，是在整个企业集成架构下的面向服务的企业应用集成机制。</p><p>ESB 具有以下功能:<br>(1)支持异构环境中的服务、消息和基于事件的交互，并且具有适当的服务级别和可 管理性。<br>(2)通过使用 ESB，可以在几乎不更改代码的情况下，以一种无缝的非侵入方式使现 有系统具有全新的服务接口，并能够在部署环境中支持任何标准。<br>(3)充当缓冲器的 ESB(负责在诸多服务之间转换业务逻辑和数据格式)与服务逻辑 相分离，从而使不同的系统可以同时使用同一个服务，不用在系统或数据发生变化时，改动 服务代码。<br>(4)在更高的层次，ESB 还提供诸如服务代理和协议转换等功能。允许在多种形式下 通过像 HTTP、SOAP 和 JMS 总线的多种传输方式，主要是以网络服务的形式，为发表、注 册、发现和使用企业服务或界面提供基础设施。<br>(5)提供可配置的消息转换翻译机制和基于消息内容的消息路由服务，传输消息到不 同的目的地。<br>(6)提供安全和拥有者机制，以保证消息和服务使用的认证、授权和完整性。</p><p>与现存的、专有的集成解决方案相比，ESB 具有以下优势:</p><p>(1)扩展的、基于标准的连接。ESB 形成一个基于标准的信息骨架，使得在系统内部<br>和整个价值链中可以容易地进行异步或同步数据交换。ESB 通过使用 XML、SOAP 和其他标 准，提供了更强大的系统连接性。<br>(2)灵活的、服务导向的应用组合。基于 SOA，ESB 使复杂的分布式系统(包括跨多 个应用、系统和防火墙的集成方案)能够由以前开发测试过的服务组合而成，使系统具有高 度可扩展性。<br>(3)提高复用率，降低成本。按照 SOA 方法构建应用，提高了复用率，简化了维护 工作，进而减少了系统总体成本。<br>(4)减少市场反应时间，提高生产率。ESB 通过构件和服务复用，按照 SOA 的思想 简化应用组合，基于标准的通信、转换和连接来实现这些优点。</p><h1 id="四、微服务"><a href="#四、微服务" class="headerlink" title="四、微服务"></a>四、微服务</h1><p>它属于面向服务架构的一种。<br>微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小 的服务，服务之间互相协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进 程中，服务与服务间采用轻量级的通信机制互相沟通(通常是基于 HTTP 协议的 RESTful API)。每个服务都围绕着具体业务进行构建，并且能够被独立的部署到生产环境、类生产环 境等。</p><p>另外，应当尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根 据业务上下文，选择合适的语言、工具对其进行构建。</p><p>所以总结起来，微服务的核心特点为:小, 且专注于做一件事情、轻量级的通信机制、松耦合、独立部署。</p><h2 id="1-微服务的优势"><a href="#1-微服务的优势" class="headerlink" title="1.微服务的优势"></a>1.微服务的优势</h2><h3 id="1-技术异构性"><a href="#1-技术异构性" class="headerlink" title="(1)技术异构性"></a>(1)技术异构性</h3><p>在微服务架构中，每个服务都是一个相对独立的个体，每个服务都可以选择适合于自身 的技术来实现。</p><p>同时，在应用新技术时，微服务架构也提供了更好的试验场。</p><h3 id="2-弹性"><a href="#2-弹性" class="headerlink" title="(2)弹性"></a>(2)弹性</h3><p>弹性主要讲的是系统中一部分出现故障会引起多大问题。<br>微服务架构中，每个服务可以内置可用性的解决方 案 与功能降级方案，所以比单块系统强。</p><h3 id="3-扩展"><a href="#3-扩展" class="headerlink" title="(3)扩展"></a>(3)扩展</h3><p>在微服务架构中，可以针对单个服务进行扩展。</p><h3 id="4-简化部署"><a href="#4-简化部署" class="headerlink" title="(4)简化部署"></a>(4)简化部署</h3><p>在大型单块系统中，即使修改一行代码，也需要重新部署整个应用系统。<br>微服务架构中，每个服务的部署都是独立的，这样就可以更快地对特定部分的代码进行部署。</p><h3 id="5-与结织结构相匹配"><a href="#5-与结织结构相匹配" class="headerlink" title="(5)与结织结构相匹配"></a>(5)与结织结构相匹配</h3><p>微服务架构可以将架构与组织结构相匹配，避免出现过大的代码库，从而获得 理想的团队大小及生产力。服务的所有权也可以在团队之 间迁移，从而避免异地团队的出 现。</p><h3 id="6-可组合性"><a href="#6-可组合性" class="headerlink" title="(6)可组合性"></a>(6)可组合性</h3><p>在微服务架构中，系统会开放很多接口供外部使用。当情况发生改变时，可以使用不同的方式构建应用，而整体化应用程序只能提供一个非常粗粒度的接口供外部使用。</p><h3 id="7-对可替代性的优化"><a href="#7-对可替代性的优化" class="headerlink" title="(7)对可替代性的优化"></a>(7)对可替代性的优化</h3><p>在微服务架构中，我们可以在需要时轻易地重写服务， 或者删除不再使用的服务。</p><h2 id="2-微服务面临的挑战"><a href="#2-微服务面临的挑战" class="headerlink" title="2. 微服务面临的挑战"></a>2. 微服务面临的挑战</h2><h3 id="1-分布式系统的复杂度"><a href="#1-分布式系统的复杂度" class="headerlink" title="(1)分布式系统的复杂度"></a>(1)分布式系统的复杂度</h3><p>使用微服务实现分布式系统的复杂度要比单块系统高。</p><h3 id="2-运维成本"><a href="#2-运维成本" class="headerlink" title="(2)运维成本"></a>(2)运维成本</h3><p>在微服务架构下，随着服务数量的增多，每个服务都需要独立的配置、部署、 监控、日志收集等，因此成本呈指数级增长。</p><h3 id="3-部署自动化"><a href="#3-部署自动化" class="headerlink" title="(3)部署自动化"></a>(3)部署自动化</h3><p>传统单块系统手动部署是 可以满足需求的。<br>对于微服务架构而言，如何有效地构建自 动化部署流水线，降低部署成本、提高部署频率，是微服务架构下需要面临的一个挑战。。</p><h3 id="4-DevOps-与组织结构"><a href="#4-DevOps-与组织结构" class="headerlink" title="(4)DevOps 与组织结构"></a>(4)DevOps 与组织结构</h3><p>传统单块架构中，团队通常是按技能划分，并通过项目的 方式协作，完成系统交付。</p><p>在微服务架构的实施过程中，除了如上所述的交付、运维上存 在的挑战，在组织或者团队层面，如何传递 DevOps 文化的价值，让团队理解 DevOps 文化的价值，并构建全功能团队，也是一个不小的挑战。</p><h3 id="5-服务间依赖测试"><a href="#5-服务间依赖测试" class="headerlink" title="(5)服务间依赖测试"></a>(5)服务间依赖测试</h3><p>在服务数量较多的情况下，如何有效地保证服务之间能有效按照接口的约定正常工作， 成为微服务实施过程中必须面临的巨大挑战。</p><h3 id="6-服务间依赖管理"><a href="#6-服务间依赖管理" class="headerlink" title="(6)服务间依赖管理"></a>(6)服务间依赖管理</h3><p>随着微服 务个数的增多，如何清晰有效地展示服务之间的依赖关系，成为了一个挑战。</p><h2 id="3-微服务与-SOA"><a href="#3-微服务与-SOA" class="headerlink" title="3.微服务与 SOA"></a>3.微服务与 SOA</h2><p>微服务可以讲是 SOA 的一种，但他们也有一些差异。</p><table><thead><tr><th>微服务</th><th>SOA</th></tr></thead><tbody><tr><td>能拆分的就拆分</td><td>是整体的，服务能放一起的就放一起</td></tr><tr><td>纵向业务划分</td><td>水平分多层</td></tr><tr><td>单一组织负责</td><td>按层次划分不同部门的组织负责</td></tr><tr><td>细粒度</td><td>粗粒度</td></tr><tr><td>两句话可以解释明白</td><td>几百字是相当于SOA的目录</td></tr><tr><td>独立的子公司</td><td>类似大公司里面划分了一些业务单元</td></tr><tr><td>组件小</td><td>存在较复杂的组件</td></tr><tr><td>业务逻辑存在于每一个服务中</td><td>业务逻辑很卡多个业务领域</td></tr><tr><td>使用轻量级的通信方式</td><td>ESB充当了服务之间通信的角色</td></tr></tbody></table><p>实现方面的差异：</p><table><thead><tr><th>微服务架构实现</th><th>SOA实现</th></tr></thead><tbody><tr><td>团队级，自底向上开展实施</td><td>企业级，自顶向下开展实施</td></tr><tr><td>一个系统被拆分成多个服务，粒度细</td><td>服务由多个子系统组成，粒度大</td></tr><tr><td>无集中式总线，松散的服务架构</td><td>企业服务总线，集中式的服务架构</td></tr><tr><td>集成方式简单</td><td>集成方式复杂</td></tr><tr><td>服务能独立部署</td><td>单块架构系统，互相依赖，部署复杂</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-软件架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件架构设计（六）架构设计</title>
      <link href="/2021/09/26/%E8%BD%AF%E8%80%83/9%E3%80%81%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%85%AD%EF%BC%89%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2021/09/26/%E8%BD%AF%E8%80%83/9%E3%80%81%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%85%AD%EF%BC%89%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>架构模式也称为架构风格，它是适当地选取战术的结果，这些固定的结果(模式)在高 层抽象层次上具有普遍实用性和复用性。</p><p>通过架构模式，架构设计师可以借鉴和复用他人的经验，看看类似的问题别人是如何解 决的。但不要把模式看成是一个硬性的解决方法，它只是一种解决问题的思路。</p><p>“模式和业务构件的区别就在于模式会引发你的思考。”</p><h1 id="1-演变交付生命周期"><a href="#1-演变交付生命周期" class="headerlink" title="1.演变交付生命周期"></a>1.演变交付生命周期</h1><p><img src="/images/ruankao/6-47.png"></p><p>在生命周期模型中，架构设计就是从初步的需求分析开始逐步进行循环迭代。即:一方面在了解系统需求前，不能开始设计架构;另一方 面，刚开始进行设计架构时并不需要等到全部需求都收集到。</p><p>架构由少数关键需 求决定并在循环迭代中处于基本稳定状态，它作为演变的基础设施。</p><h1 id="2-属性驱动设计法"><a href="#2-属性驱动设计法" class="headerlink" title="2.属性驱动设计法"></a>2.属性驱动设计法</h1><p>模型强调先建立软件架构，再把架构作为骨架，在骨架上循环迭代，逐步长出有血 有肉的系统之躯。</p><p>属性驱动设计法(Attribute-Driven Design，ADD)就是一种定义软件架构 的方法，该方法将分解过程建立在软件必须满足的质量属性之上。</p><p>ADD 的输入为:功能需 求(一般表示为用例)、限制条件和质量需求(一组特定于系统的质量场景)。</p><p>ADD 的步骤如下：<br>(1)选择要分解的模块。<br>(2)根据如下步骤对模块进行求精:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">从具体的质量场景和功能需求集合中选择架构驱动因素。</span><br><span class="line">选择满足架构驱动因素的架构模式，根据前面的战术创建(或选择)模式。</span><br><span class="line">实例化模块并根据用例分配功能，使用多个视图进行表示。</span><br><span class="line">定义子模块的接口。</span><br><span class="line">验证用例和质量场景，并对其进行求精，使它们成为子模式的限制。</span><br></pre></td></tr></table></figure><p>(3)对需要进一步分解的每个模块重复上述步骤。</p><h1 id="3-按架构组织开发团队"><a href="#3-按架构组织开发团队" class="headerlink" title="3.按架构组织开发团队"></a>3.按架构组织开发团队</h1><p>像软件系统一样，开发小组也应该努力做到松耦合、高内聚。</p><p>项目计划在架构确定之后可以结合分工进一步明细化，特别要规划好接口提供的 时间点，保证项目开发的整体协调性。</p><h1 id="4-开发骨架系统"><a href="#4-开发骨架系统" class="headerlink" title="4.开发骨架系统"></a>4.开发骨架系统</h1><p>演变交付生命周期模型中有两个循环，第一个循环是通过迭代的方式开发出软件架构， 第二个循环是在架构的基础上通过迭代的方式开发出交付的最终版本。开发骨架系统就是第 二个循环的第一步。</p><h1 id="5-利用商用构件进行开发"><a href="#5-利用商用构件进行开发" class="headerlink" title="5.利用商用构件进行开发"></a>5.利用商用构件进行开发</h1><p>模式本来就是针对特定问题的解，因此，针对需求的特点，也可以选用相应的模式来设 计架构，并利用对应于该模式的商用构件进行软件开发。例如可以使用 J2EE/EJB 进行开发 面向对象的分布式系统。</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-软件架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件架构设计（四）层次系统架构风格</title>
      <link href="/2021/09/26/%E8%BD%AF%E8%80%83/9%E3%80%81%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%9B%9B%EF%BC%89%E5%B1%82%E6%AC%A1%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC/"/>
      <url>/2021/09/26/%E8%BD%AF%E8%80%83/9%E3%80%81%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%9B%9B%EF%BC%89%E5%B1%82%E6%AC%A1%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="一、二层及三层-C-S-架构风格"><a href="#一、二层及三层-C-S-架构风格" class="headerlink" title="一、二层及三层 C/S 架构风格"></a>一、二层及三层 C/S 架构风格</h1><h2 id="二层架构"><a href="#二层架构" class="headerlink" title="二层架构"></a>二层架构</h2><p>C/S 架构是基于资源不对等，且为实现共享而提出来的，是 20 世纪 90 年代成熟起来 的技术，C/S 结构将应用一分为二，服务器(后台)负责数据管理，客户机(前台)完成与 用户的交互任务。</p><h3 id="二层架构优点"><a href="#二层架构优点" class="headerlink" title="二层架构优点"></a>二层架构优点</h3><p>具有强大的数据操作和事务处理能力，模型思想简单，易于人们理解和接受</p><h3 id="二层架构缺点"><a href="#二层架构缺点" class="headerlink" title="二层架构缺点"></a>二层架构缺点</h3><p>单一服务器且以局域网为中心<br>软、硬件的组合及集成能力有限;<br>服务器的负荷太重，难以管理大量的客户机，系统的性能容易变坏;<br>数据安全性不好。</p><h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><p>三层 C/S 结构是 将应用功能分成表示层、功能层和数据层三个部分。</p><p><img src="/images/ruankao/6-40.png"></p><h1 id="二、B-S架构风格"><a href="#二、B-S架构风格" class="headerlink" title="二、B/S架构风格"></a>二、B/S架构风格</h1><p>浏览器/服务器(Browser/Server，简称 B/S)风格就是上述三层应用结构的一种实现方 式，其具体结构为:浏览器/Web 服务器/数据库服务器。</p><p>在 B/S 结构中，除了数据库服务器外，应用程序以网页形式存放于 Web 服务器上，用户运行某个应用程序时只需在客户端上的浏览器中键入相应的网址，调用 Web 服务器上 的应用程序并对数据库进行操作完成相应的数据处理工作，最后将结果通过浏览器显示给用 户。可以说，在 B/S 模式的计算机应用系统中，应用(程序)在一定程度上具有集中特征。</p><h2 id="B-S架构优点"><a href="#B-S架构优点" class="headerlink" title="B/S架构优点"></a>B/S架构优点</h2><p>B/S 架构主要是利用不断成熟的 WWW 浏览器技术，结合浏览器的多种脚本语言，用 通用浏览器就实现了原来需要复杂的专用软件才能实现的强大功能，并节约了开发成本。</p><h2 id="B-S架构缺点"><a href="#B-S架构缺点" class="headerlink" title="B/S架构缺点"></a>B/S架构缺点</h2><p>与 C/S 架构相比，B/S 架构也有许多不足之处，例如:<br>(1)B/S 架构缺乏对动态页面的支持能力，没有集成有效的数据库处理功能。<br>(2)采用 B/S 架构的应用系统，在数据查询等响应速度上，要远远地低于 C/S 架构。<br>(3)B/S 架构的数据提交一般以页面为单位，数据的动态交互性不强，不利于在线事 务处理(OnLine Transaction Processing，简称 OLTP)应用。</p><h1 id="三、MVC-架构风格"><a href="#三、MVC-架构风格" class="headerlink" title="三、MVC 架构风格"></a>三、MVC 架构风格</h1><p>MVC 全名是 Model ViewController，是模型(model)-视图(view)-控制器(controller)的 缩写，它是分层架构风格的一种。</p><p>MVC 提出的基本思想是进行关注点分 离。一个典型的人机交互应用具有三个主要的关注点:数据在可视化界面上的呈现、UI 处 理逻辑和业务逻辑。</p><p>传统的自治视图模式(即将与 UI 相关的逻辑都定义在针对视图 的相关元素的事件上)，将三者混合在一起会带来一下问题：</p><p>(1)业务逻辑是与 UI 无关的，应该最大限度地被重用。由于业务逻辑定义在自治视 图中，相当于完全与视图本身绑定在一定，如果我们能够将 UI 的行为抽象出来，基于抽象 化 UI 的处理逻辑也是可以被共享的。但是定义在自治视频中的 UI 处理逻辑完全丧失了重 用的可能。<br>(2)业务逻辑具有最强的稳定性，UI 处理逻辑次之，而可视化界面上的呈现最差(比如我们经常会为了更好地呈现效果来调整 HTML)。如果将具有不同稳定性的元素融为一体，那么具有最差稳定性的元素决定了整体的稳定性。<br>(3)任何涉及 UI 的组件都不易测试。UI 是呈现给人看的，并且用于人机交互，用机 器来模拟活生生的人来对组件实施自动化测试不是一件容易的事，自治视图严重损害了组件 的可测试性。</p><p><img src="/images/ruankao/6-41.png"></p><h1 id="四、MVP-架构风格"><a href="#四、MVP-架构风格" class="headerlink" title="四、MVP 架构风格"></a>四、MVP 架构风格</h1><p>MVP 是从经典的模式 MVC 演变而来。</p><p>MVC 模式中元素之间“混乱”的交互主要体现在允许 View 和 Model 直接进行“交流”，这在 MVP 模式中是不允许的。</p><p>MVP 不仅仅避免了 View 和 Model 之间的耦合，还进一步降低了 Presenter 对 View 的依赖。</p><p><img src="/images/ruankao/6-42.png"></p><h2 id="MVP-的优点"><a href="#MVP-的优点" class="headerlink" title="MVP 的优点"></a>MVP 的优点</h2><p>(1)模型与视图完全分离，我们可以修改视图而不影响模型。 (2)可以更高效地使用模型，因为所有的交互都发生在一个地方—Presenter 内部。<br>(3)我们可以将一个 Presenter 用于多个视图，而不需要改变 Presenter 的逻辑。这个特性非常的有用，因为视图的变化总是比模型的变化频繁。<br>(4)如果我们把逻辑放在 Presenter 中，那么我们就可以脱离用户接口来测试这些逻辑(单元测试)。</p><h2 id="MVP-的缺点"><a href="#MVP-的缺点" class="headerlink" title="MVP 的缺点"></a>MVP 的缺点</h2><p>（1）由于对视图的渲染放在了 Presenter 中，所以视图和 Presenter 的交互会过于频繁。<br>（2）如果 Presenter 过多地渲染了视图，往往会使得它与特定的视图的联系过 于紧密。一旦视图需要变更，那么 Presenter 也需要变更了。</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-软件架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件架构设计（一）软件架构概述</title>
      <link href="/2021/09/25/%E8%BD%AF%E8%80%83/9%E3%80%81%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/"/>
      <url>/2021/09/25/%E8%BD%AF%E8%80%83/9%E3%80%81%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p>通俗地讲，软件架构设计就是软件系统的“布局谋篇”。</p><p>软件架构的研究内容主要涉及软件架构描述、软件架构设计、软件架构风格、软件架构评价和软件架构的形成方法等。</p><p>软件设计人员学习软件架构知识旨在站在较高的层面上整体地解决好软件的设计、复用、质量和维护等方面的实际问题。</p><hr><p>软件架构是软件抽象发展到一定阶段的产物，从编程的角度，可以清晰地看到软件抽象 层次和表达工具的发展历史。</p><p>20 世纪 60 年代是子程序的年代:出现了原始的软件架构，即子程序，并以程序间的调用为连接关系。</p><p>20 世纪 70 年代是模块化的年代:出现了数据流分析、实体—关系图(E-R 图)、信息隐藏等工具和方法，软件的抽象层次发展到了模块级。</p><p>20 世纪 80 年代是面向对象的年代:基于模块化的编程语言进一步发展成面向对象的语言，继承性地增加了一种新元素之间的连接关系。</p><p>20 世纪 90 年代是框架的年代:标准的基于对象的架构以框架的形式出现了。如电子数据表、文档、图形图像、音频剪辑等可互换的黑箱对象，可以相互嵌入。</p><p>当前(最近 10 年来):中间件和 IT 架构作为标准平台出现，用可购买可复用的元素来构建系统，同时，基于架构的开发方法和理论不断成熟。</p><table><thead><tr><th>年代</th><th>60</th><th>70</th><th>80</th><th>90</th><th>当前</th></tr></thead><tbody><tr><td>发展状况</td><td>子程序</td><td>模块化</td><td>面向对象</td><td>框架</td><td>中间件和IT架构</td></tr></tbody></table><h1 id="一、软件架构的定义"><a href="#一、软件架构的定义" class="headerlink" title="一、软件架构的定义"></a>一、软件架构的定义</h1><p>软件架构仍在不断发展中，还没有形成一个统一的、公认的定义，这里仅举出几个较权威的定义。</p><p>定义 1:软件或计算机系统的软件架构是该系统的一个(或多个)结构，而结构由软件元素、元素的外部可见属性及它们之间的关系组成。</p><p>定义 2:软件架构为软件系统提供了一个结构、行为和属性的高级抽象，由构成系统的元素的描述、这些元素的相互作用、指导元素集成的模式及这些模式的约束组成。</p><p>定义 3:软件架构是指一个系统的基础组织，它具体体现在:系统的构件，构件之间、构件与环境之间的关系，以及指导其设计和演化的原则上。(IEEE1471- 2000)</p><p>(1)架构是对系统的抽象，它通过描述元素、元素的外部可见属性及元素之间的关系来反映这种抽象。因此，仅与内部具体实现有关的细节是不属于架构的，即定义强调元素的 “外部可见”属性。</p><p>(2)架构由多个结构组成，结构是从功能角度来描述元素之间的关系的，具体的结构传达了架构某方面的信息，但是个别结构一般不能代表大型软件架构。</p><p>(3)任何软件都存在架构，但不一定有对该架构的具体表述文档。即架构可以独立于架构的描述而存在。如文档已过时，则该文档不能反映架构。</p><p>(4)元素及其行为的集合构成架构的内容。体现系统由哪些元素组成，这些元素各有哪些功能(外部可见)，以及这些元素间如何连接与互动。即在两个方面进行抽象:在静态方面，关注系统的大粒度(宏观)总体结构(如分层);在动态方面，关注系统内关键行为的共同特征。</p><p>(5)架构具有“基础”性:它通常涉及解决各类关键的重复问题的通用方案(复用性)，以及系统设计中影响深远(架构敏感)的各项重要决策(一旦贯彻，更改的代价昂贵)。</p><p>(6)架构隐含有“决策”，即架构是由架构设计师根据关键的功能和非功能性需求(质量属性及项目相关的约束)进行设计与决策的结果。不同的架构设计师设计出来的架构是不一样的，为避免架构设计师考虑不周，重大决策应经过评审。特别是架构设计师自身的水平是一种约束，不断学习和积累经验才是摆脱这种约束走向自由王国的必经之路。</p><p>在设计软件架构时也必须考虑硬件特性和网络特性，因此，软件架构与系统架构二者间的区别其实不大。但是，在大多情况下，架构设计师在软件方面的选择性较之硬件方面，其自由度大得多。因此，使用“软件架构”这一术语，也表明了一个观点:架构设计师通常将架构的重点放在软件部分。</p><p>(1)影响架构的因素。软件系统的项目干系人(客户、用户、项目经理、程序员、测试人员、市场人员等)对软件系统有不同的要求、开发组织(项目组)有不同的人员知识结构、架构设计师的素质与经验、当前的技术环境等方面都是影响架构的因素。这些因素通过功能性需求、非功能性需求、约束条件及相互冲突的要求，影响架构设计师的决策，从而影响架构。</p><p>(2)架构对上述诸因素具有反作用，例如，影响开发组织的结构。架构描述了系统的大粒度(宏观)总体结构，因此可以按架构进行分工，将项目组为几个工作组，从而使开发有序;影响开发组织的目标，即成功的架构为开发组织提供了新的商机，这归功于:系统的示范性、架构的可复用性及团队开发经验的提升，同时，成功的系统将影响客户对下一个系统的要求等。这种反馈机制构成了架构的商业周期。</p><h1 id="二、软件架构的重要性"><a href="#二、软件架构的重要性" class="headerlink" title="二、软件架构的重要性"></a>二、软件架构的重要性</h1><h2 id="1-项目关系人之间交流的平台。"><a href="#1-项目关系人之间交流的平台。" class="headerlink" title="(1)项目关系人之间交流的平台。"></a>(1)项目关系人之间交流的平台。</h2><p>软件系统的项目关系人分别关注系统的不同特性， 而这些特性都由架构所决定，因此，架构提供了一个共同语言(公共的参考点)，项目关系 人以此作为彼此理解、协商、达成共识或相互沟通的基础。架构分析既依赖于又促进了这个 层次上的交流。</p><h2 id="2-早期设计决策。"><a href="#2-早期设计决策。" class="headerlink" title="(2)早期设计决策。"></a>(2)早期设计决策。</h2><p>从软件生命周期来看，软件架构是所开发系统的最早设计决策的体现。</p><p>架构明确了对系统实现的约束条件:架构是架构设计师对系统实现的各方面进行权衡的结果， 是总体设计的体现，因此，在具体实现时必须按架构的设计进行。</p><p>架构影响着系统的质量属性:要保证系统的高质量，具有完美的架构是必要的(虽然不充分)。 架构可以用来预测系统的质量，例如，可以根据经验对该架构的质量(如性能)作定性的判 断。</p><p>架构为维护的决策提供根据。在架构层次上能为日后的更改决策提供推理、判断的依据。一个富有生命力的架构，应该是在最有可能更改的地方有所考虑(架构的柔性)，使其在此点 最容易进行更改。</p><p>架构有助于原型开发。可以按架构构造一个骨架系统(原型)，例如，在早期实现一个可执 行的特例，确定潜在的性能问题。</p><p>借助于架构进行成本与进度的估计。</p><h2 id="3-在较高层面上实现软件复用。"><a href="#3-在较高层面上实现软件复用。" class="headerlink" title="(3)在较高层面上实现软件复用。"></a>(3)在较高层面上实现软件复用。</h2><p>软件架构作为系统的抽象模型，可以在多个系统间传递(复用)，特别是比较容易地应用到具有相似质量属性和功能需求的系统中。产品线通 常共享一个架构。产品线的架构是开发组织的核心资产之一，利用架构及其范例进行多系统 的开发，在开发时间、成本、生产率和产品质量方面具有极大的回报。基于架构的开发强调 对各元素的组合或装配。系统开发还可以使用其他组织开发的元素，例如购买商业构件。</p><h2 id="4-架构对开发的指导与规范意义不容忽略。"><a href="#4-架构对开发的指导与规范意义不容忽略。" class="headerlink" title="(4)架构对开发的指导与规范意义不容忽略。"></a>(4)架构对开发的指导与规范意义不容忽略。</h2><p>架构作为系统的总体设计，它指导后续 的详细设计和编码。架构使基于模板的开发成为可能，有利于开发的规范化和一致性，减少 开发与维护成本。架构可以作为培训的基础，有利于培养开发团队和培训相关人员。</p><p><img src="/images/ruankao/6-20.png"></p><h1 id="三、架构的模型"><a href="#三、架构的模型" class="headerlink" title="三、架构的模型"></a>三、架构的模型</h1><p>软件架构作为一个有机的整体，可以分解成多个侧面来认识，每个侧面强调它的不同方 面的特征，从而使架构设计师能整体地把握它的重点。我们可以将软件架构归纳成 5 种模 型:结构模型、框架模型、动态模型、过程模型和功能模型。最常用的是结构模型和动态模 型。</p><h2 id="1-结构模型。"><a href="#1-结构模型。" class="headerlink" title="(1)结构模型。"></a>(1)结构模型。</h2><p>这是一个最直观、最普遍的建模方法。这种方法以架构的构件、连接 件和其他概念来刻画结构，并力图通过结构来反映系统的重要语义内容，包括系统的配置、 约束、隐含的假设条件、风格、性质。研究结构模型的核心是架构描述语言。</p><h2 id="2-框架模型。"><a href="#2-框架模型。" class="headerlink" title="(2)框架模型。"></a>(2)框架模型。</h2><p>框架模型与结构模型类似，但它不太侧重描述结构的细节而更侧重于 整体的结构。框架模型主要以一些特殊的问题为目标建立只针对和适应该问题的结构。</p><h2 id="3-动态模型。"><a href="#3-动态模型。" class="headerlink" title="(3)动态模型。"></a>(3)动态模型。</h2><p>动态模型是对结构或框架模型的补充，研究系统“大颗粒”的行为性质。例如，描述系统的重新配置或演化。动态可能指系统总体结构的配置、建立或拆除通信 通道或计算的过程。</p><h2 id="4-过程模型。"><a href="#4-过程模型。" class="headerlink" title="(4)过程模型。"></a>(4)过程模型。</h2><p>过程模型研究构造系统的步骤和过程。因而结构是遵循某些过程脚本的结果。</p><h2 id="5-功能模型。"><a href="#5-功能模型。" class="headerlink" title="(5)功能模型。"></a>(5)功能模型。</h2><p>该模型认为架构由一组功能构件按层次组成，且下层向上层提供服务。 它可以看作是一种特殊的框架模型。</p><h2 id="“4-1”的视图模型"><a href="#“4-1”的视图模型" class="headerlink" title="“4+1”的视图模型"></a>“4+1”的视图模型</h2><p>4+1” 视 图模型从 5 个不同的视角包括逻辑视图、进程视图、物理视图、开发视图和场景视图来描 述软件架构。每一个视图只关心系统的一个侧面，5 个视图结合在一起才能反映系统的软件 架构的全部内容。</p><p><img src="/images/ruankao/6-21.png"></p><h3 id="1-逻辑视图"><a href="#1-逻辑视图" class="headerlink" title="(1)逻辑视图"></a>(1)逻辑视图</h3><p>主要支持系统的功能需求，即系统提供给最终用户的服务。</p><p>在面向对象技术中，通过抽象、封装和继承，可以用对象模型来代表逻辑视图，用类图来描述逻辑视图。逻辑视图中使用的风格为面向对象的风格。</p><h3 id="2-开发视图"><a href="#2-开发视图" class="headerlink" title="(2)开发视图"></a>(2)开发视图</h3><p>也称为模块视图，主要侧重于软件模块的组织和管理。</p><p>开发视图要考虑软件内部的需求，如软件开发的容易性、软件的重用和软件的通用性，要充分考虑由于具体开发工具的不同而带来的局限性。开发视图通过系统输入输出关系的模型图和子系统图来描述。</p><h3 id="3-进程视图"><a href="#3-进程视图" class="headerlink" title="(3)进程视图"></a>(3)进程视图</h3><p>侧重于系统的运行特性，主要关注一些非功能性的需求，例如系统的性能和可用性。</p><p>进程视图强调并发性、分布性、系统集成性和容错能力，以及逻辑视图中的 主要抽象的进程结构。它也定义逻辑视图中的各个类的操作具体是在哪一个线程中被执行的。 进程视图可以描述成多层抽象，每个级别分别关注不同的方面。</p><h3 id="4-物理视图"><a href="#4-物理视图" class="headerlink" title="(4)物理视图"></a>(4)物理视图</h3><p>主要考虑如何把软件映射到硬件上，它通常要考虑到解决系统拓扑结 构、系统安装、通信等问题。</p><p>当软件运行于不同的节点上时，各视图中的构件都直接或间接 地对应于系统的不同节点上。因此，从软件到节点的映射要有较高的灵活性，当环境改变时， 对系统其他视图的影响最小。</p><h3 id="5-场景"><a href="#5-场景" class="headerlink" title="(5)场景"></a>(5)场景</h3><p>可以看作是那些重要系统活动的抽象，它使四个视图有机地联系起来，从某种意义上说，场景是最重要的需求抽象。</p><p>在开发架构时，它可以帮助设计者找到架构的构件和它们之间的作用关系。同时，也可以用场景来分析一个特定的视图，或描述不同视图构件间是如何相互作用的。场景可以用文本表示，也可以用图形表示。</p><p><img src="/images/ruankao/6-22.png"></p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-软件架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件架构设计（二）架构需求与软件质量属性</title>
      <link href="/2021/09/25/%E8%BD%AF%E8%80%83/9%E3%80%81%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89%E6%9E%B6%E6%9E%84%E9%9C%80%E6%B1%82%E4%B8%8E%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7/"/>
      <url>/2021/09/25/%E8%BD%AF%E8%80%83/9%E3%80%81%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89%E6%9E%B6%E6%9E%84%E9%9C%80%E6%B1%82%E4%B8%8E%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>架构的基本需求主要是在满足功能属性的前提下，关注软件质量属性，架构设计则是为满足架构需求(质量属性)寻找适当的“战术”。</p><p>软件属性包括功能属性和质量属性，但是，软件架构(及软件架构设计师)重点关注的是质量属性。</p><p>在大量的可能结构中，可以使用不同的结构来实现同样的功能性，即功 能性在很大程度上是独立于结构的，架构设计师面临着决策(对结构的选择)，而功能性所 关心的是它如何与其他质量属性进行交互，以及它如何限制其他质量属性。</p><h1 id="一、软件质量属性"><a href="#一、软件质量属性" class="headerlink" title="一、软件质量属性"></a>一、软件质量属性</h1><p>《GB/T16260-1996(idt ISO/IEC9126:1991)信息技术软件产品评价质量特性及其使用指南》中描述的软件质量特性包括功能性、可靠性、易用性、效率、可维护性、可移植性等 6 个方面，每个方面都包含若干个子特性。 </p><table><thead><tr><th>软件质量特性</th><th>子特性</th></tr></thead><tbody><tr><td>功能性</td><td>适合性、准确性、互操作性、依从性、安全性</td></tr><tr><td>可靠性</td><td>成熟性、容错性、易恢复性</td></tr><tr><td>易用性</td><td>易理解性、易学性、易操作性</td></tr><tr><td>效率</td><td>时间特性、资源特性</td></tr><tr><td>可维护性</td><td>易分析性、易改变性、稳定性、易测试性</td></tr><tr><td>可移植性</td><td>适应性、易安装性、遵循性、易替换性</td></tr></tbody></table><h2 id="1-运行期质量属性"><a href="#1-运行期质量属性" class="headerlink" title="1.运行期质量属性"></a>1.运行期质量属性</h2><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>性能是指软件系统及时提供相应服务的能力。包括速度、吞吐量和持续高速性三方面的要求。</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>指软件系统同时兼顾向合法用户提供服务，以及阻止非授权使用的能力。</p><h3 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h3><p>指软件系统易于被使用的程度。</p><h3 id="可伸缩性"><a href="#可伸缩性" class="headerlink" title="可伸缩性"></a>可伸缩性</h3><p>指当用户数和数据量增加时，软件系统维持高服务质量的能力。例如，通过增加服务器来提高能力。</p><h3 id="互操作性"><a href="#互操作性" class="headerlink" title="互操作性"></a>互操作性</h3><p>指本软件系统与其他系统交换数据和相互调用服务的难易程度。</p><h3 id="持续可用性"><a href="#持续可用性" class="headerlink" title="持续可用性"></a>持续可用性</h3><p>指系统长时间无故障运行的能力。与可靠性相关联，常将其纳入可靠性中。</p><h3 id="鲁棒性"><a href="#鲁棒性" class="headerlink" title="鲁棒性"></a>鲁棒性</h3><p>是指软件系统在一些非正常情况(如用户进行了非法操作、相关的软硬件系统发生了故障等)下仍能够正常运行的能力。也称健壮性或容错性。</p><h2 id="2-开发期质量属性"><a href="#2-开发期质量属性" class="headerlink" title="2.开发期质量属性"></a>2.开发期质量属性</h2><h3 id="易理解性"><a href="#易理解性" class="headerlink" title="易理解性"></a>易理解性</h3><p>指设计被开发人员理解的难易程度。</p><h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>软件因适应新需求或需求变化而增加新功能的能力。也称为灵活性。</p><h3 id="可重用性"><a href="#可重用性" class="headerlink" title="可重用性"></a>可重用性</h3><p>指重用软件系统或某一部分的难易程度。</p><h3 id="可测试性"><a href="#可测试性" class="headerlink" title="可测试性"></a>可测试性</h3><p>对软件测试以证明其满足需求规范的难易程度。</p><h3 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h3><p>当需要修改缺陷、增加功能、提高质量属性时，定位修改点并实施修改的难易程度;</p><h3 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h3><p>将软件系统从一个运行环境转移到另一个不同的运行环境的难易程度。</p><p><img src="/images/ruankao/6-23.png"></p><h1 id="二、6-个质量属性及实现"><a href="#二、6-个质量属性及实现" class="headerlink" title="二、6 个质量属性及实现"></a>二、6 个质量属性及实现</h1><p>如何描述质量属性需求呢?<br><img src="/images/ruankao/6-24.png"></p><h2 id="1-可用性及其实现战术"><a href="#1-可用性及其实现战术" class="headerlink" title="1.可用性及其实现战术"></a>1.可用性及其实现战术</h2><h3 id="1-可用性的描述。"><a href="#1-可用性的描述。" class="headerlink" title="(1)可用性的描述。"></a>(1)可用性的描述。</h3><p><img src="/images/ruankao/6-25.png"></p><h3 id="2-可用性战术。"><a href="#2-可用性战术。" class="headerlink" title="(2)可用性战术。"></a>(2)可用性战术。</h3><p>可用性战术的目标是阻止错误发展成故障，至少能够把错误的影响 限制在一定范围内，从而使修复成为可能。战术分为:错误检测、错误恢复、错误预防。</p><h4 id="①错误检测"><a href="#①错误检测" class="headerlink" title="①错误检测"></a>①错误检测</h4><p>命令/响应:一个构件发出一个命令，并希望在预定义的时间内收到一个来自审查构件的响 应，例如远程错误的检测。<br>心跳(计时器):一个构件定期发出一个心跳消息，另一个构件收听到消息，如果未收到心 跳消息，则假定构件失败，并通知错误纠正构件。<br>异常:当出现异常时，异常处理程序开发执行。</p><h4 id="②错误恢复"><a href="#②错误恢复" class="headerlink" title="②错误恢复"></a>②错误恢复</h4><p>表决:通过冗余构件(或处理器)与表决器连接，构件按相同的输入及算法计算输出值交给 表决器，由表决器按表决算法(如多数规则)确定是否有构件出错，表决通常用在控制系统中。</p><p>主动冗余(热重启、热备份):所有的冗余构件都以并行的方式对事件做出响应。它们都处 在相同的状态，但仅使用一个构件的响应，丢弃其余构件的响应。错误发生时通过切换的方 式使用另一个构件的响应。</p><p>被动冗余(暧重启/双冗余/三冗余):一个构件(主构件)对事件做出响应，并通知其他构 件(备用的)必须进行的状态更新(同步)。当错误发生时，备用构件从最新同步点接替主 构件的工作。</p><p>备件:备件是计算平台配置用于更换各种不同的故障构件。</p><p>状态再同步:主动和被动冗余战术要求所恢复的构件在重新提供服务前更新其状态。更新方 法取决于可以承受的停机时间、更新的规模及更新的内容多少。</p><p>检查点/回滚:检查点就是使状态一致的同步点，它或者是定期进行，或者是对具体事件做 出响应。当在两检查点之间发生故障时，则以这个一致状态的检查点(有快照)和之后发生 的事务日志来恢复系统(数据库中常使用)。</p><h4 id="③错误预防"><a href="#③错误预防" class="headerlink" title="③错误预防"></a>③错误预防</h4><p>从服务中删除:如删除进程再重新启动，以防止内存泄露导致故障的发生。</p><p>事务:使用事务来保证数据的一致性，即几个相关密切的步骤，要么全成功，要么都不成功。</p><p>进程监视器:通过监视进程来处理进程的错误。</p><p><img src="/images/ruankao/6-26.png"></p><h2 id="2-可修改性及其实现战术"><a href="#2-可修改性及其实现战术" class="headerlink" title="2.可修改性及其实现战术"></a>2.可修改性及其实现战术</h2><h3 id="1-可修改性的描述"><a href="#1-可修改性的描述" class="headerlink" title="(1)可修改性的描述"></a>(1)可修改性的描述</h3><p><img src="/images/ruankao/6-27.png"></p><h3 id="2-可修改性战术。"><a href="#2-可修改性战术。" class="headerlink" title="(2)可修改性战术。"></a>(2)可修改性战术。</h3><p>包括局部化修改、防止连锁反应、推迟绑定时间。</p><h4 id="①局部化修改"><a href="#①局部化修改" class="headerlink" title="①局部化修改"></a>①局部化修改</h4><p>在设计期间为模块分配责任，以便把预期的变更限制在一定的范围内，从而降低修改的成本。</p><p>维持语义的一致性:语义的一致性指的是模块中责任之间的关系，使这些责任能够协同工作， 不需要过多地依赖其他模块。耦合和内聚指标反映一致性，应该根据一组预期的变更来度量 语义一致性。使用“抽象通用服务”(如应用框架的使用和其他中间软件的使用)来支持可 修改性是其子战术。</p><p>预期期望的变更:通过对变更的预估，进行预设、准备，从而使变更的影响最小。</p><p>泛化该模块:使一个模块更通用、更广泛的功能。</p><p>限制可能的选择:如在更换某一模块(如处理器)时，限制为相同家族的成员。</p><h4 id="②防止连锁反应。"><a href="#②防止连锁反应。" class="headerlink" title="②防止连锁反应。"></a>②防止连锁反应。</h4><p>由于模块之间有各种依赖性，因此，修改会产生连锁反应。防止连锁反应的战术如下。</p><p>信息隐藏:就是把某个实体的责任分解为更小的部分，并选择哪些信息成为公有的，哪些成 为私有的，通过接口获得公有责任。</p><p>维持现有的接口:尽可能维持现有接口的稳定性。例如通过添加接口(通过新的接口提供新 的服务)可以达到这一目的。</p><p>限制通信路径:限制与一个给定的模块共享数据的模块。这样可以减少由于数据产生/使用引入的连锁反应。</p><p>仲裁者的使用:在具有依赖关系的两个模块之间插入一个仲裁者，以管理与该依赖相关的活 动。仲裁者有很多种类型，例如:桥、调停者、代理等就是可以提供把服务的语法从一种形 式转换为另一种形式的仲裁者。</p><h4 id="③推迟绑定时间。"><a href="#③推迟绑定时间。" class="headerlink" title="③推迟绑定时间。"></a>③推迟绑定时间。</h4><p>系统具备在运行时进行绑定并允许非开发人员进行修改(配置)。</p><p>运行时注册:支持即插即用。</p><p>配置文件:在启动时设置参数。</p><p>多态:在方法调用的后期绑定。</p><p>构件更换:允许载入时绑定。<br><img src="/images/ruankao/6-29.png"></p><h2 id="3-性能及其实现战术"><a href="#3-性能及其实现战术" class="headerlink" title="3.性能及其实现战术"></a>3.性能及其实现战术</h2><h3 id="1-性能的描述。"><a href="#1-性能的描述。" class="headerlink" title="(1)性能的描述。"></a>(1)性能的描述。</h3><p><img src="/images/ruankao/6-28.png"></p><h3 id="2-性能战术。"><a href="#2-性能战术。" class="headerlink" title="(2)性能战术。"></a>(2)性能战术。</h3><p>性能与时间相关，影响事件的响应时间有两个基本因素。</p><p>资源消耗:事件到达后进入一系列的处理程序，每一步处理都要占用资源，而且在处理过程 中消息在各构件之间转换，这些转换也需要占用资源。</p><p>闭锁时间:指对事件处理时碰到了资源争用、资源不可用或对其他计算的依赖等情况，就产 生了等待时间。</p><h4 id="①资源需求"><a href="#①资源需求" class="headerlink" title="①资源需求"></a>①资源需求</h4><p>减少处理事件流所需的资源:提高计算效率(如改进算法)、减少计算开销(如在可修改性与性能之间权衡，减少不必要的代理构件)。</p><p>减少所处理事件的数量:管理事件率、控制采样频率。</p><p>控制资源的使用:限制执行时间(如减少迭代次数)、限制队列大小。</p><h4 id="②资源管理"><a href="#②资源管理" class="headerlink" title="②资源管理"></a>②资源管理</h4><p>引入并发:引入并发对负载平衡很重要。</p><p>维持数据或计算的多个副本:C/S 结构中客户机 C 就是计算的副本，它能减少服务器计算的压力;高速缓存可以存放数据副本(在不同速度的存储库之间的缓冲)。</p><p>增加可用资源:在成本允许时，尽量使用速度更快的处理器、内存和网络。</p><h4 id="③资源仲裁"><a href="#③资源仲裁" class="headerlink" title="③资源仲裁"></a>③资源仲裁</h4><p>通过如下调度策略来实现：</p><p>先进/先出(FIFO);</p><p>固定优先级调度:先给事件分配特定的优先级，再按优先级高低顺序分配资源;</p><p>动态优先级调度:轮转调度、时限时间最早优先;</p><p>静态调度:可以离线确定调度。</p><p><img src="/images/ruankao/6-30.png"></p><h2 id="4-安全性及其实现战术"><a href="#4-安全性及其实现战术" class="headerlink" title="4.安全性及其实现战术"></a>4.安全性及其实现战术</h2><h3 id="1-安全性的描述。"><a href="#1-安全性的描述。" class="headerlink" title="(1)安全性的描述。"></a>(1)安全性的描述。</h3><p><img src="/images/ruankao/6-31.png"></p><h3 id="2-安全性战术"><a href="#2-安全性战术" class="headerlink" title="(2)安全性战术"></a>(2)安全性战术</h3><p>包括抵抗攻击、检测攻击和从攻击中恢复。</p><h4 id="①抵抗攻击"><a href="#①抵抗攻击" class="headerlink" title="①抵抗攻击"></a>①抵抗攻击</h4><p>对用户进行身份验证:包括动态密码、一次性密码、数字证书及生物识别等;</p><p>对用户进行授权:即对用户的访问进行控制管理;</p><p>维护数据的机密性:一般通过对数据和通信链路进行加密来实现;</p><p>维护完整性:对数据添加校验或哈希值;</p><p>限制暴露的信息;</p><p>限制访问:如用防火墙、DMZ 策略。</p><h4 id="②检测攻击"><a href="#②检测攻击" class="headerlink" title="②检测攻击"></a>②检测攻击</h4><p>一般通过“入侵检测”系统进行过滤、比较通信模式与历史基线等方法。</p><h4 id="③从攻击中恢复"><a href="#③从攻击中恢复" class="headerlink" title="③从攻击中恢复"></a>③从攻击中恢复</h4><p>恢复:与可用性中的战术相同;</p><p>识别攻击者:作为审计追踪，用于预防性或惩罚性目的。</p><p><img src="/images/ruankao/6-32.png"></p><h2 id="5-可测试性及其实现战术"><a href="#5-可测试性及其实现战术" class="headerlink" title="5.可测试性及其实现战术"></a>5.可测试性及其实现战术</h2><h3 id="1-可测试性的描述"><a href="#1-可测试性的描述" class="headerlink" title="(1)可测试性的描述"></a>(1)可测试性的描述</h3><p><img src="/images/ruankao/6-33.png"></p><h3 id="2-可测试性战术"><a href="#2-可测试性战术" class="headerlink" title="(2)可测试性战术"></a>(2)可测试性战术</h3><p>包括输入/输出和内部监控。</p><h4 id="①输入-输出"><a href="#①输入-输出" class="headerlink" title="①输入/输出"></a>①输入/输出</h4><p>记录/回放:指捕获跨接口的信息，并将其作为测试专用软件的输入;</p><p>将接口与实现分离:允许使用实现的替代(模拟器)来支持各种测试目的;</p><p>优化访问线路/接口:用测试工具来捕获或赋予构件的变量值。</p><h4 id="②内部监控"><a href="#②内部监控" class="headerlink" title="②内部监控"></a>②内部监控</h4><p>当监视器处于激活状态时，记录事件(如通过接口的信息)。<br><img src="/images/ruankao/6-34.png"></p><h2 id="6-易用性及其实现战术"><a href="#6-易用性及其实现战术" class="headerlink" title="6.易用性及其实现战术"></a>6.易用性及其实现战术</h2><h3 id="1-易用性的描述"><a href="#1-易用性的描述" class="headerlink" title="(1)易用性的描述"></a>(1)易用性的描述</h3><p><img src="/images/ruankao/6-35.png"></p><h3 id="2-易用性战术"><a href="#2-易用性战术" class="headerlink" title="(2)易用性战术"></a>(2)易用性战术</h3><p>包括运行时战术、设计时战术和支持用户主动操作。</p><h4 id="①运行时战术"><a href="#①运行时战术" class="headerlink" title="①运行时战术"></a>①运行时战术</h4><p>任务的模型:维护任务的信息，使系统了解用户试图做什么，并提供各种协助;</p><p>用户的模型:维护用户的信息，例如使系统以用户可以阅读页面的速度滚动页面;</p><p>系统的模型:维护系统的信息，它确定了期望的系统行为，并向用户提供反馈。</p><h4 id="②设计时战术"><a href="#②设计时战术" class="headerlink" title="②设计时战术"></a>②设计时战术</h4><p>将用户接口与应用的其余部分分离开来，预计用户接口会频繁发生变化，因此，单独维护用户接口代码将实现变更局部化。这与可修改性相关。</p><h4 id="③支持用户主动操作"><a href="#③支持用户主动操作" class="headerlink" title="③支持用户主动操作"></a>③支持用户主动操作</h4><p>支持用户的主动操作，如支持“取消”、“撤销”、“聚合”和 “显<br>示多个视图”。</p><p><img src="/images/ruankao/6-36.png"></p><hr><p><img src="/images/ruankao/6-37.png"></p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-软件架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统分析与设计方法（七）简单分布式计算机应用系统的设计</title>
      <link href="/2021/09/24/%E8%BD%AF%E8%80%83/8%E3%80%81%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E7%AE%80%E5%8D%95%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2021/09/24/%E8%BD%AF%E8%80%83/8%E3%80%81%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E7%AE%80%E5%8D%95%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>分布式计算背景：<br>单台计算机的功能仍然十分有限。<br>升级到更强的服务器的费用常常远远高于购买多台档次稍低的机器。</p><p>解决方案：<br>利用联网的计算机协同工作，共同完成复杂的工作成为相对成本较低的选择，而且可以完成单台计算机所无法完成的任务。</p><p>存在问题：<br>网络本质上并不可靠，特别是远程通信。<br>分布式系统还带来了并发和同步的问题。</p><h1 id="基于实例的协作"><a href="#基于实例的协作" class="headerlink" title="基于实例的协作"></a>基于实例的协作</h1><p>所有的实例都处理自己范围内的数据，这些对象实例的地位是相同的，当一个对象实例必须要处理不属于它自己范围的数据时，它必须和数据归宿的对象实例通信，请求另外一个对象实例进行处理。<br>请求对象实例可以启动对象、调用远程对象的方法，以及停止运行远程实例。</p><p>基于实例的协作适用于比较小范围内网络情况良好的环境中，这种环境常常被称为近连接。这种情况下对对象的生存周期管理所带来不寻常的网络流量是可以容忍的。</p><p>基于实例的协作常常使用被称为“代理”的方法。</p><h1 id="基于服务的协作"><a href="#基于服务的协作" class="headerlink" title="基于服务的协作"></a>基于服务的协作</h1><p>只提供远程对象的接口，用户可以调用这些方法，却无法远程创建和销毁远程对象实例。</p><p>基于服务的协作适用于跨平台的网络，网络响应较慢的情况，这种环境常称为远连接。这时，简化交互性更为重要，而频繁的网络交换数据会带来难以容忍的延时。</p><p>基于服务的协作往往采用分层次的结构，高层次的应用依赖于低层次的对象，而低层次对象实例的实现细节则没有必要暴露给高层次对象。</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-系统分析与设计方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统分析与设计方法（三）结构化分析与设计</title>
      <link href="/2021/09/24/%E8%BD%AF%E8%80%83/8%E3%80%81%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%8C%96%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
      <url>/2021/09/24/%E8%BD%AF%E8%80%83/8%E3%80%81%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%8C%96%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>结构化分析与设计方法是一种面向数据流的需求分析和设计方法。</p><p>它适用于分析和设计大型数据处理系统，是一种简单、实用的方法。</p><h1 id="一、结构化分析"><a href="#一、结构化分析" class="headerlink" title="一、结构化分析"></a>一、结构化分析</h1><p>结构化分析方法的基本思想史自顶向下逐层分解。<br>分解和抽象是控制问题复杂性的两种基本手段。<br>把一个大问题分解成若干个小问题，每个小问题在分解成更小的问题，让每个最底层的问题都足够简单、容易解决，这个过程就是分解过程。</p><p>结构化分析与面向对象分析方法之间最大的差别是：<br>面向对象方法把系统看成一个相互影响的对象集。<br>结构化分析方法把系统看作一个过程的集合体，包括人完成的和电脑完成的。特点是利用数据流图帮助人们理解问题，对问题进行分析。<br>结构化分析一般包括以下工具：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数据流图（Data Flow Diagram，DFD）</span><br><span class="line">数据字段（Data Dictionary，DD）</span><br><span class="line">结构化语言</span><br><span class="line">判定表</span><br><span class="line">判定树</span><br></pre></td></tr></table></figure><h2 id="1、结构化分析的工作步骤"><a href="#1、结构化分析的工作步骤" class="headerlink" title="1、结构化分析的工作步骤"></a>1、结构化分析的工作步骤</h2><h3 id="（1）研究“物质环境”"><a href="#（1）研究“物质环境”" class="headerlink" title="（1）研究“物质环境”"></a>（1）研究“物质环境”</h3><p>首先应该画出当前系统的数据流图，说明系统的输入、输出数据流，说明系统的数据流情况，经历了那些处理过程。</p><h3 id="（2）简历系统逻辑模型"><a href="#（2）简历系统逻辑模型" class="headerlink" title="（2）简历系统逻辑模型"></a>（2）简历系统逻辑模型</h3><p>在物理模型建立完成之后，接下来就是画出相对于真实系统的等价逻辑数据流图。<br>在前一步简历的数据流图的基础上，将所有自然数据流都转成等价的逻辑流。<br>比如将现实世界中的“送往总经理办公室”改成“报送表格”。</p><h3 id="（3）划清人机界限"><a href="#（3）划清人机界限" class="headerlink" title="（3）划清人机界限"></a>（3）划清人机界限</h3><p>确定在系统逻辑模型中，哪些通过系统自动化完成，哪些手工操作。</p><h2 id="2、数据流图DFD"><a href="#2、数据流图DFD" class="headerlink" title="2、数据流图DFD"></a>2、数据流图DFD</h2><p>DFD是一种图形化的系统模型，主要在图中展示主要需求，包括输入、输出、处理、数据存储等过程。<br>DFD包括以下几个基础元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">过程：也称为加工，一步步地执行指令，完成输入到输出的转换。</span><br><span class="line">外部实体：也称为源/宿，系统之外的数据源或目的。</span><br><span class="line">数据存储：也称为文件，存放数据的地方，一般是文件、数据库。</span><br><span class="line">数据流：从一处到另一处的数据流向。</span><br><span class="line">实时链接：当过程执行时，外部实体与过程之间的来回通信。</span><br></pre></td></tr></table></figure><p><img src="/images/ruankao/6-1.png"></p><h3 id="1-数据流图的层次"><a href="#1-数据流图的层次" class="headerlink" title="(1)数据流图的层次"></a>(1)数据流图的层次</h3><p>结构化的思路是依赖于数据流图自顶向下分析。<br>因为系统通常比较复杂，很难在一张图上将所有的数据流和加工描述清楚。<br>因此数据流图分为高层次和低层次的图，由高层次逐步分解。<br><img src="/images/ruankao/6-2.png"></p><h3 id="（2）Context图"><a href="#（2）Context图" class="headerlink" title="（2）Context图"></a>（2）Context图</h3><p>系统上下文范围关系图。是系统最高层结构的DFD图。<br>特点是将待开发的系统表示成一个过程，将所有外部实体和进出系统的数据流都花在一张图中。<br><img src="/images/ruankao/6-3.png"></p><h3 id="（3）逐级分解"><a href="#（3）逐级分解" class="headerlink" title="（3）逐级分解"></a>（3）逐级分解</h3><p><img src="/images/ruankao/6-4.png"><br>保持输入、输出不变，由于是对过程0分解进行分解，所以叫DFD0层图。<br>对DFD1层图进行分解，其编号就是1.1，1.2……</p><h3 id="（4）如何画DFD。"><a href="#（4）如何画DFD。" class="headerlink" title="（4）如何画DFD。"></a>（4）如何画DFD。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">画系统的输入和输出</span><br><span class="line">画数据流图的内部</span><br><span class="line">为每个数据流命名</span><br><span class="line">为加工命名</span><br></pre></td></tr></table></figure><h2 id="3、细化记录DFD部件"><a href="#3、细化记录DFD部件" class="headerlink" title="3、细化记录DFD部件"></a>3、细化记录DFD部件</h2><p>数据字典是很适用和有效的细化手段。他对所有和系统相关的数据元素进行明确的定义。<br>数据字典的每一个条目中包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">名称</span><br><span class="line">何处使用/如何使用</span><br><span class="line">内容描述</span><br><span class="line">补充信息</span><br></pre></td></tr></table></figure><p>内容描述的符号包括</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">= 由xxx组成</span><br><span class="line">+ 和，表示顺序链接</span><br><span class="line">[|] 或</span><br><span class="line">&#123;&#125;* n次重复</span><br><span class="line">() 可选的数据项</span><br><span class="line">*...* 特定限制</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">客户信息=客户编号+客户名称+身份证号+手机</span><br><span class="line">客户编号=&#123;0...9&#125;8</span><br><span class="line">客户名称=&#123;字&#125;4</span><br><span class="line">身份证号=[&#123;0...9&#125;15|&#123;0...9&#125;18]</span><br></pre></td></tr></table></figure><h1 id="二、结构化设计"><a href="#二、结构化设计" class="headerlink" title="二、结构化设计"></a>二、结构化设计</h1><p>结构化设计包括架构设计、接口设计、数据设计、过程设计等。<br>是面向数据流的设计，自顶向下、逐步求精、模块化的过程。</p><h2 id="1、概要设计与详细设计的主要任务"><a href="#1、概要设计与详细设计的主要任务" class="headerlink" title="1、概要设计与详细设计的主要任务"></a>1、概要设计与详细设计的主要任务</h2><h3 id="概要设计"><a href="#概要设计" class="headerlink" title="概要设计"></a>概要设计</h3><p>概要设计阶段的主要任务是设计软件的结构、确定系统由哪些模块组成，每个模块之间的关系。<br>整个过程包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">复查基本系统模型</span><br><span class="line">复查并精化数据流图</span><br><span class="line">确定数据流图的信息流类型</span><br><span class="line">根据刘类型分别实施变换分析或事务分析</span><br><span class="line">根据软件设计原则对得到的软件结构图进一步细化</span><br></pre></td></tr></table></figure><h3 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h3><p>详细设计阶段的主要任务是确定应该如何具体地实现所要求的的系统，得出对目标系统的精确描述。<br>采用自顶向下、逐步求精的设计方式，单入口单出口的控制结构。<br>常用工具包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">流程图</span><br><span class="line">盒图</span><br><span class="line">问题分析图PAD</span><br><span class="line">程序设计语言PDL</span><br></pre></td></tr></table></figure><h2 id="2、结构图"><a href="#2、结构图" class="headerlink" title="2、结构图"></a>2、结构图</h2><p>结构图包括模块、调用、和数据<br><img src="/images/ruankao/6-5.png"><br>结构图是在数据流图的基础上进一步设计，将DFD中的信息流分成交换流和事务流。</p><h3 id="交换流"><a href="#交换流" class="headerlink" title="交换流"></a>交换流</h3><p>信息沿着输入通路进入系统，将其转换为内部表示，然后通过交换中心（加工）的处理，再验证输出转换为外部形式离开系统。</p><h3 id="事务流"><a href="#事务流" class="headerlink" title="事务流"></a>事务流</h3><p>信息沿着输入通道进入系统，事务中心根据输入信息的类型在若干活动流选择一个执行。</p><h2 id="3、流程图和盒图"><a href="#3、流程图和盒图" class="headerlink" title="3、流程图和盒图"></a>3、流程图和盒图</h2><p>流程图和盒图都是描述程序的细节逻辑。<br>流程图的特点是简单、直观、医学，缺点是由于其随意性使画出来的流程图容易变成费及饿哦固化的流程图。<br>盒图是为了解决这一问题设计的。<br>盒图的主要特点是功能域明确、无法任意转移控制、容易确定全局数据和局部数据的作用域、容易表示嵌套关系、可以表示模块的层次结构。<br>盒图的缺点是修改相对比较困难。<br><img src="/images/ruankao/6-6.png"></p><h2 id="4、PAD和PDL"><a href="#4、PAD和PDL" class="headerlink" title="4、PAD和PDL"></a>4、PAD和PDL</h2><p>问题分析图PAD，能够方便的转换成程序语言的源程序代码。<br>语言描述工具PDL，伪代码，形式化语言，其控制结构和描述是确定的，但内部的描述语言是不确定的。</p><h1 id="三、模块设计"><a href="#三、模块设计" class="headerlink" title="三、模块设计"></a>三、模块设计</h1><p>在模块化方法中，将软件分解成若干小的模块，每个模块可独立开发、测试。<br>模块设计时，最重要的原则是实现信息隐蔽和模块独立。</p><h2 id="1、信息隐蔽原则"><a href="#1、信息隐蔽原则" class="headerlink" title="1、信息隐蔽原则"></a>1、信息隐蔽原则</h2><p>将难的决策、可能修改的决策、数据结构的内部链接以及对他所做的操作细节、内部特征码、与计算机硬件有关的细节隐藏起来。<br>可以提高软件的可修改性、可测试性和可移植性。</p><h2 id="2、模块独立性原则"><a href="#2、模块独立性原则" class="headerlink" title="2、模块独立性原则"></a>2、模块独立性原则</h2><p>每个模块完成一个相对独立的特定子功能，并与其他模块之间的联系最简单。<br>设计的目标是高内聚、低耦合。</p><p>从高到低对7种内聚类型排序：</p><table><thead><tr><th>内聚类型</th><th>描述</th></tr></thead><tbody><tr><td>功能内聚</td><td>完成一个单一功能，各个部分协同工作，缺一不可</td></tr><tr><td>顺序内聚</td><td>处理元素相关，而且必须顺序执行</td></tr><tr><td>通信内聚</td><td>所有处理元素居中在一个数据结构的区域上</td></tr><tr><td>过程内聚</td><td>处理元素相关，而且必须按特定的次序执行</td></tr><tr><td>瞬时内聚</td><td>所包含的任务必须在同一时间间隔内执行，如初始化模块</td></tr><tr><td>逻辑内聚</td><td>完成逻辑上相关的一组任务</td></tr><tr><td>偶然内聚</td><td>完成一组没有关系或松散关系的任务</td></tr></tbody></table><p>从低到高7种耦合类型排序：</p><table><thead><tr><th>耦合类型</th><th>描述</th></tr></thead><tbody><tr><td>非直接耦合</td><td>没有直接联系，互相不依赖对方</td></tr><tr><td>数据耦合</td><td>借助参数表传递简单数据</td></tr><tr><td>标记耦合</td><td>一个数据结构的一部分借助于模块接口来传递</td></tr><tr><td>控制耦合</td><td>模块间传递的信息中包括用于控制模块内部逻辑的信息</td></tr><tr><td>外部耦合</td><td>与软件意外的环境有关</td></tr><tr><td>公共耦合</td><td>多个模块引用同一个全局数据区</td></tr><tr><td>内容耦合</td><td>一个模块访问另一个模块的内部数据</td></tr><tr><td>-</td><td>一个模块不通过正常入口转到另一个模块的内部</td></tr><tr><td>-</td><td>两个模块有一部分程序代码重叠</td></tr><tr><td>-</td><td>一个模块有多个入口</td></tr></tbody></table><p>系统设计时，除了保持信息隐蔽和模块独立性之外，还需要考虑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">保持模块大小适中</span><br><span class="line">尽可能减少调用深度</span><br><span class="line">直接调用该模块的个数应该尽量大</span><br><span class="line">调用其他模块的个数不宜过大</span><br><span class="line">保证模块是单入口、单出口</span><br><span class="line">模块的作用于应该在控制域之内</span><br><span class="line">功能应该是可预测的</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-系统分析与设计方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统分析与设计方法（九）系统过渡计划</title>
      <link href="/2021/09/24/%E8%BD%AF%E8%80%83/8%E3%80%81%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89%E7%B3%BB%E7%BB%9F%E8%BF%87%E6%B8%A1%E8%AE%A1%E5%88%92/"/>
      <url>/2021/09/24/%E8%BD%AF%E8%80%83/8%E3%80%81%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89%E7%B3%BB%E7%BB%9F%E8%BF%87%E6%B8%A1%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>如果同时运行两个系统，会给客户造成多大的开销;<br>如果直接运行新系统，客户面对的风险有多大;<br>对新系统试运行时的查错和纠错，以及出现严重错误而导致停止运行时的应急措施;<br>客户运行新系统将面临的不利因素有哪些;<br>人员的培训。</p><h1 id="1-直接过渡"><a href="#1-直接过渡" class="headerlink" title="1.直接过渡"></a>1.直接过渡</h1><p>这是一种快速的系统过渡方式，当新系统运行时，立即关闭原来的系统。这种过渡方式非常简单，没有后勤保障的问题，也不要消耗很多资源。同时，它也意味着大风险，目标系统的特性决定了风险的大小。设计者主要要权衡当新系统失败时，系统停止运行或者勉强运行给客户带来的损失有多大。由于这种过渡方式简单而费用低廉，对于可以容忍停机一段时间的系统的实践者，可以采用这种方式。</p><h1 id="2-并行过渡"><a href="#2-并行过渡" class="headerlink" title="2.并行过渡"></a>2.并行过渡</h1><p>设计者采用并行过渡方式，让新系统和旧系统在一段时间里同时运行，通过这样的旧系统作为新系统的备份，可以大大降低系统过渡的风险。可是并行过渡显然比直接过渡要消耗更多的资源:现有的硬件资源必须保证能同时跑两套系统，这常常意味着增加服务器和额外的存储空间，需要增加人员来同时使用两套系统，或者增加现有员工的工作量，让他们同时操作两套系统。这种方式同时也增加了管理和后勤保障的复杂度。</p><p>有些系统无法使用并行过渡的方式，主要是客户没有足够的资源来维持两个系统同时运行，另外一种情况是新、旧系统差别太大，旧系统的数据无法为新系统采用。当客户无法使用并行过渡，又想尽可能地减少风险，设计者可以使用部分并行过渡的策略，使并行的开销减少到客户能够接受的范围内。</p><h1 id="3-阶段过渡"><a href="#3-阶段过渡" class="headerlink" title="3.阶段过渡"></a>3.阶段过渡</h1><p>通常在系统非常复杂、过于庞大以至于无法一次性进行过渡时采用，也适用于分阶段开发的系统。设计者需要设计一系列步骤和过程来完成整个系统的过渡，这种过渡方式和系统的复杂程度相关，随着系统的不同往往有很大的不同。和并行过渡一样，阶段过渡也能够减少风险，显然局部的失败要比全体的失败更容易接受，带来的损失更小。阶段过渡也带来了复杂性，有时候比并行过渡更加复杂。</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-系统分析与设计方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统分析与设计方法（五）用户界面设计</title>
      <link href="/2021/09/24/%E8%BD%AF%E8%80%83/8%E3%80%81%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/"/>
      <url>/2021/09/24/%E8%BD%AF%E8%80%83/8%E3%80%81%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>接口设计主要包括三个方面的内容:一是设计软件构件间的接口;二是设计模块和其他非人的信息生产者和消费者(如外部实体)的接口;三是人(如用户)和计算机间界面设计。</p><h1 id="一、用户界面设计的原则"><a href="#一、用户界面设计的原则" class="headerlink" title="一、用户界面设计的原则"></a>一、用户界面设计的原则</h1><p>用户界面设计必须考虑软件使用者的体力和脑力，设计时必须遵从三个黄金法则。</p><h2 id="1、置用户于控制之下"><a href="#1、置用户于控制之下" class="headerlink" title="1、置用户于控制之下"></a>1、置用户于控制之下</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">以不强迫用户进入不必要的或不希望的动作的方式来定义交互模式</span><br><span class="line">提供灵活的交互</span><br><span class="line">允许用户交互可以被中断和撤销</span><br><span class="line">当技能级别增长时可以使交互流水化并允许定制交互</span><br><span class="line">使用户隔离内部技术细节</span><br><span class="line">设计应允许用户和出现在屏幕上的对象直接交互</span><br></pre></td></tr></table></figure><h2 id="2、减少用户的记忆负担"><a href="#2、减少用户的记忆负担" class="headerlink" title="2、减少用户的记忆负担"></a>2、减少用户的记忆负担</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">减少对短期记忆的要求</span><br><span class="line">建立有意义的默认</span><br><span class="line">定义直觉性的捷径</span><br><span class="line">界面的视觉布局应该基于对真实世界的隐喻</span><br><span class="line">以不断进展的方式提示信息</span><br></pre></td></tr></table></figure><h2 id="3、保持界面的一致"><a href="#3、保持界面的一致" class="headerlink" title="3、保持界面的一致"></a>3、保持界面的一致</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">允许用户将当前任务放入有意义的语境</span><br><span class="line">在应用系列内保持一致性，如果过去的交互模型已经建立了用户期望，除非有不得已的理由，否则不要改变它</span><br></pre></td></tr></table></figure><p>除此之外，还应该考虑表所示的设计原则。</p><p><img src="/images/ruankao/6-18.png"></p><h1 id="二、用户界面设计过程"><a href="#二、用户界面设计过程" class="headerlink" title="二、用户界面设计过程"></a>二、用户界面设计过程</h1><p><img src="/images/ruankao/6-19.png"></p><h2 id="1-用户、任务和环境分析"><a href="#1-用户、任务和环境分析" class="headerlink" title="(1)用户、任务和环境分析"></a>(1)用户、任务和环境分析</h2><p>着重于分析将和系统交互的用户的特点。记录下技术级别、业务理解及对新系统的一般感悟，并定义不同的用户类别。然后对用户将要完成什么样的任务进行详细的标识和描述。最后对用户的物理工作环境进行了解与分析。</p><h2 id="2-界面设计"><a href="#2-界面设计" class="headerlink" title="(2)界面设计"></a>(2)界面设计</h2><p>主要包括建立任务的目标和意图，为每个目标或意图制定特定的动作序列，按在界面上执行的方式对动作序列进行规约，指明系统状态，定义控制机制，指明控制机制如何影响系统状态，指明用户如何通过界面上的信息来解释系统状态。</p><h2 id="3-实现"><a href="#3-实现" class="headerlink" title="(3)实现"></a>(3)实现</h2><p>就是根据界面设计进行实现，前期可以通过原型工具来快速实现，减少返工的工作量。</p><h2 id="4-界面确认"><a href="#4-界面确认" class="headerlink" title="(4)界面确认"></a>(4)界面确认</h2><p>界面实现后就可以进行一些定性和定量的数据收集，以进行界面的评估，以调整界面的设计。</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-系统分析与设计方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统分析与设计方法（六）工作流设计</title>
      <link href="/2021/09/24/%E8%BD%AF%E8%80%83/8%E3%80%81%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E5%B7%A5%E4%BD%9C%E6%B5%81%E8%AE%BE%E8%AE%A1/"/>
      <url>/2021/09/24/%E8%BD%AF%E8%80%83/8%E3%80%81%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E5%B7%A5%E4%BD%9C%E6%B5%81%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>现实中的流程存在大量的不确定性。</p><h1 id="一、工作流设计概述"><a href="#一、工作流设计概述" class="headerlink" title="一、工作流设计概述"></a>一、工作流设计概述</h1><p>工作流是一类能够完全或者部分自动执行的经营过程，根据一系列过程规则、文档、信息或任务在不同的执行者之间 传递、执行。</p><h2 id="1-工作流"><a href="#1-工作流" class="headerlink" title="(1)工作流"></a>(1)工作流</h2><p>工作流是现实中的具体工作从开始到结束过程的抽象和概括。这个过程包括了众多因素:任务顺序、路线规则、时间时限约束等。</p><h2 id="2-流程定义"><a href="#2-流程定义" class="headerlink" title="(2)流程定义"></a>(2)流程定义</h2><p>流程定义是指对业务过程的形式化表示，它定义了过程运行中的活动和所涉及的各种信息。这些信息包括</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">过程的开始和完成条件</span><br><span class="line">构成过程的活动及进行活动间导航的规则</span><br><span class="line">用户所需要完成的任务</span><br><span class="line">可能被调用的应用</span><br><span class="line">工作流间的引用关系</span><br><span class="line">工作流数据的定义</span><br></pre></td></tr></table></figure><h2 id="3-流程实例"><a href="#3-流程实例" class="headerlink" title="(3)流程实例"></a>(3)流程实例</h2><p>也称为工作，是一个流程定义的运行实例。</p><h2 id="4-工作流管理系统"><a href="#4-工作流管理系统" class="headerlink" title="(4)工作流管理系统"></a>(4)工作流管理系统</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">存储流程的定义</span><br><span class="line">按照所使用的流程定义来触发流程状态的改变</span><br><span class="line">推动流程的运转</span><br></pre></td></tr></table></figure><p>这个推动的依据常常称为工作流引擎。</p><h2 id="5-流程定义工具"><a href="#5-流程定义工具" class="headerlink" title="(5)流程定义工具"></a>(5)流程定义工具</h2><p>使用流程定义工具来完成流程定义的工作</p><h2 id="6-参与者"><a href="#6-参与者" class="headerlink" title="(6)参与者"></a>(6)参与者</h2><p>可以是具体的人或者角色(企业内部有特别共同作用的多个人)，也可以是自动化系统，甚至是其他系统。</p><h2 id="7-活动"><a href="#7-活动" class="headerlink" title="(7)活动"></a>(7)活动</h2><p>活动是流程定义中的一个元素，一次活动可能改变流程处理数据的内容、流程的状态，并可能将流程推动到其他活动中去。活动可以由人来完成，也可以是系统自动的处理过程。</p><h2 id="8-活动所有者"><a href="#8-活动所有者" class="headerlink" title="(8)活动所有者"></a>(8)活动所有者</h2><p>决定该活动是否结束</p><h2 id="9-工作所有者"><a href="#9-工作所有者" class="headerlink" title="(9)工作所有者"></a>(9)工作所有者</h2><p>有权整体控制流程实例执行过程的参与者</p><h2 id="10-工作项"><a href="#10-工作项" class="headerlink" title="(10)工作项"></a>(10)工作项</h2><p>流程实例中活动的参与者将要执行的工作</p><h1 id="二、工作流管理系统"><a href="#二、工作流管理系统" class="headerlink" title="二、工作流管理系统"></a>二、工作流管理系统</h1><p>在工作流形式化表示的驱动下，通过软件的执行而完成工作流定义、管理及执行的系统。<br>主要目标是对业务过程中各活动发生的先后次序及与活动相关的相应人力或信息资源的调用进行管理，而实现业务过程的自动化。</p><p>工作流管理系统的6个最基本组成：</p><h2 id="1-流程定义工具"><a href="#1-流程定义工具" class="headerlink" title="(1)流程定义工具"></a>(1)流程定义工具</h2><p>提供图形化或者其他方式的界面给设计者。由设计者将实际工作流程进行抽象，并将设计者提交的流程定义转换为形式化语言描述，提供给计算机工作流执行服务进行流程实例处理的依据。</p><h2 id="2-工作流执行服务"><a href="#2-工作流执行服务" class="headerlink" title="(2)工作流执行服务"></a>(2)工作流执行服务</h2><p>1、使用一种或者多种数据流引擎，对流程定义进行解释，激活有效的流程实例，推动流程实例在不同的活动中运转。<br>2、和客户应用程序、其他工作流服务执行程序及其他应用程序进行交互，从而完成流程实例的创建、执行和管理工作。<br>3、为每个用户维护一个活动列表，告诉用户当前必须处理的任务。<br>4、通过电子邮件甚至是短消息的形式提醒用户任务的到达。</p><h2 id="3-其他工作流执行服务"><a href="#3-其他工作流执行服务" class="headerlink" title="(3)其他工作流执行服务"></a>(3)其他工作流执行服务</h2><p>大型的企业工作流应用，往往包括多个工作流管理系统。这就需要这些工作流管理系统之间进行有效的交互，避免画地为牢、信息孤岛的现象出现。</p><h2 id="4-客户应用程序"><a href="#4-客户应用程序" class="headerlink" title="(4)客户应用程序"></a>(4)客户应用程序</h2><p>最终用户的界面，用户通过使用这部分软件对工作流的数据进行必要的处理，如果用户是当前活动的拥有者，还可通过客户应用程序改变流程实例的活动，将流程实例推动到另外一个活动中。</p><h2 id="5-被调用应用程序"><a href="#5-被调用应用程序" class="headerlink" title="(5)被调用应用程序"></a>(5)被调用应用程序</h2><p>对工作流所携带数据的处理程序。</p><h2 id="6-管理和监控工具"><a href="#6-管理和监控工具" class="headerlink" title="(6)管理和监控工具"></a>(6)管理和监控工具</h2><p>对流程实例的状态查询、挂起、恢复、销毁等操作，同时提供系统参数、系统运行情况统计等数据。</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-系统分析与设计方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统分析与设计方法（八）系统运行环境的集成与设计</title>
      <link href="/2021/09/24/%E8%BD%AF%E8%80%83/8%E3%80%81%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E9%9B%86%E6%88%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
      <url>/2021/09/24/%E8%BD%AF%E8%80%83/8%E3%80%81%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E9%9B%86%E6%88%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>在设计一个新的系统时，设计者必须考虑目标系统的运行环境问题。软件的运行环境是指系统运行的设备、操作系统和网络配置。</p><h1 id="1-集中式系统"><a href="#1-集中式系统" class="headerlink" title="1.集中式系统"></a>1.集中式系统</h1><p>所有的操作都集中于一台主机中。</p><p>集中式系统常见于银行、保险、证券行业，它们含有大规模的处理应用。</p><p>在现代的系统中，集中式系统通常是某个分布式系统的一个环节。</p><p>集中式系统由以下几个部分组成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1)单计算机结构:这种结构简单、容易维护，但是处理能力受到限制。 </span><br><span class="line">(2)集群结构:由多个计算机组成，这些计算机具有类似的硬件平台、操作系统等。通常采用负载均衡、资源共享等方式实现更大的处理能力和容量。 </span><br><span class="line">(3)多计算机结构:由多个计算机组成，这些计算机之间操作环境可能不同。适用于当系统可以分解成多个不同的子系统时。</span><br></pre></td></tr></table></figure><h1 id="2-分布式系统"><a href="#2-分布式系统" class="headerlink" title="2.分布式系统"></a>2.分布式系统</h1><p>分布式系统由于网络的普遍延伸，费用的不断降低而越来越成为大型系统的首选环境。分布式系统必须基于网络，这个网络可以是在一个地域内的局域网，也可以是跨越不同城市乃至国家的广域网。对比集中式的计算机环境，分布式系统有着多种多样的形式。这也给设计者在确定系统运行环境时带来一定的烦恼。</p><h1 id="3-C-S-结构"><a href="#3-C-S-结构" class="headerlink" title="3.C/S 结构"></a>3.C/S 结构</h1><p>由提供服务的服务器和发起请求、接受结果的客户机构成。</p><h1 id="4-多层结构"><a href="#4-多层结构" class="headerlink" title="4.多层结构"></a>4.多层结构</h1><p>C/S 结构的扩展。</p><p>典型的分为由存储数据的数据库服务器作为数据层、实现商业规则的程序作为逻辑层、管理用户输入输出的视图层所组成的三层结构。</p><p>多层结构形式复杂，功能多样。实现多层结构常常需要来实现不同层次间通信的专门程序——管件，也称为中间件。中间件大多数实现远程程序调用、对象请求调度等功能。</p><h1 id="5-Internet、Intranet-和-Extranet"><a href="#5-Internet、Intranet-和-Extranet" class="headerlink" title="5.Internet、Intranet 和 Extranet"></a>5.Internet、Intranet 和 Extranet</h1><p>Internet 是全球的网络集合，使用通用的 TCP/IP 协议来相互连接。Internet 提供电子邮件、文件传输、远程登录等服务。</p><p>Intranet 是私有网络，只限于内部使用，也使用 TCP/IP 协议。</p><p>Extranet 是一个扩展的 Intranet。它包括企业之外的和企业密切相关合作的其他企业。 Extranet 允许分离的组织交换信息并进行合作，这样就形成了一个虚拟组织。</p><p>现在的 VPN 技术允许在公用网络上架构只对组织内部开发服务。</p><p>Web 同样基于 C/S 结构，实际上 Web 接口是一个通用的接口，不是只能使用浏览器 的协议，它同样能够在普通的程序中使用。</p><p>Internet 和 Web 已经给设计者提供了一个非常富有吸引力的选择方案。它的优势在于:它们已经成为网络的事实上的标准，支持它们的软件已经广泛地存在于全世界的计算机中，而且通信费用已经下降到很有竞争力的水平。</p><p>采用 Internet 时，必须考虑其不利的一面。 Internet 的安全性过去、现在、以后都是设计者头痛的问题。其他诸如可靠性、系统吞吐量、不断发展的技术和标准都是影响系统选择它们作为运行环境的不利因素。</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-系统分析与设计方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统分析与设计方法（四）面向对象的分析与设计</title>
      <link href="/2021/09/24/%E8%BD%AF%E8%80%83/8%E3%80%81%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
      <url>/2021/09/24/%E8%BD%AF%E8%80%83/8%E3%80%81%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>面向对象方法以客观世界中的对象为中心，其分析和设计思想符合人们的思维方式，分析和设计的结构与客观世界的实际比较接近。</p><p>面向对象方法中，分析和设计的界面并不明显，他们采用的相同的符号表示，能方便的从分析阶段平滑过渡到设计阶段。</p><p>在显示生活中，用户的需求经常会发生变化，但是客观世界的对象集对象间的关系比较稳定，因此用面向对象方法分析和设计的结构也相对比较稳定。</p><h1 id="一、面向对象的基本概念"><a href="#一、面向对象的基本概念" class="headerlink" title="一、面向对象的基本概念"></a>一、面向对象的基本概念</h1><h2 id="1、对象和类"><a href="#1、对象和类" class="headerlink" title="1、对象和类"></a>1、对象和类</h2><p>对象是描述客观事物的实体，由对象标识（名称）、属性（状态、数据、成员变量）和服务（操作、行为、方法）是3个要素组成，封装成一个整体，以接口的形式对外提供服务。<br>类是具有相同属性和服务的一个或一组对象的抽象。<br>类与对象是抽象描述和具体实例的关系。一个具体的对象被称为类的一个实例。</p><p>类可以分为实体类、边界类、控制类。</p><h3 id="（1）实体类"><a href="#（1）实体类" class="headerlink" title="（1）实体类"></a>（1）实体类</h3><p>实体类映射需求中的每个实体，实体类保存需要存储在永久存储体重的信息。<br>实体类一定有属性，不一定有操作。</p><h3 id="（2）控制类"><a href="#（2）控制类" class="headerlink" title="（2）控制类"></a>（2）控制类</h3><p>控制类是用于控制用力工作的类，一般由动宾结构的短语转化来的名称，例如身份验证。<br>控制类没有属性，但是有方法。</p><h3 id="（3）边界类"><a href="#（3）边界类" class="headerlink" title="（3）边界类"></a>（3）边界类</h3><p>边界类用于封装在用例内、外流动的信息或数据流。边界类位于系统与外界的交界处，包括所有窗体、报表、打印机和扫描仪等硬件接口，以及与其他系统的接口。<br>边界类通常既有属性也要方法。</p><h2 id="2、继承与泛化"><a href="#2、继承与泛化" class="headerlink" title="2、继承与泛化"></a>2、继承与泛化</h2><p>用来说明特殊类（子类）与一般类（父类）的关系。</p><p><img src="/images/ruankao/6-7.png"></p><h2 id="3、多态与重载"><a href="#3、多态与重载" class="headerlink" title="3、多态与重载"></a>3、多态与重载</h2><p>一般类中定义的属性或服务被特殊类集成后，可以具有不同的数据类型或表现出不同的行为。<br>通常用重载和改写实现。<br>重载是编译时制定的，改写是运行时选择的。</p><h2 id="4、模板类"><a href="#4、模板类" class="headerlink" title="4、模板类"></a>4、模板类</h2><p>也称为类属类，用来实现参数多态机制。<br>一个类属类是一组类的一个特性抽象。</p><h2 id="5、消息和消息通信"><a href="#5、消息和消息通信" class="headerlink" title="5、消息和消息通信"></a>5、消息和消息通信</h2><p>消息是想对象发出的服务请求。 为对象间提供唯一合法的动态联系的途径。</p><h1 id="二、面向对象分析"><a href="#二、面向对象分析" class="headerlink" title="二、面向对象分析"></a>二、面向对象分析</h1><p>对象技术的流行，演化出数十种不同的OOA方法，其中比较流行的包括OMT、OOA、OOSE、Booch等。OMT、OOSE、Booch最后统一成为UML。</p><h2 id="1、OOA-OOD方法"><a href="#1、OOA-OOD方法" class="headerlink" title="1、OOA/OOD方法"></a>1、OOA/OOD方法</h2><p>面向对象分析（OOA），面向对象设计（OOD）。<br>OOA模型包括<em><strong>主题、对象类、结构、属性和服务</strong></em>5个层次。需要经过<em><strong>标识对象类、标识结构与关联、划分主题、定义属性、定义服务</strong></em>5个步骤完成整个分析工作。<br>OOD贯穿OOA的5个层次和5个活动，由<em><strong>人机交互部件、问题域部件、任务管理部件、数据管理部件</strong></em>4个部分组成。</p><h3 id="（1）设计问题域部分"><a href="#（1）设计问题域部分" class="headerlink" title="（1）设计问题域部分"></a>（1）设计问题域部分</h3><p>OOA的结果是OOD的问题域部件，分析的结果在OOD中可以被改动或增补，但基于问题域的总体组织架构是长时间稳定的。</p><h3 id="（2）设计人机交互部件"><a href="#（2）设计人机交互部件" class="headerlink" title="（2）设计人机交互部件"></a>（2）设计人机交互部件</h3><p>在上述结果中加入人机交互的设计和交互细节。</p><h3 id="（3）设计任务管理部分"><a href="#（3）设计任务管理部分" class="headerlink" title="（3）设计任务管理部分"></a>（3）设计任务管理部分</h3><p>识别事件驱动任务、识别时钟驱动任务、识别优先任务和关键任务、识别协调者、审查每个任务并定义每个任务。</p><h3 id="（4）设计数据管理部分"><a href="#（4）设计数据管理部分" class="headerlink" title="（4）设计数据管理部分"></a>（4）设计数据管理部分</h3><p>数据管理部分提供了在数据管理系统中存储和紧缩对象的基本结构，其目的是隔离数据管理方法对其他部分的影响。</p><h2 id="2、Booch方法"><a href="#2、Booch方法" class="headerlink" title="2、Booch方法"></a>2、Booch方法</h2><p>Booch认为软件开发是螺旋上升的过程，每个周期包括 标识类和对象、确定类和对象的含义、标识关系、说明每个类的接口和实现 4个步骤。</p><table><thead><tr><th></th><th>静态模型</th><th>动态模型</th></tr></thead><tbody><tr><td>逻辑模型</td><td>类图、对象图</td><td>状态转换图、时序图</td></tr><tr><td>物理模型</td><td>模块图、进程图</td><td>-</td></tr></tbody></table><p>Booch方法的开发过程是一个迭代的渐进式的系统开发过程，分为宏过程和微过程梁两类。<br>宏过程用于控制微过程，5个主要活动包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">建立核心需求的概念化</span><br><span class="line">建立模型的分析</span><br><span class="line">建立架构的设计</span><br><span class="line">形成实现的进化</span><br><span class="line">管理软件交付使用的维护</span><br></pre></td></tr></table></figure><p>微过程基本上代表开发人团的日常活动，4个重要、没有顺序的步骤包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在给定的抽象层次上识别出类和对象</span><br><span class="line">识别出这些类和对象的语义</span><br><span class="line">识别出类间和对象间的关系</span><br><span class="line">实现类和对象</span><br></pre></td></tr></table></figure><h2 id="3、OMT方法"><a href="#3、OMT方法" class="headerlink" title="3、OMT方法"></a>3、OMT方法</h2><p>对象建模技术（OMT）主要用于分析、系统设计和对象设计。<br>包括对象模型、动态模型、功能模型。</p><table><thead><tr><th>模型</th><th>说明</th><th>主要技术</th></tr></thead><tbody><tr><td>对象模型</td><td>描述系统中对象的静态结构、对象之间的关系、属性、操作。他表示静态的、结构上的、系统的“数据”特征。</td><td>对象图</td></tr><tr><td>动态模型</td><td>描述与时间和操作顺序有关的系统特征，如激发时间、时间序列、确定时间先后关系的状态。他表示瞬时、行为上的、系统的“控制”特征</td><td>状态图</td></tr><tr><td>功能模型</td><td>描述与值的变换有关的系统特征：功能、映射、约束和函数依赖</td><td>数据流图</td></tr></tbody></table><h2 id="4、OOSE方法"><a href="#4、OOSE方法" class="headerlink" title="4、OOSE方法"></a>4、OOSE方法</h2><p>面向对象软件工程（OOSE）在OMT的基础上对功能模型进行了补充，提出了“用例”的概念，最终取代数据流图进行需求分析和建立功能模型。</p><h1 id="三、统一建模语言"><a href="#三、统一建模语言" class="headerlink" title="三、统一建模语言"></a>三、统一建模语言</h1><p>统一建模语言（UML）</p><h2 id="1、UML是什么"><a href="#1、UML是什么" class="headerlink" title="1、UML是什么"></a>1、UML是什么</h2><p>是一种用于详细描述的可视化语言。<br>是一种构造语言，虽然不是一种可视化的编程语言，但与编程语言直接相连，有较好的映射关系。允许正向工程、逆向工程。<br>是一种文档化语言。</p><h2 id="2、UML的结构"><a href="#2、UML的结构" class="headerlink" title="2、UML的结构"></a>2、UML的结构</h2><p>UML由构造块、公共机制和架构三部分组成。</p><h3 id="（1）构造块"><a href="#（1）构造块" class="headerlink" title="（1）构造块"></a>（1）构造块</h3><p>构造块也就是基本的UML建模元素、关系和图。<br>建模元素：包括构造事物（类、接口、协作、用例、活动类、组件、节点等）、行为事物（交互、状态机）、分组事物（包）、注释事物。<br>关系：包括关联关系、依赖关系、泛化关系、实现关系。<br>图：UML2.0包括14种不同的图，分为表示系统静态结构的静态模型（包括类图、对象图、包图、构件图、部署图、制品图），以及表示系统动态结构的动态模型（包括对象图、用例图、顺序图、通信图、定时图、状态图、活动图、我交互概览图）。</p><h3 id="（2）公共机制"><a href="#（2）公共机制" class="headerlink" title="（2）公共机制"></a>（2）公共机制</h3><p>指达到特定目标的公共UML方法，包括规格说明、修饰、公共分类和扩展机制4种。<br>规格说明：是元素语义的文本描述。<br>修饰：通过修饰给模型元素表达更多的信息。<br>公共分类：包括类元和实体、接口和实现两组公共分类。<br>扩展机制：包括约束、构造型、标记值。</p><h3 id="（3）架构"><a href="#（3）架构" class="headerlink" title="（3）架构"></a>（3）架构</h3><p>架构是系统的组织结构，包括系统分解的组成部分、他们的关联性、交互、机制和指导原则。</p><p>具体来说，就是5个系统视图。</p><p>逻辑视图：以问题域的语汇组成的类和对象集合。<br>进程视图：可执行线程和进程作为活动类的建模，他是逻辑视图的一次执行实例。<br>实现视图：对组成基于系统的物理代码的文件和组件进行建模。<br>部署视图：把组件物理的部署到一组物理的可计算的节点上。<br>用例视图：最基本的需求分析模型。</p><h2 id="3、用例图基础"><a href="#3、用例图基础" class="headerlink" title="3、用例图基础"></a>3、用例图基础</h2><p>外部参与者所理解的系统功能。</p><p><img src="/images/ruankao/6-8.png"></p><p>包括参与者、用例、包含和扩展。</p><h2 id="4、类图和对象图基础"><a href="#4、类图和对象图基础" class="headerlink" title="4、类图和对象图基础"></a>4、类图和对象图基础</h2><p>类图技术是OO方法的核心。</p><p><img src="/images/ruankao/6-9.png"></p><h3 id="（1）类和对象"><a href="#（1）类和对象" class="headerlink" title="（1）类和对象"></a>（1）类和对象</h3><p>类是对一类具有相同特征的对象的描述。<br>对象是类的实例。<br>类的属性的语法为: “可见性 属性名:类型 = 默认值 {约束特性}”。<br>可见性包括 Public、Private 和 Protected，分别用+、-、#号表示。<br>类的操作的语法为: “可见性:操作名(参数表):返回类型 {约束特性}”。</p><h3 id="（2）类之间的关系"><a href="#（2）类之间的关系" class="headerlink" title="（2）类之间的关系"></a>（2）类之间的关系</h3><p>①依赖关系。使用带箭头的虚线表示依赖关系。<br>②泛化关系。继承关系是泛化关系的反关系，也就是说子类是从父类中继承的，而父类则是子类的泛化。使用带空心箭头的实线表示，箭头指向父类。<br>③关联关系。用一条实线来表示关联关系。<br>聚合关系:聚合是一种特殊形式的关联。聚合表示类之间的关系是整体与部分的关系。例如 一辆轿车包含四个车轮、一个方向盘、一个发动机和一个底盘，就是聚合的一个例子。在 UML 中，用一个带空心菱形的实线表示，空心菱形指向的是代表“整体”的类。<br>组合关系:如果聚合关系中的表示“部分”的类的存在，与表示“整体”的类有着紧密的关系，例如“公司”与“部门”之间的关系，那么就应该使用“组合”关系来表示。在 UML 中， 用带有实心菱形的实线表示，菱形指向的是代表“整体”的类。<br>④实现关系。用一个带空心箭头的虚线表示。<br><img src="/images/ruankao/6-9-1.png"></p><h3 id="（3）多重性问题"><a href="#（3）多重性问题" class="headerlink" title="（3）多重性问题"></a>（3）多重性问题</h3><p>多重性是用来说明关联的两个类之间的数量关系的。<br>0…1;0…<em>;1…1;1…</em>;*</p><h3 id="（4）类图"><a href="#（4）类图" class="headerlink" title="（4）类图"></a>（4）类图</h3><p>对于软件系统，其类模型和对象模型类图描述类和类之间的静态关系。与数据模型不同，它不仅显示了信息的结构，同时还描述了系统的行为。类图是定义其他图的基础。</p><h3 id="（5）对象图"><a href="#（5）对象图" class="headerlink" title="（5）对象图"></a>（5）对象图</h3><p>UML 中对象图与类图具有相同的表示形式。对象图可以看作是类图的一个实例。</p><h2 id="5、交互图基础"><a href="#5、交互图基础" class="headerlink" title="5、交互图基础"></a>5、交互图基础</h2><p>交互图是表示各组对象如何按某种行为进行协作的模型。通常可以使用一个交互图来表示和说明一个用例的行为。</p><h3 id="（1）顺序图"><a href="#（1）顺序图" class="headerlink" title="（1）顺序图"></a>（1）顺序图</h3><p>顺序图用来描述对象之间动态的交互关系，着重体现对象间消息传递的时间顺序。顺序图允许直观地表示出对象的生存期，在生存期内，对象可以对输入消息做出响应，并且可以发送信息。<br><img src="/images/ruankao/6-10.png"></p><h3 id="（2）通信图"><a href="#（2）通信图" class="headerlink" title="（2）通信图"></a>（2）通信图</h3><p>通信图用于描述相互合作的对象间的交互关系和链接关系。虽然顺序图和通信图都用来描述对象间的交互关系，但侧重点不一样。顺序图着重体现交互的时间顺序，通信图则着重体现交互对象间的静态链接关系。<br><img src="/images/ruankao/6-11.png"></p><h3 id="（3）定时图"><a href="#（3）定时图" class="headerlink" title="（3）定时图"></a>（3）定时图</h3><p>定时图是一种特殊形式的顺序图。<br><img src="/images/ruankao/6-12.png"></p><h2 id="6、状态图基础"><a href="#6、状态图基础" class="headerlink" title="6、状态图基础"></a>6、状态图基础</h2><p>状态图用来描述一个特定对象的所有可能状态及其引起状态转移的事件。<br><img src="/images/ruankao/6-13.png"></p><h2 id="7、活动图基础"><a href="#7、活动图基础" class="headerlink" title="7、活动图基础"></a>7、活动图基础</h2><p>活动图的应用非常广泛，它既可用来描述操作(类的方法)的行为，也可以描述用例和对象内部的工作过程。<br>活动图是由状态图变化而来的，它们各自用于不同的目的。活动图依据对象状态的变化来捕获动作(将要执行的工作或活动)与动作的结果。活动图中一个活动结束后将立即进入下一个活动(在状态图中状态的变迁可能需要事件的触发)。</p><h3 id="1-基本活动图。"><a href="#1-基本活动图。" class="headerlink" title="(1)基本活动图。"></a>(1)基本活动图。</h3><p><img src="/images/ruankao/6-14.png"><br>判定:用菱形表示。<br>分支与组合:用粗线来表示分支和组合。</p><h3 id="2-带泳道的活动图。"><a href="#2-带泳道的活动图。" class="headerlink" title="(2)带泳道的活动图。"></a>(2)带泳道的活动图。</h3><p><img src="/images/ruankao/6-15.png"></p><h3 id="3-对象流。"><a href="#3-对象流。" class="headerlink" title="(3)对象流。"></a>(3)对象流。</h3><p>在活动图中可以出现对象。对象可以作为活动的输入或输出，对象与活 动间的输入/输出关系由虚线箭头来表示。如果仅表示对象受到某一活动的影响，则可用不带箭头的虚线来连接对象与活动。</p><h3 id="4-信号。"><a href="#4-信号。" class="headerlink" title="(4)信号。"></a>(4)信号。</h3><p>在活动图中可以表示信号的发送与接收，分别用发送和接收标识来表示。 发送和接收标识也可与对象相连，用于表示消息的发送者和接收者。</p><h2 id="8、构件图基础"><a href="#8、构件图基础" class="headerlink" title="8、构件图基础"></a>8、构件图基础</h2><p>构件图是面向对象系统的物理方面进行建模要用的两种图之一。它可以有效地显示一组构件，以及它们之间的关系。构件图中通常包括构件、接口及各种关系。<br><img src="/images/ruankao/6-16.png"><br>通常构件指的是源代码文件、二进制代码文件和可执行文件等。而构件图就是用来显示编译、链接或执行时构件之间的依赖关系的。</p><h3 id="对源代码进行建模"><a href="#对源代码进行建模" class="headerlink" title="对源代码进行建模"></a>对源代码进行建模</h3><p>这样可以清晰地表示出各个不同源程序文件之间的关系。</p><h3 id="对物理数据库建模"><a href="#对物理数据库建模" class="headerlink" title="对物理数据库建模"></a>对物理数据库建模</h3><p>用来表示各种类型的数据库、表之间的关系。</p><h3 id="对可调整的系统建模"><a href="#对可调整的系统建模" class="headerlink" title="对可调整的系统建模"></a>对可调整的系统建模</h3><p>例如对应用了负载均衡、故障恢复等系统的建模。</p><p>在绘制构件图时，应该注意侧重于描述系统的静态实现视图的一个方面，图形不要过于简化，应该为构件图取一个直观的名称，在绘制时避免产生线的交叉。</p><h2 id="9、部署图基础"><a href="#9、部署图基础" class="headerlink" title="9、部署图基础"></a>9、部署图基础</h2><p>部署图，也称为实施图，它和构件图一样，是面向对象系统的物理方面建模的两种图之一。构件图是说明构件之间的逻辑关系，而部署图则是在此基础上更进一步地描述系统硬件的物理拓扑结构及在此结构上执行的软件。部署图可以显示计算结点的拓扑结构和通信路径、结点上运行的软件构件，常用于帮助理解分布式系统。</p><h3 id="1-节点和连接。"><a href="#1-节点和连接。" class="headerlink" title="(1)节点和连接。"></a>(1)节点和连接。</h3><p>节点代表一个物理设备及其上运行的软件系统，如一台 UNIX 主机、一个 PC 终端、一台打印机、一个传感器等。<br>节点之间的连线表示系统之间进行交互的通信路径，在 UML 中被称为连接。<br>通信类型则放在连接旁边的“《》”之间，表示所用的通信协议或网络类型。</p><h3 id="2-构件和接口。"><a href="#2-构件和接口。" class="headerlink" title="(2)构件和接口。"></a>(2)构件和接口。</h3><p>在部署图中，构件代表可执行的物理代码模块，如一个可执行程序。</p><p><img src="/images/ruankao/6-17.png"><br>在面向对象方法中，类和构件等元素并不是所有的属性和操作都对外可见。它们对外提供了可见操作和属性，称之为类和构件的接口。界面可以表示为一头是小圆圈的直线。</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-系统分析与设计方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统分析与设计方法（一）定义问题与归结模型</title>
      <link href="/2021/09/22/%E8%BD%AF%E8%80%83/8%E3%80%81%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%9A%E4%B9%89%E9%97%AE%E9%A2%98%E4%B8%8E%E5%BD%92%E7%BB%93%E6%A8%A1%E5%9E%8B/"/>
      <url>/2021/09/22/%E8%BD%AF%E8%80%83/8%E3%80%81%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%9A%E4%B9%89%E9%97%AE%E9%A2%98%E4%B8%8E%E5%BD%92%E7%BB%93%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>软件系统的目的是为了解决问题。<br>定义问题的过程包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、理解真实世界中的问题和用户的需要。</span><br><span class="line">2、提出满足这些需要的解决方案的过程。</span><br></pre></td></tr></table></figure><h1 id="一、问题分析"><a href="#一、问题分析" class="headerlink" title="一、问题分析"></a>一、问题分析</h1><h2 id="1、在问题定义上达成共识"><a href="#1、在问题定义上达成共识" class="headerlink" title="1、在问题定义上达成共识"></a>1、在问题定义上达成共识</h2><p>用标准化的格式将问题写出来。</p><h2 id="2、理解问题的本质"><a href="#2、理解问题的本质" class="headerlink" title="2、理解问题的本质"></a>2、理解问题的本质</h2><p>通常用因果鱼骨图和帕累托图两种方式。</p><h3 id="（1）因果鱼骨图"><a href="#（1）因果鱼骨图" class="headerlink" title="（1）因果鱼骨图"></a>（1）因果鱼骨图</h3><p><img src="/images/ruankao/5-1.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将问题简明扼要的写在右侧方框中。</span><br><span class="line">确定问题潜在原因的主要类别，将他们连在鱼的脊骨上。</span><br><span class="line">用头脑风暴法寻找原因并归类。</span><br></pre></td></tr></table></figure><h3 id="（2）帕累托图"><a href="#（2）帕累托图" class="headerlink" title="（2）帕累托图"></a>（2）帕累托图</h3><p><img src="/images/ruankao/5-2.png"><br>采用直方图的形式，将问题的相对频率或大小从高到低排列，聚焦重要的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">明确问题。</span><br><span class="line">找到问题的各种可能原因。</span><br><span class="line">选择评价标准和考察期限，最常用的标准是频率和费用。</span><br><span class="line">收集各种原因发生的频率和费用数据。</span><br><span class="line">将原因按发生的频率或费用从大到小排列。</span><br><span class="line">将原因排在横轴，频率或费用排在纵轴。</span><br></pre></td></tr></table></figure><h2 id="3、确认项目干系人和用户"><a href="#3、确认项目干系人和用户" class="headerlink" title="3、确认项目干系人和用户"></a>3、确认项目干系人和用户</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">系统的用户是谁？</span><br><span class="line">系统的客户是谁？</span><br><span class="line">那些人收到系统输出的影响？</span><br><span class="line">系统完成收入使用后谁对她进行评估？</span><br><span class="line">其他系统内部或外部的客户？</span><br><span class="line">系统将来谁维护？</span><br></pre></td></tr></table></figure><h2 id="4、定义系统的边界"><a href="#4、定义系统的边界" class="headerlink" title="4、定义系统的边界"></a>4、定义系统的边界</h2><p>解决方案系统和现实世界之间的边界。在系统边界中，信息以输入和输出的形式流入系统，并由系统流向系统外的用户。</p><h3 id="（1）上下文范围图"><a href="#（1）上下文范围图" class="headerlink" title="（1）上下文范围图"></a>（1）上下文范围图</h3><p>数据流图中的顶层图，它反映领域信息，能够清晰的显示出系统和相邻系统的职责，能够从宏观层面了解系统。</p><h3 id="（2）用例模型"><a href="#（2）用例模型" class="headerlink" title="（2）用例模型"></a>（2）用例模型</h3><p>以参与者的角度描述“和系统进行交互的事物”。<br><img src="/images/ruankao/5-3.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">谁会对系统提供信息？</span><br><span class="line">谁会在系统中使用信息？</span><br><span class="line">谁会从系统中删除信息？</span><br><span class="line">谁将操作系统？</span><br><span class="line">系统将会在哪里使用？</span><br><span class="line">系统从那里得到信息？</span><br><span class="line">哪些外部系统要和系统进行交互？</span><br></pre></td></tr></table></figure><h2 id="5、确定系统实现的约束"><a href="#5、确定系统实现的约束" class="headerlink" title="5、确定系统实现的约束"></a>5、确定系统实现的约束</h2><p>从约束源开始考虑。<br>进度、投资收益、人员、设备预算、环境、操作系统、数据库、主机和客户机系统、技术问题、行政问题、已有软件、公司总体战略和程序、工具和语言的选择、人员和其他资源限制等。</p><h1 id="二、问题定义"><a href="#二、问题定义" class="headerlink" title="二、问题定义"></a>二、问题定义</h1><h2 id="1、目标"><a href="#1、目标" class="headerlink" title="1、目标"></a>1、目标</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">优势：目标不仅仅是解决问题，还要提供业务上的优势。</span><br><span class="line">度量：度量优势的标准</span><br><span class="line">合理性：获得的业务优势要大于工作量成本，才是合理的解决方案。</span><br><span class="line">可行性：要探寻能够满足度量标准的解决方案。</span><br><span class="line">可达成性：是否具备需要的技能，建设完成后是否能够操作它。</span><br></pre></td></tr></table></figure><p><img src="/images/ruankao/5-4.png"></p><h2 id="2、功能需求"><a href="#2、功能需求" class="headerlink" title="2、功能需求"></a>2、功能需求</h2><p>系统必须做的事，功能需求源于业务需求。</p><h2 id="3、非功能需求"><a href="#3、非功能需求" class="headerlink" title="3、非功能需求"></a>3、非功能需求</h2><p>系统必须具备的属性。<br>功能需求通常以动词为特征，非功能需求以副词为特征。<br>非功能需求主要包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">观感需求</span><br><span class="line">易用性需求</span><br><span class="line">性能需求</span><br><span class="line">可操作性需求</span><br><span class="line">可维护性和可移植性需求</span><br><span class="line">安全性需求</span><br><span class="line">文化和政策需求</span><br><span class="line">法律需求</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-系统分析与设计方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统分析与设计方法（二）需求分析与软件设计</title>
      <link href="/2021/09/22/%E8%BD%AF%E8%80%83/8%E3%80%81%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%B8%8E%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
      <url>/2021/09/22/%E8%BD%AF%E8%80%83/8%E3%80%81%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%B8%8E%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>需求分析阶段的主要任务是通过开发人员与用户之间的广泛交流，不断澄清模糊的概念，最终形成一个完整的、清晰的、一直的需求说明。（做什么）</p><p>在需求明确之后，下一步就是对软件系统进行设计。（怎么做）</p><h1 id="一、需求分析的任务与过程"><a href="#一、需求分析的任务与过程" class="headerlink" title="一、需求分析的任务与过程"></a>一、需求分析的任务与过程</h1><p>需求分析主要是确定待开发软件的功能、性能、数据、界面等要求。<br>需求分析的步骤包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">获取当前系统的物理模型</span><br><span class="line">抽象出当前系统的逻辑模型</span><br><span class="line">建立目标系统的逻辑模型</span><br></pre></td></tr></table></figure><p>需求分析工作的4个方面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">问题识别：用于发现需求、描述需求</span><br><span class="line">分析与综合：对问题进行分析，并给出解决方案</span><br><span class="line">编制需求分析的文档：输出《需求规格说明书》</span><br><span class="line">需求分析与评审：主要对功能的正确性、完整性和清晰性等给与评价。</span><br></pre></td></tr></table></figure><h2 id="1、需求的分类"><a href="#1、需求的分类" class="headerlink" title="1、需求的分类"></a>1、需求的分类</h2><p>软件需求包括功能需求、非功能需求、设计约束三方面。<br><img src="/images/ruankao/5-5.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">功能需求：系统必须完成的事，为了向用户提供有用的功能，产品必须执行的动作。</span><br><span class="line">非功能需求：产品必须具备的属性或者品质，如性能、响应时间、可靠性、容错性、扩展性等。</span><br><span class="line">设计约束：也叫限制条件、补充规约，比如必须采用国内自主知识版权的数据库等。</span><br></pre></td></tr></table></figure><p>除了上面三种需求之外，在其他维度，还有业务需求、用户需求、系统需求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">业务需求：客户对系统、产品高层次的目标要求。</span><br><span class="line">用户需求：用户使用产品必须要完成上面任务，通过访谈、调查，从用户角度出发的需求。</span><br><span class="line">系统需求：从系统角度的需求，包括用特性说明的功能需求、质量属性、非功能需求及设计约束。</span><br></pre></td></tr></table></figure><h2 id="2、需求工程"><a href="#2、需求工程" class="headerlink" title="2、需求工程"></a>2、需求工程</h2><p>创建和维护系统需求文档的所有活动，包括需求开发和需求管理两大工作。</p><h3 id="（1）需求开发"><a href="#（1）需求开发" class="headerlink" title="（1）需求开发"></a>（1）需求开发</h3><p>包括需求捕获、需求分析、编写规格说明书和需求验证四个阶段。<br>需求开发是目标，是主线，是努力掌握客户对系统的需求。</p><h3 id="（2）需求管理"><a href="#（2）需求管理" class="headerlink" title="（2）需求管理"></a>（2）需求管理</h3><p>包括需求基线、处理需求变更、需求跟踪等。<br>需求管理是支持，是保障，是对需求的变化进行管理的过程。</p><h2 id="2、需求分析方法"><a href="#2、需求分析方法" class="headerlink" title="2、需求分析方法"></a>2、需求分析方法</h2><p>根据分析方法发展的历史，分为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">结构化分析方法</span><br><span class="line">软系统方法</span><br><span class="line">面向对象分析方法</span><br><span class="line">面向问题域的分析</span><br></pre></td></tr></table></figure><h1 id="二、如何进行系统设计"><a href="#二、如何进行系统设计" class="headerlink" title="二、如何进行系统设计"></a>二、如何进行系统设计</h1><p>系统设计与其说是在设计，不如说是在选择和妥协。<br>妥协，就是在各个系统目标之间找到一个平衡点。系统目标包括但不限于功能、性能、健壮性、开发周期、交付日期等，但这些目标往往都是矛盾的。<br>没有一个设计者会完全重新开始设计一个系统，他们总参考多个与目标系统相类似的系统，再从中进行甄别、取舍和补充来作为新系统的设计。<br>要成为优秀的设计者，了解、掌握、消化、总结前人和自己以前的设计成果是最好的、也是唯一的方法。</p><p>优秀的系统设计一般在以下几个方面都很出色：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">组建的独立性。做到高内聚、低耦合。</span><br><span class="line">例外的识别和处理。</span><br><span class="line">防错和容错。</span><br></pre></td></tr></table></figure><p>也有一些技术能够改进系统设计，这些方法包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">降低复杂性</span><br><span class="line">通过合约进行设计</span><br><span class="line">原型化设计</span><br><span class="line">错误树分析等</span><br></pre></td></tr></table></figure><h1 id="三、软件设计的任务与活动"><a href="#三、软件设计的任务与活动" class="headerlink" title="三、软件设计的任务与活动"></a>三、软件设计的任务与活动</h1><p>软件设计时把软件需求变成软件表示的过程。<br>软件表示先是总体框架，然后在进一步细化，并在框架中填入细节。<br>1、从工程管理角度，软件设计可以分为两个步骤：<br>（1）概要设计：也称为高层设计<br>将软件需求转化为数据结构和软件的系统结构。<br>（2）详细设计：也称为底层设计<br>对结构表示进行细化，得到详细的数据结构与算法。<br>2、主要的设计方法比较<br>结构化设计的时代，主要设计方法包括Jackson方法和Parnas方法。结构化方法侧重于“模块相对独立且功能单一，使模块间联系弱、模块内联系强”；<br>Jackson方法是从数据结构导出模块结构。<br>Parnas方法是将可能引起变化的因素隐藏在有关模块内部，是这些因素变化时的影响范围受到限制。<br>近年来，对象技术凭借数据的高效封装和良好的消息机制，实现了高内聚、低耦合，成为现代软件设计的主流方法。</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-系统分析与设计方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发方法（五）软件重用</title>
      <link href="/2021/09/17/%E8%BD%AF%E8%80%83/6%E3%80%81%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E8%BD%AF%E4%BB%B6%E9%87%8D%E7%94%A8/"/>
      <url>/2021/09/17/%E8%BD%AF%E8%80%83/6%E3%80%81%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E8%BD%AF%E4%BB%B6%E9%87%8D%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>软件重用是一种重要的开发方法，虽然还不成熟，但现在已经有一些重用技术（中间件、应用服务器）改变了开发过程。</p><h1 id="软件重用"><a href="#软件重用" class="headerlink" title="软件重用"></a>软件重用</h1><p>软件产品是抽象的，可以无限复制的，因此重复利用可以节约人力物力，提高开发效率、降低成本、缩短开发周期、提高软件质量。<br>软件重用可以是软件产品、源程序、文档、设计思想甚至是领域知识。</p><p>常见的软件重用形式包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">源代码重用</span><br><span class="line">架构重用</span><br><span class="line">应用框架重用</span><br><span class="line">业务建模重用</span><br><span class="line">文件及过程重用</span><br><span class="line">软构件重用</span><br><span class="line">软件服务重用</span><br></pre></td></tr></table></figure><h1 id="构件技术"><a href="#构件技术" class="headerlink" title="构件技术"></a>构件技术</h1><p>构件又称为组件，是自包容、可复用的程序集。构件整体向外提供统一的访问接口，外部只能访问接口，不能直接操作构件内部。</p><p>自包容是指构件本身是一个功能完整地独立体，构建内部与外部界限明确，可独立配置和使用。</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-开发方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发方法（六）软件设计方法</title>
      <link href="/2021/09/17/%E8%BD%AF%E8%80%83/6%E3%80%81%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/"/>
      <url>/2021/09/17/%E8%BD%AF%E8%80%83/6%E3%80%81%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="基于架构的软件设计ABSD"><a href="#基于架构的软件设计ABSD" class="headerlink" title="基于架构的软件设计ABSD"></a>基于架构的软件设计ABSD</h1><p>三个基础</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">功能分解，ABSD使用已有的基于模块的内聚和耦合技术。</span><br><span class="line">通过选择架构风格来实现质量和业务需求。</span><br><span class="line">软件模板的使用</span><br></pre></td></tr></table></figure><p><img src="/images/ruankao/3-5.png"><br>ABSD方法的输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">抽象功能需求：对功能需求进行抽象，在获取需求的时候，需要考虑到所有最终用户。</span><br><span class="line">用例：用例是对功能需求的具体化。在架构设计阶段，对用例进行分组，设置优先级，重要的用例才有用。</span><br><span class="line">抽象的质量和业务需求：</span><br><span class="line">架构选项：对于每个质量和业务需求，我们都要列举能够满足该需求的所有可能得架构。</span><br><span class="line">质量场景：质量场景是质量需求的具体化。同样，需要对质量场景进行分组、设置优先级，验证最重要的质量场景。</span><br><span class="line">约束：</span><br></pre></td></tr></table></figure><h1 id="基于架构的软件开发模型ABSDM"><a href="#基于架构的软件开发模型ABSDM" class="headerlink" title="基于架构的软件开发模型ABSDM"></a>基于架构的软件开发模型ABSDM</h1><p>ABSDM把基于架构的软件过程划分为架构需求、架构设计、架构文档化、架构复审、架构实现、架构演化等六个子过程。<br><img src="/images/ruankao/3-6.png"></p><h2 id="一、架构需求"><a href="#一、架构需求" class="headerlink" title="一、架构需求"></a>一、架构需求</h2><p>需求是用户对软件系统在功能、行为、性能、设计约束等方面的期望，架构需求受技术环境和架构设计师的惊艳影像。<br><img src="/images/ruankao/3-7.png"></p><h3 id="获取需求"><a href="#获取需求" class="headerlink" title="获取需求"></a>获取需求</h3><p>架构需求一般来自于 系统的质量目标、系统的业务目标、系统开发人员的业务目标。获取架构需求的目的是为了让开发出来的软件能够满足用户业务上的功能需求。</p><h3 id="标识构件"><a href="#标识构件" class="headerlink" title="标识构件"></a>标识构件</h3><p>标识构件的目的是为了生成系统的初始逻辑结构。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">生成类图</span><br><span class="line">对类进行分组</span><br><span class="line">把类打包成构件</span><br></pre></td></tr></table></figure><h3 id="需求评审"><a href="#需求评审" class="headerlink" title="需求评审"></a>需求评审</h3><p>评审的主要内容是需求是否是真实需求、类的分组是否合理、构件是否合理。</p><h2 id="二、架构设计"><a href="#二、架构设计" class="headerlink" title="二、架构设计"></a>二、架构设计</h2><p>架构设计是一个迭代的过程。<br><img src="/images/ruankao/3-8.png"></p><h3 id="提出架构模型"><a href="#提出架构模型" class="headerlink" title="提出架构模型"></a>提出架构模型</h3><p>在架构初期，最重要的是确定架构风格，即使这个模型是理想化的，但该模型为将来实现和演化过程建立了目标。</p><h3 id="把已标识的构建映射到软件架构中"><a href="#把已标识的构建映射到软件架构中" class="headerlink" title="把已标识的构建映射到软件架构中"></a>把已标识的构建映射到软件架构中</h3><h3 id="分析构件之间的相互作用"><a href="#分析构件之间的相互作用" class="headerlink" title="分析构件之间的相互作用"></a>分析构件之间的相互作用</h3><h3 id="产生软件架构"><a href="#产生软件架构" class="headerlink" title="产生软件架构"></a>产生软件架构</h3><h3 id="设计评审"><a href="#设计评审" class="headerlink" title="设计评审"></a>设计评审</h3><h2 id="三、架构文档化"><a href="#三、架构文档化" class="headerlink" title="三、架构文档化"></a>三、架构文档化</h2><p>大多数架构都是抽象的，是由一些概念上的构件组成。<br>文档是在系统演化的每一个阶段、系统设计和开发人员的通信媒介，视为验证架构设计和提炼或修改这些设计的基础。<br>架构文档化的主要输出结果是《架构需求规格说明书》和《测试架构需求的质量设计说明书》两个文档。</p><h2 id="四、架构复审"><a href="#四、架构复审" class="headerlink" title="四、架构复审"></a>四、架构复审</h2><p>目的是标识潜在风险，及早发现架构设计中的缺陷和错误。包括架构是否满足需求、质量需求是否在设计中得到体现、层次是否清晰、构建划分是否合理、文档表达是否明确、goUI结案设计师够满足功能和性能的需求等。</p><h2 id="五、架构实现"><a href="#五、架构实现" class="headerlink" title="五、架构实现"></a>五、架构实现</h2><p><img src="/images/ruankao/3-9.png"></p><h2 id="六、架构演化"><a href="#六、架构演化" class="headerlink" title="六、架构演化"></a>六、架构演化</h2><p>由于最终用户的需求可能变化、移植时需求产生变化等情况，就必须对架构进行修改，以适应新的软件需求。<br><img src="/images/ruankao/3-10.png"></p><h3 id="需求变化归类"><a href="#需求变化归类" class="headerlink" title="需求变化归类"></a>需求变化归类</h3><p>让变化的需求与已有构建对应，对应不到的变动，做好记录，在后续创建新的构件应该这部分变化的需求</p><h3 id="架构演化计划"><a href="#架构演化计划" class="headerlink" title="架构演化计划"></a>架构演化计划</h3><p>在改变原有架构之前，必须制定一个周密的架构演化计划，为后续演化开发工作做指南。</p><h3 id="构件变动"><a href="#构件变动" class="headerlink" title="构件变动"></a>构件变动</h3><p>在演化计划的基础上新增、修改或者删除构件，根据需求变化归类决定对构件新增修改或删除。最后对构件进行功能性测试。</p><h3 id="更新构件的相互作用"><a href="#更新构件的相互作用" class="headerlink" title="更新构件的相互作用"></a>更新构件的相互作用</h3><p>更新构建之间的控制流程</p><h3 id="构建组装与测试"><a href="#构建组装与测试" class="headerlink" title="构建组装与测试"></a>构建组装与测试</h3><p>通过工具把构建的实现体组装起来，完成真个软件系统的连接与合成。最后进行整体功能和性能测试。</p><h3 id="技术评审"><a href="#技术评审" class="headerlink" title="技术评审"></a>技术评审</h3><p>评审是否符合用户需求，如果不符合，则在2-6步进行迭代。</p><h3 id="演化后的架构"><a href="#演化后的架构" class="headerlink" title="演化后的架构"></a>演化后的架构</h3><p>将演化后的架构在原来系统上所做的所有修改必须集成到原来的架构中，完成一次演化过程。</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-开发方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统规划（一）项目提出与选择</title>
      <link href="/2021/09/17/%E8%BD%AF%E8%80%83/7%E3%80%81%E7%B3%BB%E7%BB%9F%E8%A7%84%E5%88%92/%E7%B3%BB%E7%BB%9F%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89%E9%A1%B9%E7%9B%AE%E6%8F%90%E5%87%BA%E4%B8%8E%E9%80%89%E6%8B%A9/"/>
      <url>/2021/09/17/%E8%BD%AF%E8%80%83/7%E3%80%81%E7%B3%BB%E7%BB%9F%E8%A7%84%E5%88%92/%E7%B3%BB%E7%BB%9F%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89%E9%A1%B9%E7%9B%AE%E6%8F%90%E5%87%BA%E4%B8%8E%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<p>系统规划主要记录从项目提出、选择到确立的过程。包括系统项目的提出与可行性分析，系统方案的制定、评价和改进，新旧系统的分析和比较，以及现有软件、硬件和数据资源的有效利用等问题。</p><h1 id="一、项目的提出与选择"><a href="#一、项目的提出与选择" class="headerlink" title="一、项目的提出与选择"></a>一、项目的提出与选择</h1><p>根据项目的动机确定系统的范围及方案选择。</p><h2 id="1、系统的立项目标和动机"><a href="#1、系统的立项目标和动机" class="headerlink" title="1、系统的立项目标和动机"></a>1、系统的立项目标和动机</h2><p>项目立项的动机包括</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">进行基础研究并获取技术：大学、企业、研究所等科研类</span><br><span class="line">进行应用研发并获得产品：产品研发，卖产品获利</span><br><span class="line">提供技术服务：卖服务获利</span><br><span class="line">信息技术产品的使用者：买软件或者产品使用</span><br></pre></td></tr></table></figure><h2 id="2、项目选择和确定"><a href="#2、项目选择和确定" class="headerlink" title="2、项目选择和确定"></a>2、项目选择和确定</h2><p>项目选择的目的可能有两种。<br>1是软件开发公司在诸多产品方向中选择格式的方向研究和开发。<br>2是客户从诸多的产品中购买适合自己的产品或方案。</p><h3 id="（1）选择有核心价值的产品-项目或开发方向"><a href="#（1）选择有核心价值的产品-项目或开发方向" class="headerlink" title="（1）选择有核心价值的产品/项目或开发方向"></a>（1）选择有核心价值的产品/项目或开发方向</h3><p>关键在于确定什么样的系统项目是有价值的。价值通常与核心业务有关系，立项单位所在的行业或上下游位置不同，价值判断也不同。</p><h3 id="（2）评估项目风险、收益和代价"><a href="#（2）评估项目风险、收益和代价" class="headerlink" title="（2）评估项目风险、收益和代价"></a>（2）评估项目风险、收益和代价</h3><p>1、对于开发产品进行销售<br>主要评估产品期望收益和开发投入的时间、资金、人力等资源。项目的风险主要是技术难度、技术能力、经济能力、开发进度、法律风险、政策风险。<br>2、对于购买产品或技术服务<br>需要评估项目实施后的变更情况，组织机构和人员职责的影响，现有流程和人员能否满足要去，规章制度是否满足要求等。</p><h3 id="（3）评估项目的多种实施方式"><a href="#（3）评估项目的多种实施方式" class="headerlink" title="（3）评估项目的多种实施方式"></a>（3）评估项目的多种实施方式</h3><h3 id="（4）平衡地选择合适的方案"><a href="#（4）平衡地选择合适的方案" class="headerlink" title="（4）平衡地选择合适的方案"></a>（4）平衡地选择合适的方案</h3><p>1、新技术与就技术</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新技术意味着风险、学习和导入期。</span><br><span class="line">旧技术享受不了新技术的好处。</span><br></pre></td></tr></table></figure><p>2、快速开发平台</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基于某平台的产品会让用户绑定在该平台上，减少未来自主选择性。</span><br><span class="line">不基于某平台可能会延长项目开发时间，从而导致更多开销。</span><br></pre></td></tr></table></figure><p>3、系统扩展性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不考虑系统扩展性很可能在业务变更时受阻。</span><br><span class="line">过多考虑系统扩展性会花费大量时间进行设计。在IT发展迅速的今天，很有可能在有升级的时候，原来的技术体系已被淘汰。</span><br></pre></td></tr></table></figure><p>4、抛弃明显存在问题的“差”项目，选择基本立场“合适”的项目，而不是尽可能的“好”。<br><img src="/images/ruankao/4-1.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">要求质量是客户认为产品应该具备的功能或性能，实现越多客户越满意。</span><br><span class="line">假想质量是客户想当然认为产品应具备的功能或性能，客户不能正确描述自己想当然要得到的这些功能或性能需求。</span><br><span class="line">兴奋质量是客户要求范围外的功能或性能，通常是开发者很愿意增加的技术特性，实现这些客户会更高兴，但是不识闲也不影响其购买。</span><br><span class="line"></span><br><span class="line">系统设计师常犯的错误是用自己对技术产生的兴奋质量，替换客户最基本的要求质量或假想质量。</span><br><span class="line">企业经营者场贩的错误可能是对客户提出的合理要求质量视而不见，或者不加区分的把未经评估的假想质量指派给开发团队。</span><br></pre></td></tr></table></figure><h2 id="2、项目提出和选择的结果"><a href="#2、项目提出和选择的结果" class="headerlink" title="2、项目提出和选择的结果"></a>2、项目提出和选择的结果</h2><p>项目提出和选择的结果最终会以“产品/项目建议书”的方式体现。典型的应用场景是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在投标项目中，建议书通常是乙方提交给甲方竞标方案的一部分。</span><br><span class="line">在企业确立要开发某产品后，对该产品进行多角度评估，最终项目立项人向上级提交建议书进行决策。</span><br></pre></td></tr></table></figure><p>产品/项目建议书包括以下几部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">用户单位、项目或产品的立项背景、需求来源和目标性的介绍；</span><br><span class="line">用户的内外部环境、组织机构、现有的IT设施情况等；</span><br><span class="line">用户的业务模型和业务规划；</span><br><span class="line">预期要建设的技术系统在用户业务中的位置和作用；</span><br><span class="line">信息化后的用户业务模型、软件应用方式、相关的部署环境、运行规划、管理规范等；</span><br><span class="line">为实现信息化业务模型，技术系统的产品需求鼎业（功能、性能、约束）和部署方式等；</span><br><span class="line">产品或项目的技术框架；</span><br><span class="line">项目的要点、技术难点、主要实施障碍等。</span><br><span class="line">项目或产品的可行性研究结果；</span><br><span class="line">项目可选择的试试方式、组织方式、沟通和协调机制等；</span><br><span class="line">项目的资源范围和规划，人、财、物、时间等；</span><br><span class="line">项目的成本、收益分析；</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>其他项目建议书可能包含的内容或已单独文档列举的内容包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">项目风险及影响评估</span><br><span class="line">项目进度计划</span><br><span class="line">项目质量计划</span><br><span class="line">项目过渡期资金的获得方式、财务计划</span><br><span class="line">产品或项目的商务模式、盈利模式论述</span><br><span class="line">同类产品或公司的市场调查结果，以及竞争性比较</span><br><span class="line">企业成功案例、资质等</span><br><span class="line">商务条款或供应商、客户合同。</span><br></pre></td></tr></table></figure><p>项目建议书标志着项目立项和选择阶段性工作的完成，一旦项目建议书被批准通过，项目可进入正式的开发准备和实施阶段。</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-系统规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统规划（三）方案的制定和改进</title>
      <link href="/2021/09/17/%E8%BD%AF%E8%80%83/7%E3%80%81%E7%B3%BB%E7%BB%9F%E8%A7%84%E5%88%92/%E7%B3%BB%E7%BB%9F%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%89%EF%BC%89%E6%96%B9%E6%A1%88%E7%9A%84%E5%88%B6%E5%AE%9A%E5%92%8C%E6%94%B9%E8%BF%9B/"/>
      <url>/2021/09/17/%E8%BD%AF%E8%80%83/7%E3%80%81%E7%B3%BB%E7%BB%9F%E8%A7%84%E5%88%92/%E7%B3%BB%E7%BB%9F%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%89%EF%BC%89%E6%96%B9%E6%A1%88%E7%9A%84%E5%88%B6%E5%AE%9A%E5%92%8C%E6%94%B9%E8%BF%9B/</url>
      
        <content type="html"><![CDATA[<p>主要完成的工作是解析“系统如何实现”的问题。<br>主要包括一下几个方面。</p><h2 id="1、确定软件架构"><a href="#1、确定软件架构" class="headerlink" title="1、确定软件架构"></a>1、确定软件架构</h2><p>1、分析模型的结构。<br>2、对应于系统目标的最基本。最重要的实现要素。<br>3、特性和要点的解释。</p><h2 id="2、确定实现的各种关键性要素"><a href="#2、确定实现的各种关键性要素" class="headerlink" title="2、确定实现的各种关键性要素"></a>2、确定实现的各种关键性要素</h2><p>1、关键的用例、主要的控制类、功能和服务的首要组织方式<br>2、对象的组织模式<br>3、常用和最关键的实现算法模型。<br>4.选定开发工具和开发环境</p><h2 id="3、归结目标到最适合的计算体系"><a href="#3、归结目标到最适合的计算体系" class="headerlink" title="3、归结目标到最适合的计算体系"></a>3、归结目标到最适合的计算体系</h2><p>1、表示层：用户的界面部分<br>2、事务逻辑层：负责处理表示层的应用请求，完成商务逻辑的计算任务并肩结果返回用户。<br>3、数据服务层：为应用提供数据来源。</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-系统规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统规划（二）可行性研究</title>
      <link href="/2021/09/17/%E8%BD%AF%E8%80%83/7%E3%80%81%E7%B3%BB%E7%BB%9F%E8%A7%84%E5%88%92/%E7%B3%BB%E7%BB%9F%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%AF%E8%A1%8C%E6%80%A7%E7%A0%94%E7%A9%B6/"/>
      <url>/2021/09/17/%E8%BD%AF%E8%80%83/7%E3%80%81%E7%B3%BB%E7%BB%9F%E8%A7%84%E5%88%92/%E7%B3%BB%E7%BB%9F%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%AF%E8%A1%8C%E6%80%A7%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<p>可行性研究的范围包括技术、经济、执行、环境等方面。虽然可行性研究不能给出详细的计划和方向，但是可以以最小的成本识别出错误构思的系统，从而避免更大的损失。</p><h1 id="一、可行性研究的内容"><a href="#一、可行性研究的内容" class="headerlink" title="一、可行性研究的内容"></a>一、可行性研究的内容</h1><p>可行性研究包括经济可行性、技术可行性、法律可行性、执行可行性、方案的选择等5个方面。</p><h2 id="经济可行性"><a href="#经济可行性" class="headerlink" title="经济可行性"></a>经济可行性</h2><p>评估项目的开发成本及项目成功后可能获得的经济收益。</p><h2 id="技术可行性"><a href="#技术可行性" class="headerlink" title="技术可行性"></a>技术可行性</h2><p>评估对于假想的软件系统需要实现的功能和性能，以及技术能力约束。可通过“提问-回答”的方式进行论证。<br>投资不足、时间不足、技术难度过大、没有足够的技术积累、没有熟练的员工、没有足够的合作公司、晚报资源不足等都是技术可行性的约束。</p><h2 id="法律可行性"><a href="#法律可行性" class="headerlink" title="法律可行性"></a>法律可行性</h2><p>评估可能有系统开发引起的侵权或法律责任。<br>可能包括过年政策和法律的限制，合同的订立和条款，职责、侵权情况的设定，违约、争议的解决等。</p><h2 id="执行可行性"><a href="#执行可行性" class="headerlink" title="执行可行性"></a>执行可行性</h2><p>评估与其的软件系统在真实的环境中能够被应用的程度和实施过程中的障碍。</p><h2 id="方案的选择"><a href="#方案的选择" class="headerlink" title="方案的选择"></a>方案的选择</h2><p>评估系统或者产品开发的可选方法，可以采用折中的方法，反复比较各个方案的成本和效益，选择可行的方案。</p><h1 id="二、成本效益分析"><a href="#二、成本效益分析" class="headerlink" title="二、成本效益分析"></a>二、成本效益分析</h1><p>对项目开发目标的成本及可度量的项目现金收入和无形收益进行一次转化的评估。</p><h2 id="项目可能涉及的成本"><a href="#项目可能涉及的成本" class="headerlink" title="项目可能涉及的成本"></a>项目可能涉及的成本</h2><p>基础建设支出<br>一次性支出<br>运行维护费用</p><h2 id="项目可能涉及的利益"><a href="#项目可能涉及的利益" class="headerlink" title="项目可能涉及的利益"></a>项目可能涉及的利益</h2><p>一次性收益<br>非一次性收益<br>不可定量的收益</p><h2 id="效益分析的若干指标和进一步的分析"><a href="#效益分析的若干指标和进一步的分析" class="headerlink" title="效益分析的若干指标和进一步的分析"></a>效益分析的若干指标和进一步的分析</h2><p>收益/投资比<br>投资回收周期<br>敏感性分析</p><h1 id="三、可行性分析报告"><a href="#三、可行性分析报告" class="headerlink" title="三、可行性分析报告"></a>三、可行性分析报告</h1><p>国标 GB 8567-1988 中定义了可行性分析报告的格式和内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">项目背景：包括问题描述、实现环境和限制条件</span><br><span class="line">管理概要和建议：包括重要的研究成果、说明、建议和影响</span><br><span class="line">候选方案：包括候选系统的配置和最终方案的选择标准</span><br><span class="line">系统描述：包括系统工作范围的简要说明和被分配系统元素的可行性</span><br><span class="line">经济可行性：包括经费概算和与其的经济效益</span><br><span class="line">技术可行性：包括技术实力、已有工作基础和设备条件</span><br><span class="line">法律可行性：包括系统开发可能导致的侵权，违法和责任等</span><br><span class="line">用户使用可行性：包括用户单位的行政管理，工作制度和使用人员的素质</span><br><span class="line">其他与项目有关的问题：例如其他方案接收和未来可能的变化</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-系统规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统规划（四）新旧系统的分析和比较</title>
      <link href="/2021/09/17/%E8%BD%AF%E8%80%83/7%E3%80%81%E7%B3%BB%E7%BB%9F%E8%A7%84%E5%88%92/%E7%B3%BB%E7%BB%9F%E8%A7%84%E5%88%92%EF%BC%88%E5%9B%9B%EF%BC%89%E6%96%B0%E6%97%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E6%AF%94%E8%BE%83/"/>
      <url>/2021/09/17/%E8%BD%AF%E8%80%83/7%E3%80%81%E7%B3%BB%E7%BB%9F%E8%A7%84%E5%88%92/%E7%B3%BB%E7%BB%9F%E8%A7%84%E5%88%92%EF%BC%88%E5%9B%9B%EF%BC%89%E6%96%B0%E6%97%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<p>遗留系统的特点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">系统虽然能完成很多重要的业务工作，但是已经不能外圈满足要求。</span><br><span class="line">系统在性能上已经落后，或者采用的技术已经过时。</span><br><span class="line">通常是大型的系统，已经融入业务工作中，维护工作十分困难。</span><br><span class="line">系统没有使用现代系统工程方法进行管理和开发，基本没有文档，很难理解。</span><br></pre></td></tr></table></figure><p>对于遗留系统，可以根据系统的技术条件、商业价值及维护和运行系统的组织特征不同，采取继续维护、重构或替代、或联合使用几种策略。</p><h1 id="一、遗留系统的评价方法"><a href="#一、遗留系统的评价方法" class="headerlink" title="一、遗留系统的评价方法"></a>一、遗留系统的评价方法</h1><p><img src="/images/ruankao/4-2.png"><br>1、启动评价<br>评价是为了对遗留系统足够的理解。评价前需要了解以下问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">对企业来说，遗留系统是否至关重要</span><br><span class="line">企业的商业目标是什么</span><br><span class="line">演化需求是什么</span><br><span class="line">所期望的系统寿命多长</span><br><span class="line">系统的使用期限多久</span><br><span class="line">系统的技术状态如何</span><br><span class="line">企业是否愿意改变</span><br><span class="line">企业是否有能力承受演化</span><br></pre></td></tr></table></figure><p>2、商业价值评价<br>判断遗留系统对企业的重要性。可以包括概要和详细两个级别，概要评价包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">咨询</span><br><span class="line">评价问卷</span><br><span class="line">进行评价</span><br></pre></td></tr></table></figure><p>详细评价包括应用系统不符合业务规范的风险分析，该分析十分费时，最好由业务分析师来完成。<br>3、外部环境评价<br>外部环境评价系统的外部技术环境，是硬件、支撑软件和其他基础设施的统一体。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">硬件</span><br><span class="line">    系统一些常见特征有供应商、维护费用、市销率、年龄、功能、性能等。</span><br><span class="line">    具体评价方法是对每一个部件或整个系统的每个特征打分（1-4），求总分。</span><br><span class="line">支撑软件</span><br><span class="line">    支撑软件可包括操作系统、数据库、事务处理程序、编译器、网络软件、应用软件等。</span><br><span class="line">    评价方式同硬件。</span><br><span class="line">企业基础设施</span><br><span class="line">    需要考虑企业和使用者的类型、开发组织的技术成熟度、企业的培训过程、系统支持人员的技术水平、企业是否愿意改变。</span><br></pre></td></tr></table></figure><p>4、应用软件评价</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">系统级，整个系统看作不可分的原子。</span><br><span class="line">部件级，关注系统的每个子系统，考虑子系统的特征，包括复杂性、数据、文档、外部依赖型、合法性、维护记录、大小、安全性等。</span><br><span class="line">评价方式同硬件。</span><br></pre></td></tr></table></figure><p>5、分析评价结果<br>加权平均值。</p><p><img src="/images/ruankao/4-3.png"></p><h1 id="二、遗留系统的演化策略"><a href="#二、遗留系统的演化策略" class="headerlink" title="二、遗留系统的演化策略"></a>二、遗留系统的演化策略</h1><p>1、淘汰策略<br>第3象限低水平、低价值区，淘汰，全面开发新的系统替代遗留系统。<br>一般在业务发生根本变化，或维护人员、维护资料全部丢失了。经过评价，重新开发比改造旧系统更划算。<br>2、继承策略<br>第4象限低水平、高价值区，遗留，在开发系统时需要完全兼容遗留系统的功能模型和数据模型，新老系统同时运行，逐渐切换到新系统。<br>3、改造策略<br>第1象限高水平、高价值区，改造，这种系统通常建成时间段。其他功能不变，增加新功能。<br>4、集成策略<br>第2象限高水平、低价值区，集成，这种系统可能只完成某部门或子公司的业务，从整体看，他们基于不同的平台，不同的数据模型，无法互联互通，数据还不一致，属于较严重的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-系统规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>干啊，软考之路</title>
      <link href="/2021/09/16/%E8%BD%AF%E8%80%83/start/"/>
      <url>/2021/09/16/%E8%BD%AF%E8%80%83/start/</url>
      
        <content type="html"><![CDATA[<p>干啊，软考之路，记录些比较有价值的知识点吧。</p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发方法（一）软件生命周期</title>
      <link href="/2021/09/16/%E8%BD%AF%E8%80%83/6%E3%80%81%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2021/09/16/%E8%BD%AF%E8%80%83/6%E3%80%81%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="1970年-Boehm定义的软件生命周期模型"><a href="#1970年-Boehm定义的软件生命周期模型" class="headerlink" title="1970年 Boehm定义的软件生命周期模型"></a>1970年 Boehm定义的软件生命周期模型</h1><p><img src="/images/ruankao/1-6.png"></p><h1 id="《GB-8566-1988计算机软件开发规范》定义的软件生命周期模型"><a href="#《GB-8566-1988计算机软件开发规范》定义的软件生命周期模型" class="headerlink" title="《GB 8566-1988计算机软件开发规范》定义的软件生命周期模型"></a>《GB 8566-1988计算机软件开发规范》定义的软件生命周期模型</h1><p><img src="/images/ruankao/1-7.png"></p><table><thead><tr><th>阶段</th><th>说明</th></tr></thead><tbody><tr><td>可行性研究与计划</td><td>初步确定软件的目标、范围、风险、成本，从而确定软件是否有开发的必要。输出《可行性研究报告》《软件开发计划》</td></tr><tr><td>需求分析</td><td>对软件的需求进行详细分析</td></tr><tr><td>概要设计</td><td>确定软件的技术蓝图，将需求分析结果转为技术设计方案，输出系统架构、子系统之间的关系、数据库模型、接口规范、编码规范</td></tr><tr><td>详细设计</td><td>在概要设计的基础上进行细化，可裁剪，在一些小项目或者结构简单的项目可以没有详设，或者对重要模块进行详设</td></tr><tr><td>实现</td><td>包括编码和单元测试</td></tr><tr><td>集成测试</td><td>-</td></tr><tr><td>确认测试</td><td>验证软件实现与需求是否一致，是否达到了预期目标</td></tr><tr><td>使用和维护</td><td>软件维护的过程会贯穿整个软件的使用过程。当使用和维护阶段结 束后，软件系统也就自然消亡，软件系统的生命周期结束。</td></tr></tbody></table><h1 id="《GB-T-8566-1995-信息技术-软件生存期过程》定义的软件生命周期模型"><a href="#《GB-T-8566-1995-信息技术-软件生存期过程》定义的软件生命周期模型" class="headerlink" title="《GB/T 8566-1995 信息技术-软件生存期过程》定义的软件生命周期模型"></a>《GB/T 8566-1995 信息技术-软件生存期过程》定义的软件生命周期模型</h1><p><img src="/images/ruankao/1-8.png"></p><h1 id="1999年-《统一软件开发过程》"><a href="#1999年-《统一软件开发过程》" class="headerlink" title="1999年 《统一软件开发过程》"></a>1999年 《统一软件开发过程》</h1><p>包括4个阶段和5种工作流<br><img src="/images/ruankao/1-9.png"></p><h3 id="五种工作流"><a href="#五种工作流" class="headerlink" title="五种工作流"></a>五种工作流</h3><p><img src="/images/ruankao/1-10.png"></p>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-开发方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发方法（三）统一过程UP</title>
      <link href="/2021/09/16/%E8%BD%AF%E8%80%83/6%E3%80%81%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%9F%E4%B8%80%E8%BF%87%E7%A8%8BUP/"/>
      <url>/2021/09/16/%E8%BD%AF%E8%80%83/6%E3%80%81%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%9F%E4%B8%80%E8%BF%87%E7%A8%8BUP/</url>
      
        <content type="html"><![CDATA[<p>UP是一个统一的软件开发过程，可以用于各种类型的项目。UP是基于构件的，使用统一建模语言（UML）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">特点：</span><br><span class="line">用例驱动</span><br><span class="line">以基本架构为中心</span><br><span class="line">迭代和增量</span><br></pre></td></tr></table></figure><p><img src="/images/ruankao/3-1.png"><br><img src="/images/ruankao/3-2.png"></p><p>初始阶段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">明确项目规模。了解核心需求及约束，以确定验收标准。</span><br><span class="line">计划和准备商业理由。评估风险管理、人员配备、项目计划、成本、进度、收益率折中的备选方案。</span><br><span class="line">综合考虑备选架构。评估设计和自制、外购、复用方面的折中，从而估算成本、进度和资源。</span><br><span class="line">准备项目的环境，评估项目和组织，选择工具，决定流程中要改进的部分。</span><br></pre></td></tr></table></figure><p>细化阶段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">快速确定架构。</span><br><span class="line">进一步明确需求，充分了解对推动架构和计划决策的最关键的用例。</span><br><span class="line">创建详细的迭代计划，并建立基线。</span><br><span class="line">优化开发流程，确定构建和自动化工具。</span><br><span class="line">优化架构，并选择构件。自制、外购或者复用。</span><br></pre></td></tr></table></figure><p>构建阶段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">资源管理、控制和流程优化。</span><br><span class="line">完成构件开发，并根据已定义的评估标准进行测试。</span><br><span class="line">根据验收标准对产品进行评估。</span><br></pre></td></tr></table></figure><p>交付阶段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">执行部署计划</span><br><span class="line">完成用户手册</span><br><span class="line">确认测试</span><br><span class="line">打包发布</span><br><span class="line">获得用户反馈</span><br><span class="line">基于反馈调整产品</span><br><span class="line">最终版上线</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-开发方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发方法（二）软件开发模型</title>
      <link href="/2021/09/16/%E8%BD%AF%E8%80%83/6%E3%80%81%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/"/>
      <url>/2021/09/16/%E8%BD%AF%E8%80%83/6%E3%80%81%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h1><p>瀑布模型严格遵守软件生命周期各阶段的固定顺序，上一阶段完成后才能进入下一阶段，整个模型就像一个飞流直下的瀑布。<br><img src="/images/ruankao/2-1.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line">可强迫开发人员采用规范的方法</span><br><span class="line">严格规定了各阶段必须提交的文档</span><br><span class="line">要求每个阶段结束后，都要进行严格评审</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">过于理想化</span><br><span class="line">缺乏灵活性</span><br><span class="line">无法再开发过程中逐步明确用户无法表达准确的需求</span><br></pre></td></tr></table></figure><h1 id="瀑布V模型"><a href="#瀑布V模型" class="headerlink" title="瀑布V模型"></a>瀑布V模型</h1><p>瀑布V模型是瀑布模型的一种变体。在开发过程中任一阶段都可能引入缺陷，最后的测试只能在交付前发现更多的缺陷。瀑布V模型强调了测试。<br><img src="/images/ruankao/2-2.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line">瀑布V模型不但保证了瀑布模型的阶段式文档驱动的特点，更强调了软件产品的验证工作</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">需求分析集中在项目开始，而一旦需求不准确，存在偏差，之后的设计、实现、验证会放大偏差。</span><br><span class="line">瀑布模型后期维护工作相当繁重，而这些维护工作大都是修正需求阶段引入的缺陷，这个问题是瀑布模型难以克服的。</span><br></pre></td></tr></table></figure><h1 id="快速原型模型"><a href="#快速原型模型" class="headerlink" title="快速原型模型"></a>快速原型模型</h1><p>快速原型是指在计算机上快速建立可以运行的程序或者界面。让用户能尽快了解系统的概貌，一旦用户确认了原型，就可以快速按照原型开发出满足用户真实需求的软件产品。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">特点：</span><br><span class="line">引入了迭代的概念</span><br><span class="line">强调用户参与</span><br><span class="line">在用户需求分析、系统功能描述、系统实现方法等方面允许有较大的灵活性，可以逐步完善。</span><br><span class="line">可以用来评价几种不同的设计方案</span><br><span class="line">可以用来建立系统的某个部分</span><br><span class="line">不排斥传统生命周期的有效的方法和工具，与传统方法互为补充。</span><br><span class="line"></span><br><span class="line">动态定义需求，适用于需求不明确的项目。</span><br><span class="line"></span><br><span class="line">不适合使用原型法的情况：</span><br><span class="line">缺乏使用的原型开发工具</span><br><span class="line">用户不参与、不积极配合开发过程</span><br><span class="line">用户的数据资源缺乏组织和管理</span><br><span class="line">用户的软件资源缺乏组织和管理</span><br></pre></td></tr></table></figure><h1 id="演化模型"><a href="#演化模型" class="headerlink" title="演化模型"></a>演化模型</h1><p>演化模型也是一种原型化的开发方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">快速原型模型中，原型的用途是获取用户的真实需求，一旦需求确定了，原型就被抛弃，是一种“抛弃式”的原型化方法。</span><br><span class="line">演化模型中，则是从初始模型逐步演化为最终软件产品的渐进过程，是一种“渐进式”的原型化方法。</span><br><span class="line">一个演化模型可以看做若干次瀑布模型的迭代。</span><br></pre></td></tr></table></figure><h1 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h1><p>增量模型是第三种原型化开发方法，它既不是“抛弃式”的，也不是“渐进式”的，而是“递增式”的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在系统的技术架构成熟、风险较低的时候，可以采用增量的方式进行系统开发，</span><br><span class="line">这样可以提前进行集成测试和系统测试，缩短初始版本的发布周期，提高用户对系统的可见度，降低系统的风险。</span><br><span class="line">第一版本往往是系统的核心功能，可以满足用户最基本的需求。之后增量版本的功能逐步丰富、完善。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">每一个版本都是一个完整的、可用的版本</span><br><span class="line">版本间的增量要均匀</span><br></pre></td></tr></table></figure><h1 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h1><p>螺旋模型结合了瀑布模型和演化模型的有点，不仅体现了两个模型的优点，而且还强调了其他模型均忽略了的风险分析。<br>螺旋模型在“瀑布模型”的每一个开发阶段前，引入一个非常严格的风险识别、风险分析和风险控制。它把软件项目分解成一个个小项目，每个小项目都标识一个或多个主要风险，直到所有的主要风险因素都被确定。<br>螺旋模型特别适用于庞大而复杂、具有高风险的系统。<br><img src="/images/ruankao/2-3.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line">螺旋模型支持需求的动态变化，为用户的关键决策提供了方便，有助于需求准确性；为项目管理决策调整提供了便利，从而降低软件开发风险。</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">需要具有相当丰富的风险评估经验和专业知识，如果未能及时标识风险，势必会造成重大损失。</span><br><span class="line">过多的迭代次数会增加开发成本，延迟提交时间。</span><br></pre></td></tr></table></figure><h1 id="构件组装模型"><a href="#构件组装模型" class="headerlink" title="构件组装模型"></a>构件组装模型</h1><p>利用软构件进行搭积木的方式开发。<br><img src="/images/ruankao/2-4.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line">让系统扩展更容易</span><br><span class="line">构件更容易被重用，降低软件开发成本</span><br><span class="line">构件粒度较小，开发任务更灵活，可用若干小组并行开发。</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">需要经验丰富的架构师，设计不好的构件难以实现构件的优点，降低构件组装模型的重用度。</span><br><span class="line">在考虑重用度的时候，往往会在其他方面让步，比如性能。</span><br><span class="line">使用构件的时候，要求开发人员熟练掌握构件，增加了开发人员的学习成本。</span><br><span class="line">第三方构件的质量难以掌握，且会最终影响软件的质量。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-开发方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发方法（四）敏捷方法</title>
      <link href="/2021/09/16/%E8%BD%AF%E8%80%83/6%E3%80%81%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E6%95%8F%E6%8D%B7%E6%96%B9%E6%B3%95/"/>
      <url>/2021/09/16/%E8%BD%AF%E8%80%83/6%E3%80%81%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E6%95%8F%E6%8D%B7%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>进阶方法包括极限编程、自适应开发、水晶方法、特征驱动开发等，他们都认为传统的软件工程方法文档量太“重”了，成为“重量级”方法，而敏捷方法则是“轻量级”方法。</p><h1 id="一、极限编程"><a href="#一、极限编程" class="headerlink" title="一、极限编程"></a>一、极限编程</h1><p>极限编程由价值观、原则、实践和行为四个部分组成，它们彼此相互依赖、关联，并通过行为贯穿于整个生命周期。</p><h2 id="四大价值观"><a href="#四大价值观" class="headerlink" title="四大价值观"></a>四大价值观</h2><h3 id="沟通"><a href="#沟通" class="headerlink" title="沟通"></a>沟通</h3><p>如果小组成员之间无法做到持续的、无间断的交流，那么协作就无从谈起。</p><h3 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h3><p>“够用即好”，尽量地简单化。</p><h3 id="反馈"><a href="#反馈" class="headerlink" title="反馈"></a>反馈</h3><p>向团队内部、客户、管理层反馈，通过持续、明确的反馈来暴露软件状态的问题。</p><h3 id="勇气"><a href="#勇气" class="headerlink" title="勇气"></a>勇气</h3><p>每时每刻都在变化，需要有勇气来面对快速开发，甚至重新开发。<br>在四大价值观之下，隐藏着一种更深刻的东西，那就是尊重。因为这一切都建立在团队成员之间相互关心、相互理解的基础之上。</p><h2 id="五大原则"><a href="#五大原则" class="headerlink" title="五大原则"></a>五大原则</h2><p>快速反馈<br>简单性假设<br>逐步修改<br>提倡更改<br>优质工作</p><h2 id="12个最佳实践"><a href="#12个最佳实践" class="headerlink" title="12个最佳实践"></a>12个最佳实践</h2><h3 id="计划游戏"><a href="#计划游戏" class="headerlink" title="计划游戏"></a>计划游戏</h3><p>先快速指定一份概要的计划，随着细节不断清晰，在逐步完善计划。</p><h3 id="小型发布"><a href="#小型发布" class="headerlink" title="小型发布"></a>小型发布</h3><p>持续集成，小步快走</p><h3 id="隐喻"><a href="#隐喻" class="headerlink" title="隐喻"></a>隐喻</h3><h3 id="简单设计"><a href="#简单设计" class="headerlink" title="简单设计"></a>简单设计</h3><p>简单不是忽略设计，而是认为设计不应该在编码前一次性完成。</p><h3 id="测试先行"><a href="#测试先行" class="headerlink" title="测试先行"></a>测试先行</h3><h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><p>要有重构的勇气，目的是降低变化引起的风险、使得代码优化更加容易。</p><h3 id="结对编程"><a href="#结对编程" class="headerlink" title="结对编程"></a>结对编程</h3><p>降低了沟通成本，提高了工作质量。</p><h3 id="集体代码所有制"><a href="#集体代码所有制" class="headerlink" title="集体代码所有制"></a>集体代码所有制</h3><p>每个人都拥有全部代码，也都需要对全部代码负责。</p><h3 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h3><h3 id="每周工作40小时"><a href="#每周工作40小时" class="headerlink" title="每周工作40小时"></a>每周工作40小时</h3><h3 id="现场客户"><a href="#现场客户" class="headerlink" title="现场客户"></a>现场客户</h3><p>将客户请到现场，时刻保证“客户负责业务决策，开发团队负责技术决策”。</p><h3 id="编码标准"><a href="#编码标准" class="headerlink" title="编码标准"></a>编码标准</h3><p>确保代码清晰，便于交流指导。</p><h1 id="二、特征驱动开发FDD"><a href="#二、特征驱动开发FDD" class="headerlink" title="二、特征驱动开发FDD"></a>二、特征驱动开发FDD</h1><p>FDD也是一个迭代的开发模型，弱化了过程在软件开发的地位。FDD强调软件开发不可缺少的三个要素：人、过程、技术。</p><h2 id="FDD角色"><a href="#FDD角色" class="headerlink" title="FDD角色"></a>FDD角色</h2><h3 id="项目经理"><a href="#项目经理" class="headerlink" title="项目经理"></a>项目经理</h3><p>是开发的组织者，同时对外沟通</p><h3 id="首席架构设计师"><a href="#首席架构设计师" class="headerlink" title="首席架构设计师"></a>首席架构设计师</h3><p>系统架构设计</p><h3 id="开发经理"><a href="#开发经理" class="headerlink" title="开发经理"></a>开发经理</h3><p>负责团队日常开发，解决开发中的技术问题和资源冲突。</p><h3 id="主程序员"><a href="#主程序员" class="headerlink" title="主程序员"></a>主程序员</h3><p>带领小组完成特征的详细设计和构建工作，要求有一定工作经验病能带动小组工作。</p><h3 id="程序员"><a href="#程序员" class="headerlink" title="程序员"></a>程序员</h3><p>开发</p><h3 id="领域专家"><a href="#领域专家" class="headerlink" title="领域专家"></a>领域专家</h3><p>对业务领域精通的人，一般是客户、系统分析员等。</p><p><img src="/images/ruankao/3-3.png"></p><h2 id="FDD核心过程"><a href="#FDD核心过程" class="headerlink" title="FDD核心过程"></a>FDD核心过程</h2><h3 id="开发整体对象模型"><a href="#开发整体对象模型" class="headerlink" title="开发整体对象模型"></a>开发整体对象模型</h3><p>业务建模，强调系统的完整地面向对象建模。</p><h3 id="构造特征列表"><a href="#构造特征列表" class="headerlink" title="构造特征列表"></a>构造特征列表</h3><p>特征是一个小的、对客户有价值的功能，特征包括动作、结果、目标，颗粒度最好在两周之内。</p><h3 id="计划特征开发"><a href="#计划特征开发" class="headerlink" title="计划特征开发"></a>计划特征开发</h3><p>项目经理根据特征列表、特征之间的关系安排开发任务。</p><h3 id="特征设计"><a href="#特征设计" class="headerlink" title="特征设计"></a>特征设计</h3><p>主程序员带领小组进行详细设计，为构建做准备。</p><h3 id="特征构建"><a href="#特征构建" class="headerlink" title="特征构建"></a>特征构建</h3><p>特征设计和构建合起来就是实现阶段，这两个阶段反复迭代，直到开发完成。</p><p>FDD主张个体所有对系统开发更有帮助。</p><h1 id="三、Scrum"><a href="#三、Scrum" class="headerlink" title="三、Scrum"></a>三、Scrum</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">特点：</span><br><span class="line">Scrum是一个增量的、迭代的开发过程。</span><br><span class="line">整个开发过程由多个短的迭代周期（Sprint）组成，每个周期建议2-4周。</span><br><span class="line">由Backlog管理产品需求，Backlog是按商业价值排序的需求列表，每个需求通常是一个故事。</span><br><span class="line">总是优先开发最客户最有价值的需求。</span><br></pre></td></tr></table></figure><p><img src="/images/ruankao/3-4.png"></p><h2 id="（1）五个活动"><a href="#（1）五个活动" class="headerlink" title="（1）五个活动"></a>（1）五个活动</h2><h3 id="产品待办事项列表梳理"><a href="#产品待办事项列表梳理" class="headerlink" title="产品待办事项列表梳理"></a>产品待办事项列表梳理</h3><h3 id="Sprint计划会议"><a href="#Sprint计划会议" class="headerlink" title="Sprint计划会议"></a>Sprint计划会议</h3><p>固定时长：推荐时长是每周对应两小时或者更少。<br>一、需要完成那些工作：由开发团队根据当前产品增量的状态、团队过去的工作情况、团队生产力及代办事项优先级决定。<br>二、如何完成工作：工作拆分成小的单元，每个单元不超过一天。</p><h3 id="每日Scrum会议"><a href="#每日Scrum会议" class="headerlink" title="每日Scrum会议"></a>每日Scrum会议</h3><p>团队内部沟通<br>固定时长，不超过15分钟<br>我完成了什么，我要做什么，我的阻碍</p><h3 id="Sprint评审会议"><a href="#Sprint评审会议" class="headerlink" title="Sprint评审会议"></a>Sprint评审会议</h3><p>固定时长：推荐时长是每周对应一个小时。<br>会议邀请其他相关干系人参加。<br>会议内容：演示产品增量、新想法，调整产品待办事项列表。</p><h3 id="Sprint回顾会议"><a href="#Sprint回顾会议" class="headerlink" title="Sprint回顾会议"></a>Sprint回顾会议</h3><p>固定时长：推荐时长是每周对应一个小时。<br>回顾团队在流程人际关系及工具方面做得情况，识别出好的，不好的，找出潜在改进事项。</p><h2 id="（2）五大价值观"><a href="#（2）五大价值观" class="headerlink" title="（2）五大价值观"></a>（2）五大价值观</h2><h3 id="承诺"><a href="#承诺" class="headerlink" title="承诺"></a>承诺</h3><p>愿意对目标作出承诺</p><h3 id="专注"><a href="#专注" class="headerlink" title="专注"></a>专注</h3><p>把心思和能力用到承诺的工作上</p><h3 id="开放"><a href="#开放" class="headerlink" title="开放"></a>开放</h3><p>项目中的一切开放给每个人看</p><h3 id="尊重"><a href="#尊重" class="headerlink" title="尊重"></a>尊重</h3><p>每个人都有他独特的背景和经验</p><h3 id="勇气-1"><a href="#勇气-1" class="headerlink" title="勇气"></a>勇气</h3><p>有勇气做出承诺，履行承诺，接受别人的尊重</p><h1 id="四、水晶方法Crystal"><a href="#四、水晶方法Crystal" class="headerlink" title="四、水晶方法Crystal"></a>四、水晶方法Crystal</h1><p>水晶方法Crystal家族包括Crystal Clear、Crystal Yellow、Crystal Orange、Crystal Red。<br>最常用的是Crystal Clear——透明水晶方法。<br>透明水晶方法七大体系特征</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">经常交付</span><br><span class="line">反思改进</span><br><span class="line">渗透式交流</span><br><span class="line">个人安全</span><br><span class="line">焦点</span><br><span class="line">与专家用户建立方便的联系</span><br><span class="line">配有自动测试、配置管理和经常集成功能的技术环境</span><br></pre></td></tr></table></figure><h1 id="五、其他敏捷方法"><a href="#五、其他敏捷方法" class="headerlink" title="五、其他敏捷方法"></a>五、其他敏捷方法</h1><p>开放式源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开发人员地域分布广</span><br><span class="line">查错排障高度并行，任何人都可以将补丁发给维护人</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软考-系统架构设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考-开发方法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
